var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/* Generated from Java with JSweet 2.0.0-rc1 - http://www.jsweet.org */
var def;
(function (def) {
    var Color = (function () {
        function Color(r, g, b) {
            this.redValue = 0;
            this.greenValue = 0;
            this.blueValue = 0;
            this.redValue = r;
            this.greenValue = g;
            this.blueValue = b;
        }
        Color.white_$LI$ = function () { if (Color.white == null)
            Color.white = new Color(255, 255, 255); return Color.white; };
        ;
        Color.WHITE_$LI$ = function () { if (Color.WHITE == null)
            Color.WHITE = Color.white_$LI$(); return Color.WHITE; };
        ;
        Color.lightGray_$LI$ = function () { if (Color.lightGray == null)
            Color.lightGray = new Color(192, 192, 192); return Color.lightGray; };
        ;
        Color.LIGHT_GRAY_$LI$ = function () { if (Color.LIGHT_GRAY == null)
            Color.LIGHT_GRAY = Color.lightGray_$LI$(); return Color.LIGHT_GRAY; };
        ;
        Color.gray_$LI$ = function () { if (Color.gray == null)
            Color.gray = new Color(128, 128, 128); return Color.gray; };
        ;
        Color.GRAY_$LI$ = function () { if (Color.GRAY == null)
            Color.GRAY = Color.gray_$LI$(); return Color.GRAY; };
        ;
        Color.darkGray_$LI$ = function () { if (Color.darkGray == null)
            Color.darkGray = new Color(64, 64, 64); return Color.darkGray; };
        ;
        Color.DARK_GRAY_$LI$ = function () { if (Color.DARK_GRAY == null)
            Color.DARK_GRAY = Color.darkGray_$LI$(); return Color.DARK_GRAY; };
        ;
        Color.black_$LI$ = function () { if (Color.black == null)
            Color.black = new Color(0, 0, 0); return Color.black; };
        ;
        Color.BLACK_$LI$ = function () { if (Color.BLACK == null)
            Color.BLACK = Color.black_$LI$(); return Color.BLACK; };
        ;
        Color.red_$LI$ = function () { if (Color.red == null)
            Color.red = new Color(255, 0, 0); return Color.red; };
        ;
        Color.RED_$LI$ = function () { if (Color.RED == null)
            Color.RED = Color.red_$LI$(); return Color.RED; };
        ;
        Color.pink_$LI$ = function () { if (Color.pink == null)
            Color.pink = new Color(255, 175, 175); return Color.pink; };
        ;
        Color.PINK_$LI$ = function () { if (Color.PINK == null)
            Color.PINK = Color.pink_$LI$(); return Color.PINK; };
        ;
        Color.orange_$LI$ = function () { if (Color.orange == null)
            Color.orange = new Color(255, 200, 0); return Color.orange; };
        ;
        Color.ORANGE_$LI$ = function () { if (Color.ORANGE == null)
            Color.ORANGE = Color.orange_$LI$(); return Color.ORANGE; };
        ;
        Color.yellow_$LI$ = function () { if (Color.yellow == null)
            Color.yellow = new Color(255, 255, 0); return Color.yellow; };
        ;
        Color.YELLOW_$LI$ = function () { if (Color.YELLOW == null)
            Color.YELLOW = Color.yellow_$LI$(); return Color.YELLOW; };
        ;
        Color.green_$LI$ = function () { if (Color.green == null)
            Color.green = new Color(0, 255, 0); return Color.green; };
        ;
        Color.GREEN_$LI$ = function () { if (Color.GREEN == null)
            Color.GREEN = Color.green_$LI$(); return Color.GREEN; };
        ;
        Color.magenta_$LI$ = function () { if (Color.magenta == null)
            Color.magenta = new Color(255, 0, 255); return Color.magenta; };
        ;
        Color.MAGENTA_$LI$ = function () { if (Color.MAGENTA == null)
            Color.MAGENTA = Color.magenta_$LI$(); return Color.MAGENTA; };
        ;
        Color.cyan_$LI$ = function () { if (Color.cyan == null)
            Color.cyan = new Color(0, 255, 255); return Color.cyan; };
        ;
        Color.CYAN_$LI$ = function () { if (Color.CYAN == null)
            Color.CYAN = Color.cyan_$LI$(); return Color.CYAN; };
        ;
        Color.blue_$LI$ = function () { if (Color.blue == null)
            Color.blue = new Color(0, 0, 255); return Color.blue; };
        ;
        Color.BLUE_$LI$ = function () { if (Color.BLUE == null)
            Color.BLUE = Color.blue_$LI$(); return Color.BLUE; };
        ;
        Color.prototype.getRed = function () {
            return this.redValue;
        };
        Color.prototype.getGreen = function () {
            return this.greenValue;
        };
        Color.prototype.getBlue = function () {
            return this.blueValue;
        };
        return Color;
    }());
    def.Color = Color;
    Color["__class"] = "def.Color";
})(def || (def = {}));
(function (def) {
    var ConsoleOutputWriter = (function () {
        function ConsoleOutputWriter(filename) {
            this.fileName = null;
            this.buffer = null;
            this.fileName = filename;
            this.buffer = { str: "", toString: function () { return this.str; } };
        }
        /**
         *
         * @param {string} s
         */
        ConsoleOutputWriter.prototype.write = function (s) {
            /* append */ (function (sb) { return sb.str = sb.str.concat(s); })(this.buffer);
        };
        /**
         *
         */
        ConsoleOutputWriter.prototype.flush = function () {
        };
        /**
         *
         */
        ConsoleOutputWriter.prototype.close = function () {
            console.info("=== CONSOLE OUTPUT WRITER || START ===");
            console.info(/* toString */ this.buffer.str);
            console.info("=== CONSOLE OUTPUT WRITER || END ===");
        };
        return ConsoleOutputWriter;
    }());
    def.ConsoleOutputWriter = ConsoleOutputWriter;
    ConsoleOutputWriter["__class"] = "def.ConsoleOutputWriter";
    ConsoleOutputWriter["__interfaces"] = ["def.OutputWriter"];
})(def || (def = {}));
(function (def) {
    var File = (function () {
        function File() {
        }
        return File;
    }());
    File.separator = "/";
    def.File = File;
    File["__class"] = "def.File";
})(def || (def = {}));
(function (def) {
    var Integer = (function () {
        function Integer() {
        }
        Integer.toHexString = function (value) {
            return Integer.toUnsignedRadixString(value, 16);
        };
        /*private*/ Integer.toUnsignedRadixString = function (value, radix) {
            return ((value >>> 0).toString(radix));
        };
        return Integer;
    }());
    def.Integer = Integer;
    Integer["__class"] = "def.Integer";
})(def || (def = {}));
(function (def) {
    var MersenneTwisterRandomGeneratorJS = (function () {
        function MersenneTwisterRandomGeneratorJS(seed) {
            this.random = null;
            this.setSeed(seed);
        }
        /**
         *
         * @return {number}
         */
        MersenneTwisterRandomGeneratorJS.prototype.nextDouble = function () {
            return this.random.real(0, 1, true);
        };
        /**
         *
         * @param {number} seed
         */
        MersenneTwisterRandomGeneratorJS.prototype.setSeed = function (seed) {
            var s = (Random.engines.mt19937);
            var mt19937 = (function (target) { return (typeof target === 'function') ? target() : target.get(); })(s);
            mt19937.seed(42);
            this.random = new Random(mt19937);
        };
        return MersenneTwisterRandomGeneratorJS;
    }());
    def.MersenneTwisterRandomGeneratorJS = MersenneTwisterRandomGeneratorJS;
    MersenneTwisterRandomGeneratorJS["__class"] = "def.MersenneTwisterRandomGeneratorJS";
    MersenneTwisterRandomGeneratorJS["__interfaces"] = ["desmoj.core.dist.UniformRandomGenerator"];
})(def || (def = {}));
(function (def) {
    var NumberValueHelper = (function () {
        function NumberValueHelper() {
        }
        NumberValueHelper.doubleValue = function (number) {
            return number;
        };
        NumberValueHelper.floatValue = function (number) {
            return number;
        };
        NumberValueHelper.intValue = function (number) {
            return ((number | 0) | 0);
        };
        NumberValueHelper.longValue = function (number) {
            return Math.floor(number);
        };
        return NumberValueHelper;
    }());
    NumberValueHelper.INT_MAX_VALUE = 2147483647;
    NumberValueHelper.INT_MIN_VALUE = -2147483648;
    def.NumberValueHelper = NumberValueHelper;
    NumberValueHelper["__class"] = "def.NumberValueHelper";
})(def || (def = {}));
(function (def) {
    var Observable = (function () {
        function Observable() {
            this.changed = false;
            this.obs = null;
            this.obs = ([]);
        }
        Observable.prototype.addObserver = function (o) {
            /* add */ (this.obs.push(o) > 0);
        };
        Observable.prototype.deleteObserver = function (o) {
            /* remove */ (function (a) { return a.splice(a.indexOf(o), 1); })(this.obs);
        };
        Observable.prototype.notifyObservers = function () {
            if (this.changed) {
                for (var index756 = 0; index756 < this.obs.length; index756++) {
                    var observer = this.obs[index756];
                    {
                        observer.update(this, null);
                    }
                }
            }
        };
        Observable.prototype.notifyObserversWithArgument = function (arg) {
            if (this.changed) {
                for (var index757 = 0; index757 < this.obs.length; index757++) {
                    var observer = this.obs[index757];
                    {
                        observer.update(this, arg);
                    }
                }
            }
        };
        Observable.prototype.deleteObservers = function () {
            /* clear */ (this.obs.length = 0);
        };
        Observable.prototype.setChanged = function () {
            this.changed = true;
        };
        Observable.prototype.clearChanged = function () {
            this.changed = false;
        };
        Observable.prototype.hasChanged = function () {
            return this.changed;
        };
        Observable.prototype.countObservers = function () {
            return this.obs.length;
        };
        return Observable;
    }());
    def.Observable = Observable;
    Observable["__class"] = "def.Observable";
})(def || (def = {}));
(function (def) {
    var Random = (function () {
        function Random(seed) {
            this.random = null;
            this.setSeed(seed);
        }
        /**
         * Makes this Random use a random seed similar to a Java Random instantiated with Random()
         */
        Random.prototype.autoSeed = function () {
            var s = (Random.engines.mt19937);
            var mt19937 = (function (target) { return (typeof target === 'function') ? target() : target.get(); })(s);
            mt19937.autoSeed();
            this.random = new Random(mt19937);
        };
        Random.prototype.setSeed = function (seed) {
            var s = (Random.engines.mt19937);
            var mt19937 = (function (target) { return (typeof target === 'function') ? target() : target.get(); })(s);
            mt19937.seed(seed);
            this.random = new Random(mt19937);
        };
        Random.prototype.nextInt = function () {
            return (this.random.integer(def.NumberValueHelper.INT_MIN_VALUE, def.NumberValueHelper.INT_MAX_VALUE) | 0);
        };
        Random.prototype.nextIntWithBound = function (bound) {
            return (this.random.integer(0, bound) | 0);
        };
        Random.prototype.nextDouble = function () {
            return this.random.real(0, 1, true);
        };
        return Random;
    }());
    def.Random = Random;
    Random["__class"] = "def.Random";
})(def || (def = {}));
(function (def) {
    var System = (function () {
        function System() {
        }
        System.nanoTime = function () {
            var date = new Date();
            return Math.floor(date.getMilliseconds()) * 1000000;
        };
        System.currentTimeMillis = function () {
            var date = new Date();
            return Math.floor(date.getMilliseconds());
        };
        System.getProperty = function (key) {
            switch ((key)) {
                case "line.separator":
                    return "/";
                default:
                    return null;
            }
        };
        return System;
    }());
    def.System = System;
    System["__class"] = "def.System";
})(def || (def = {}));
(function (def) {
    /**
     * A {@code TimeUnit} represents time durations at a given unit of
     * granularity and provides utility methods to convert across units,
     * and to perform timing and delay operations in these units.  A
     * {@code TimeUnit} does not maintain time information, but only
     * helps organize and use time representations that may be maintained
     * separately across various contexts.  A nanosecond is defined as one
     * thousandth of a microsecond, a microsecond as one thousandth of a
     * millisecond, a millisecond as one thousandth of a second, a minute
     * as sixty seconds, an hour as sixty minutes, and a day as twenty four
     * hours.
     *
     * <p>A {@code TimeUnit} is mainly used to inform time-based methods
     * how a given timing parameter should be interpreted. For example,
     * the following code will timeout in 50 milliseconds if the {@link
     * java.util.concurrent.locks.Lock} is not available:
     *
     * <pre> {@code
     * Lock lock = ...;
     * if (lock.tryLock(50L, TimeUnit.MILLISECONDS)) ...}</pre>
     *
     * while this code will timeout in 50 seconds:
     * <pre> {@code
     * Lock lock = ...;
     * if (lock.tryLock(50L, TimeUnit.SECONDS)) ...}</pre>
     *
     * Note however, that there is no guarantee that a particular timeout
     * implementation will be able to notice the passage of time at the
     * same granularity as the given {@code TimeUnit}.
     *
     * @since 1.5
     * @author Doug Lea
     * @enum
     * @property {def.TimeUnit} NANOSECONDS
     * Time unit representing one thousandth of a microsecond
     * @property {def.TimeUnit} MICROSECONDS
     * Time unit representing one thousandth of a millisecond
     * @property {def.TimeUnit} MILLISECONDS
     * Time unit representing one thousandth of a second
     * @property {def.TimeUnit} SECONDS
     * Time unit representing one second
     * @property {def.TimeUnit} MINUTES
     * Time unit representing sixty seconds
     * @property {def.TimeUnit} HOURS
     * Time unit representing sixty minutes
     * @property {def.TimeUnit} DAYS
     * Time unit representing twenty four hours
     * @class
     */
    var TimeUnit;
    (function (TimeUnit) {
        /**
         * Time unit representing one thousandth of a microsecond
         */
        TimeUnit[TimeUnit["NANOSECONDS"] = 0] = "NANOSECONDS";
        /**
         * Time unit representing one thousandth of a millisecond
         */
        TimeUnit[TimeUnit["MICROSECONDS"] = 1] = "MICROSECONDS";
        /**
         * Time unit representing one thousandth of a second
         */
        TimeUnit[TimeUnit["MILLISECONDS"] = 2] = "MILLISECONDS";
        /**
         * Time unit representing one second
         */
        TimeUnit[TimeUnit["SECONDS"] = 3] = "SECONDS";
        /**
         * Time unit representing sixty seconds
         */
        TimeUnit[TimeUnit["MINUTES"] = 4] = "MINUTES";
        /**
         * Time unit representing sixty minutes
         */
        TimeUnit[TimeUnit["HOURS"] = 5] = "HOURS";
        /**
         * Time unit representing twenty four hours
         */
        TimeUnit[TimeUnit["DAYS"] = 6] = "DAYS";
    })(TimeUnit = def.TimeUnit || (def.TimeUnit = {}));
    /** @ignore */
    var TimeUnit_$WRAPPER = (function () {
        function TimeUnit_$WRAPPER(_$ordinal, _$name) {
            this._$ordinal = _$ordinal;
            this._$name = _$name;
        }
        TimeUnit_$WRAPPER.C0_$LI$ = function () { if (TimeUnit_$WRAPPER.C0 == null)
            TimeUnit_$WRAPPER.C0 = 1 * 1; return TimeUnit_$WRAPPER.C0; };
        ;
        TimeUnit_$WRAPPER.C1_$LI$ = function () { if (TimeUnit_$WRAPPER.C1 == null)
            TimeUnit_$WRAPPER.C1 = TimeUnit_$WRAPPER.C0_$LI$() * 1000; return TimeUnit_$WRAPPER.C1; };
        ;
        TimeUnit_$WRAPPER.C2_$LI$ = function () { if (TimeUnit_$WRAPPER.C2 == null)
            TimeUnit_$WRAPPER.C2 = TimeUnit_$WRAPPER.C1_$LI$() * 1000; return TimeUnit_$WRAPPER.C2; };
        ;
        TimeUnit_$WRAPPER.C3_$LI$ = function () { if (TimeUnit_$WRAPPER.C3 == null)
            TimeUnit_$WRAPPER.C3 = TimeUnit_$WRAPPER.C2_$LI$() * 1000; return TimeUnit_$WRAPPER.C3; };
        ;
        TimeUnit_$WRAPPER.C4_$LI$ = function () { if (TimeUnit_$WRAPPER.C4 == null)
            TimeUnit_$WRAPPER.C4 = TimeUnit_$WRAPPER.C3_$LI$() * 60; return TimeUnit_$WRAPPER.C4; };
        ;
        TimeUnit_$WRAPPER.C5_$LI$ = function () { if (TimeUnit_$WRAPPER.C5 == null)
            TimeUnit_$WRAPPER.C5 = TimeUnit_$WRAPPER.C4_$LI$() * 60; return TimeUnit_$WRAPPER.C5; };
        ;
        TimeUnit_$WRAPPER.C6_$LI$ = function () { if (TimeUnit_$WRAPPER.C6 == null)
            TimeUnit_$WRAPPER.C6 = TimeUnit_$WRAPPER.C5_$LI$() * 24; return TimeUnit_$WRAPPER.C6; };
        ;
        TimeUnit_$WRAPPER.MAX_$LI$ = function () { if (TimeUnit_$WRAPPER.MAX == null)
            TimeUnit_$WRAPPER.MAX = Number.MAX_VALUE; return TimeUnit_$WRAPPER.MAX; };
        ;
        /**
         * Scale d by m, checking for overflow.
         * This has a short name to make above code more readable.
         * @param {number} d
         * @param {number} m
         * @param {number} over
         * @return {number}
         */
        TimeUnit_$WRAPPER.x = function (d, m, over) {
            if (d > over)
                return Number.MAX_VALUE;
            if (d < -over)
                return Number.MIN_VALUE;
            return d * m;
        };
        /**
         * Converts the given time duration in the given unit to this unit.
         * Conversions from finer to coarser granularities truncate, so
         * lose precision. For example, converting {@code 999} milliseconds
         * to seconds results in {@code 0}. Conversions from coarser to
         * finer granularities with arguments that would numerically
         * overflow saturate to {@code Long.MIN_VALUE} if negative or
         * {@code Long.MAX_VALUE} if positive.
         *
         * <p>For example, to convert 10 minutes to milliseconds, use:
         * {@code TimeUnit.MILLISECONDS.convert(10L, TimeUnit.MINUTES)}
         *
         * @param {number} sourceDuration the time duration in the given {@code sourceUnit}
         * @param {def.TimeUnit} sourceUnit the unit of the {@code sourceDuration} argument
         * @return {number} the converted duration in this unit,
         * or {@code Long.MIN_VALUE} if conversion would negatively
         * overflow, or {@code Long.MAX_VALUE} if it would positively overflow.
         */
        TimeUnit_$WRAPPER.prototype.convert = function (sourceDuration, sourceUnit) {
            throw Object.defineProperty(new Error(), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.LinkageError', 'java.lang.IncompatibleClassChangeError', 'java.lang.Error', 'java.lang.AbstractMethodError', 'java.lang.Object'] });
        };
        /**
         * Equivalent to
         * {@link #convert(long, TimeUnit) NANOSECONDS.convert(duration, this)}.
         * @param {number} duration the duration
         * @return {number} the converted duration,
         * or {@code Long.MIN_VALUE} if conversion would negatively
         * overflow, or {@code Long.MAX_VALUE} if it would positively overflow.
         */
        TimeUnit_$WRAPPER.prototype.toNanos = function (duration) {
            throw Object.defineProperty(new Error(), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.LinkageError', 'java.lang.IncompatibleClassChangeError', 'java.lang.Error', 'java.lang.AbstractMethodError', 'java.lang.Object'] });
        };
        /**
         * Equivalent to
         * {@link #convert(long, TimeUnit) MICROSECONDS.convert(duration, this)}.
         * @param {number} duration the duration
         * @return {number} the converted duration,
         * or {@code Long.MIN_VALUE} if conversion would negatively
         * overflow, or {@code Long.MAX_VALUE} if it would positively overflow.
         */
        TimeUnit_$WRAPPER.prototype.toMicros = function (duration) {
            throw Object.defineProperty(new Error(), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.LinkageError', 'java.lang.IncompatibleClassChangeError', 'java.lang.Error', 'java.lang.AbstractMethodError', 'java.lang.Object'] });
        };
        /**
         * Equivalent to
         * {@link #convert(long, TimeUnit) MILLISECONDS.convert(duration, this)}.
         * @param {number} duration the duration
         * @return {number} the converted duration,
         * or {@code Long.MIN_VALUE} if conversion would negatively
         * overflow, or {@code Long.MAX_VALUE} if it would positively overflow.
         */
        TimeUnit_$WRAPPER.prototype.toMillis = function (duration) {
            throw Object.defineProperty(new Error(), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.LinkageError', 'java.lang.IncompatibleClassChangeError', 'java.lang.Error', 'java.lang.AbstractMethodError', 'java.lang.Object'] });
        };
        /**
         * Equivalent to
         * {@link #convert(long, TimeUnit) SECONDS.convert(duration, this)}.
         * @param {number} duration the duration
         * @return {number} the converted duration,
         * or {@code Long.MIN_VALUE} if conversion would negatively
         * overflow, or {@code Long.MAX_VALUE} if it would positively overflow.
         */
        TimeUnit_$WRAPPER.prototype.toSeconds = function (duration) {
            throw Object.defineProperty(new Error(), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.LinkageError', 'java.lang.IncompatibleClassChangeError', 'java.lang.Error', 'java.lang.AbstractMethodError', 'java.lang.Object'] });
        };
        /**
         * Equivalent to
         * {@link #convert(long, TimeUnit) MINUTES.convert(duration, this)}.
         * @param {number} duration the duration
         * @return {number} the converted duration,
         * or {@code Long.MIN_VALUE} if conversion would negatively
         * overflow, or {@code Long.MAX_VALUE} if it would positively overflow.
         * @since 1.6
         */
        TimeUnit_$WRAPPER.prototype.toMinutes = function (duration) {
            throw Object.defineProperty(new Error(), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.LinkageError', 'java.lang.IncompatibleClassChangeError', 'java.lang.Error', 'java.lang.AbstractMethodError', 'java.lang.Object'] });
        };
        /**
         * Equivalent to
         * {@link #convert(long, TimeUnit) HOURS.convert(duration, this)}.
         * @param {number} duration the duration
         * @return {number} the converted duration,
         * or {@code Long.MIN_VALUE} if conversion would negatively
         * overflow, or {@code Long.MAX_VALUE} if it would positively overflow.
         * @since 1.6
         */
        TimeUnit_$WRAPPER.prototype.toHours = function (duration) {
            throw Object.defineProperty(new Error(), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.LinkageError', 'java.lang.IncompatibleClassChangeError', 'java.lang.Error', 'java.lang.AbstractMethodError', 'java.lang.Object'] });
        };
        /**
         * Equivalent to
         * {@link #convert(long, TimeUnit) DAYS.convert(duration, this)}.
         * @param {number} duration the duration
         * @return {number} the converted duration
         * @since 1.6
         */
        TimeUnit_$WRAPPER.prototype.toDays = function (duration) {
            throw Object.defineProperty(new Error(), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.LinkageError', 'java.lang.IncompatibleClassChangeError', 'java.lang.Error', 'java.lang.AbstractMethodError', 'java.lang.Object'] });
        };
        /**
         * Implementation of compareTo() method in enum types.
         * compareTo() is not transpiled by JSweet and therefore has to be reimplemented
         * Method name has to be different since compareTo() in enums is final and can't be overwritten
         * @param {def.TimeUnit} u
         * @return {number} distance of this to constant u
         */
        TimeUnit_$WRAPPER.prototype.compareTo2 = function (u) {
            return this.ordinal() - def.TimeUnit[def.TimeUnit[u]];
        };
        TimeUnit_$WRAPPER.prototype.name = function () { return this._$name; };
        TimeUnit_$WRAPPER.prototype.ordinal = function () { return this._$ordinal; };
        return TimeUnit_$WRAPPER;
    }());
    def.TimeUnit_$WRAPPER = TimeUnit_$WRAPPER;
    TimeUnit["__class"] = "def.TimeUnit";
    TimeUnit["__interfaces"] = ["java.lang.Comparable", "java.io.Serializable"];
    (function (TimeUnit) {
        /** @ignore */
        var TimeUnit$0_$WRAPPER = (function (_super) {
            __extends(TimeUnit$0_$WRAPPER, _super);
            function TimeUnit$0_$WRAPPER(_$ordinal, _$name) {
                return _super.call(this, _$ordinal, _$name) || this;
            }
            TimeUnit$0_$WRAPPER.prototype.toNanos = function (d) {
                return d;
            };
            TimeUnit$0_$WRAPPER.prototype.toMicros = function (d) {
                return Math.floor(d / (Math.floor(def.TimeUnit_$WRAPPER.C1_$LI$() / def.TimeUnit_$WRAPPER.C0_$LI$())));
            };
            TimeUnit$0_$WRAPPER.prototype.toMillis = function (d) {
                return Math.floor(d / (Math.floor(def.TimeUnit_$WRAPPER.C2_$LI$() / def.TimeUnit_$WRAPPER.C0_$LI$())));
            };
            TimeUnit$0_$WRAPPER.prototype.toSeconds = function (d) {
                return Math.floor(d / (Math.floor(def.TimeUnit_$WRAPPER.C3_$LI$() / def.TimeUnit_$WRAPPER.C0_$LI$())));
            };
            TimeUnit$0_$WRAPPER.prototype.toMinutes = function (d) {
                return Math.floor(d / (Math.floor(def.TimeUnit_$WRAPPER.C4_$LI$() / def.TimeUnit_$WRAPPER.C0_$LI$())));
            };
            TimeUnit$0_$WRAPPER.prototype.toHours = function (d) {
                return Math.floor(d / (Math.floor(def.TimeUnit_$WRAPPER.C5_$LI$() / def.TimeUnit_$WRAPPER.C0_$LI$())));
            };
            TimeUnit$0_$WRAPPER.prototype.toDays = function (d) {
                return Math.floor(d / (Math.floor(def.TimeUnit_$WRAPPER.C6_$LI$() / def.TimeUnit_$WRAPPER.C0_$LI$())));
            };
            TimeUnit$0_$WRAPPER.prototype.convert = function (d, u) {
                return def.TimeUnit["_$wrappers"][u].toNanos(d);
            };
            TimeUnit$0_$WRAPPER.prototype.excessNanos = function (d, m) {
                return ((d - (m * def.TimeUnit_$WRAPPER.C2_$LI$())) | 0);
            };
            return TimeUnit$0_$WRAPPER;
        }(TimeUnit_$WRAPPER));
        TimeUnit.TimeUnit$0_$WRAPPER = TimeUnit$0_$WRAPPER;
        /** @ignore */
        var TimeUnit$1_$WRAPPER = (function (_super) {
            __extends(TimeUnit$1_$WRAPPER, _super);
            function TimeUnit$1_$WRAPPER(_$ordinal, _$name) {
                return _super.call(this, _$ordinal, _$name) || this;
            }
            TimeUnit$1_$WRAPPER.prototype.toNanos = function (d) {
                return TimeUnit_$WRAPPER.x(d, Math.floor(def.TimeUnit_$WRAPPER.C1_$LI$() / def.TimeUnit_$WRAPPER.C0_$LI$()), Math.floor(def.TimeUnit_$WRAPPER.MAX_$LI$() / (Math.floor(def.TimeUnit_$WRAPPER.C1_$LI$() / def.TimeUnit_$WRAPPER.C0_$LI$()))));
            };
            TimeUnit$1_$WRAPPER.prototype.toMicros = function (d) {
                return d;
            };
            TimeUnit$1_$WRAPPER.prototype.toMillis = function (d) {
                return Math.floor(d / (Math.floor(def.TimeUnit_$WRAPPER.C2_$LI$() / def.TimeUnit_$WRAPPER.C1_$LI$())));
            };
            TimeUnit$1_$WRAPPER.prototype.toSeconds = function (d) {
                return Math.floor(d / (Math.floor(def.TimeUnit_$WRAPPER.C3_$LI$() / def.TimeUnit_$WRAPPER.C1_$LI$())));
            };
            TimeUnit$1_$WRAPPER.prototype.toMinutes = function (d) {
                return Math.floor(d / (Math.floor(def.TimeUnit_$WRAPPER.C4_$LI$() / def.TimeUnit_$WRAPPER.C1_$LI$())));
            };
            TimeUnit$1_$WRAPPER.prototype.toHours = function (d) {
                return Math.floor(d / (Math.floor(def.TimeUnit_$WRAPPER.C5_$LI$() / def.TimeUnit_$WRAPPER.C1_$LI$())));
            };
            TimeUnit$1_$WRAPPER.prototype.toDays = function (d) {
                return Math.floor(d / (Math.floor(def.TimeUnit_$WRAPPER.C6_$LI$() / def.TimeUnit_$WRAPPER.C1_$LI$())));
            };
            TimeUnit$1_$WRAPPER.prototype.convert = function (d, u) {
                return def.TimeUnit["_$wrappers"][u].toMicros(d);
            };
            TimeUnit$1_$WRAPPER.prototype.excessNanos = function (d, m) {
                return (((d * def.TimeUnit_$WRAPPER.C1_$LI$()) - (m * def.TimeUnit_$WRAPPER.C2_$LI$())) | 0);
            };
            return TimeUnit$1_$WRAPPER;
        }(TimeUnit_$WRAPPER));
        TimeUnit.TimeUnit$1_$WRAPPER = TimeUnit$1_$WRAPPER;
        /** @ignore */
        var TimeUnit$2_$WRAPPER = (function (_super) {
            __extends(TimeUnit$2_$WRAPPER, _super);
            function TimeUnit$2_$WRAPPER(_$ordinal, _$name) {
                return _super.call(this, _$ordinal, _$name) || this;
            }
            TimeUnit$2_$WRAPPER.prototype.toNanos = function (d) {
                return TimeUnit_$WRAPPER.x(d, Math.floor(def.TimeUnit_$WRAPPER.C2_$LI$() / def.TimeUnit_$WRAPPER.C0_$LI$()), Math.floor(def.TimeUnit_$WRAPPER.MAX_$LI$() / (Math.floor(def.TimeUnit_$WRAPPER.C2_$LI$() / def.TimeUnit_$WRAPPER.C0_$LI$()))));
            };
            TimeUnit$2_$WRAPPER.prototype.toMicros = function (d) {
                return TimeUnit_$WRAPPER.x(d, Math.floor(def.TimeUnit_$WRAPPER.C2_$LI$() / def.TimeUnit_$WRAPPER.C1_$LI$()), Math.floor(def.TimeUnit_$WRAPPER.MAX_$LI$() / (Math.floor(def.TimeUnit_$WRAPPER.C2_$LI$() / def.TimeUnit_$WRAPPER.C1_$LI$()))));
            };
            TimeUnit$2_$WRAPPER.prototype.toMillis = function (d) {
                return d;
            };
            TimeUnit$2_$WRAPPER.prototype.toSeconds = function (d) {
                return Math.floor(d / (Math.floor(def.TimeUnit_$WRAPPER.C3_$LI$() / def.TimeUnit_$WRAPPER.C2_$LI$())));
            };
            TimeUnit$2_$WRAPPER.prototype.toMinutes = function (d) {
                return Math.floor(d / (Math.floor(def.TimeUnit_$WRAPPER.C4_$LI$() / def.TimeUnit_$WRAPPER.C2_$LI$())));
            };
            TimeUnit$2_$WRAPPER.prototype.toHours = function (d) {
                return Math.floor(d / (Math.floor(def.TimeUnit_$WRAPPER.C5_$LI$() / def.TimeUnit_$WRAPPER.C2_$LI$())));
            };
            TimeUnit$2_$WRAPPER.prototype.toDays = function (d) {
                return Math.floor(d / (Math.floor(def.TimeUnit_$WRAPPER.C6_$LI$() / def.TimeUnit_$WRAPPER.C2_$LI$())));
            };
            TimeUnit$2_$WRAPPER.prototype.convert = function (d, u) {
                return def.TimeUnit["_$wrappers"][u].toMillis(d);
            };
            TimeUnit$2_$WRAPPER.prototype.excessNanos = function (d, m) {
                return 0;
            };
            return TimeUnit$2_$WRAPPER;
        }(TimeUnit_$WRAPPER));
        TimeUnit.TimeUnit$2_$WRAPPER = TimeUnit$2_$WRAPPER;
        /** @ignore */
        var TimeUnit$3_$WRAPPER = (function (_super) {
            __extends(TimeUnit$3_$WRAPPER, _super);
            function TimeUnit$3_$WRAPPER(_$ordinal, _$name) {
                return _super.call(this, _$ordinal, _$name) || this;
            }
            TimeUnit$3_$WRAPPER.prototype.toNanos = function (d) {
                return TimeUnit_$WRAPPER.x(d, Math.floor(def.TimeUnit_$WRAPPER.C3_$LI$() / def.TimeUnit_$WRAPPER.C0_$LI$()), Math.floor(def.TimeUnit_$WRAPPER.MAX_$LI$() / (Math.floor(def.TimeUnit_$WRAPPER.C3_$LI$() / def.TimeUnit_$WRAPPER.C0_$LI$()))));
            };
            TimeUnit$3_$WRAPPER.prototype.toMicros = function (d) {
                return TimeUnit_$WRAPPER.x(d, Math.floor(def.TimeUnit_$WRAPPER.C3_$LI$() / def.TimeUnit_$WRAPPER.C1_$LI$()), Math.floor(def.TimeUnit_$WRAPPER.MAX_$LI$() / (Math.floor(def.TimeUnit_$WRAPPER.C3_$LI$() / def.TimeUnit_$WRAPPER.C1_$LI$()))));
            };
            TimeUnit$3_$WRAPPER.prototype.toMillis = function (d) {
                return TimeUnit_$WRAPPER.x(d, Math.floor(def.TimeUnit_$WRAPPER.C3_$LI$() / def.TimeUnit_$WRAPPER.C2_$LI$()), Math.floor(def.TimeUnit_$WRAPPER.MAX_$LI$() / (Math.floor(def.TimeUnit_$WRAPPER.C3_$LI$() / def.TimeUnit_$WRAPPER.C2_$LI$()))));
            };
            TimeUnit$3_$WRAPPER.prototype.toSeconds = function (d) {
                return d;
            };
            TimeUnit$3_$WRAPPER.prototype.toMinutes = function (d) {
                return Math.floor(d / (Math.floor(def.TimeUnit_$WRAPPER.C4_$LI$() / def.TimeUnit_$WRAPPER.C3_$LI$())));
            };
            TimeUnit$3_$WRAPPER.prototype.toHours = function (d) {
                return Math.floor(d / (Math.floor(def.TimeUnit_$WRAPPER.C5_$LI$() / def.TimeUnit_$WRAPPER.C3_$LI$())));
            };
            TimeUnit$3_$WRAPPER.prototype.toDays = function (d) {
                return Math.floor(d / (Math.floor(def.TimeUnit_$WRAPPER.C6_$LI$() / def.TimeUnit_$WRAPPER.C3_$LI$())));
            };
            TimeUnit$3_$WRAPPER.prototype.convert = function (d, u) {
                return def.TimeUnit["_$wrappers"][u].toSeconds(d);
            };
            TimeUnit$3_$WRAPPER.prototype.excessNanos = function (d, m) {
                return 0;
            };
            return TimeUnit$3_$WRAPPER;
        }(TimeUnit_$WRAPPER));
        TimeUnit.TimeUnit$3_$WRAPPER = TimeUnit$3_$WRAPPER;
        /** @ignore */
        var TimeUnit$4_$WRAPPER = (function (_super) {
            __extends(TimeUnit$4_$WRAPPER, _super);
            function TimeUnit$4_$WRAPPER(_$ordinal, _$name) {
                return _super.call(this, _$ordinal, _$name) || this;
            }
            TimeUnit$4_$WRAPPER.prototype.toNanos = function (d) {
                return TimeUnit_$WRAPPER.x(d, Math.floor(def.TimeUnit_$WRAPPER.C4_$LI$() / def.TimeUnit_$WRAPPER.C0_$LI$()), Math.floor(def.TimeUnit_$WRAPPER.MAX_$LI$() / (Math.floor(def.TimeUnit_$WRAPPER.C4_$LI$() / def.TimeUnit_$WRAPPER.C0_$LI$()))));
            };
            TimeUnit$4_$WRAPPER.prototype.toMicros = function (d) {
                return TimeUnit_$WRAPPER.x(d, Math.floor(def.TimeUnit_$WRAPPER.C4_$LI$() / def.TimeUnit_$WRAPPER.C1_$LI$()), Math.floor(def.TimeUnit_$WRAPPER.MAX_$LI$() / (Math.floor(def.TimeUnit_$WRAPPER.C4_$LI$() / def.TimeUnit_$WRAPPER.C1_$LI$()))));
            };
            TimeUnit$4_$WRAPPER.prototype.toMillis = function (d) {
                return TimeUnit_$WRAPPER.x(d, Math.floor(def.TimeUnit_$WRAPPER.C4_$LI$() / def.TimeUnit_$WRAPPER.C2_$LI$()), Math.floor(def.TimeUnit_$WRAPPER.MAX_$LI$() / (Math.floor(def.TimeUnit_$WRAPPER.C4_$LI$() / def.TimeUnit_$WRAPPER.C2_$LI$()))));
            };
            TimeUnit$4_$WRAPPER.prototype.toSeconds = function (d) {
                return TimeUnit_$WRAPPER.x(d, Math.floor(def.TimeUnit_$WRAPPER.C4_$LI$() / def.TimeUnit_$WRAPPER.C3_$LI$()), Math.floor(def.TimeUnit_$WRAPPER.MAX_$LI$() / (Math.floor(def.TimeUnit_$WRAPPER.C4_$LI$() / def.TimeUnit_$WRAPPER.C3_$LI$()))));
            };
            TimeUnit$4_$WRAPPER.prototype.toMinutes = function (d) {
                return d;
            };
            TimeUnit$4_$WRAPPER.prototype.toHours = function (d) {
                return Math.floor(d / (Math.floor(def.TimeUnit_$WRAPPER.C5_$LI$() / def.TimeUnit_$WRAPPER.C4_$LI$())));
            };
            TimeUnit$4_$WRAPPER.prototype.toDays = function (d) {
                return Math.floor(d / (Math.floor(def.TimeUnit_$WRAPPER.C6_$LI$() / def.TimeUnit_$WRAPPER.C4_$LI$())));
            };
            TimeUnit$4_$WRAPPER.prototype.convert = function (d, u) {
                return def.TimeUnit["_$wrappers"][u].toMinutes(d);
            };
            TimeUnit$4_$WRAPPER.prototype.excessNanos = function (d, m) {
                return 0;
            };
            return TimeUnit$4_$WRAPPER;
        }(TimeUnit_$WRAPPER));
        TimeUnit.TimeUnit$4_$WRAPPER = TimeUnit$4_$WRAPPER;
        /** @ignore */
        var TimeUnit$5_$WRAPPER = (function (_super) {
            __extends(TimeUnit$5_$WRAPPER, _super);
            function TimeUnit$5_$WRAPPER(_$ordinal, _$name) {
                return _super.call(this, _$ordinal, _$name) || this;
            }
            TimeUnit$5_$WRAPPER.prototype.toNanos = function (d) {
                return TimeUnit_$WRAPPER.x(d, Math.floor(def.TimeUnit_$WRAPPER.C5_$LI$() / def.TimeUnit_$WRAPPER.C0_$LI$()), Math.floor(def.TimeUnit_$WRAPPER.MAX_$LI$() / (Math.floor(def.TimeUnit_$WRAPPER.C5_$LI$() / def.TimeUnit_$WRAPPER.C0_$LI$()))));
            };
            TimeUnit$5_$WRAPPER.prototype.toMicros = function (d) {
                return TimeUnit_$WRAPPER.x(d, Math.floor(def.TimeUnit_$WRAPPER.C5_$LI$() / def.TimeUnit_$WRAPPER.C1_$LI$()), Math.floor(def.TimeUnit_$WRAPPER.MAX_$LI$() / (Math.floor(def.TimeUnit_$WRAPPER.C5_$LI$() / def.TimeUnit_$WRAPPER.C1_$LI$()))));
            };
            TimeUnit$5_$WRAPPER.prototype.toMillis = function (d) {
                return TimeUnit_$WRAPPER.x(d, Math.floor(def.TimeUnit_$WRAPPER.C5_$LI$() / def.TimeUnit_$WRAPPER.C2_$LI$()), Math.floor(def.TimeUnit_$WRAPPER.MAX_$LI$() / (Math.floor(def.TimeUnit_$WRAPPER.C5_$LI$() / def.TimeUnit_$WRAPPER.C2_$LI$()))));
            };
            TimeUnit$5_$WRAPPER.prototype.toSeconds = function (d) {
                return TimeUnit_$WRAPPER.x(d, Math.floor(def.TimeUnit_$WRAPPER.C5_$LI$() / def.TimeUnit_$WRAPPER.C3_$LI$()), Math.floor(def.TimeUnit_$WRAPPER.MAX_$LI$() / (Math.floor(def.TimeUnit_$WRAPPER.C5_$LI$() / def.TimeUnit_$WRAPPER.C3_$LI$()))));
            };
            TimeUnit$5_$WRAPPER.prototype.toMinutes = function (d) {
                return TimeUnit_$WRAPPER.x(d, Math.floor(def.TimeUnit_$WRAPPER.C5_$LI$() / def.TimeUnit_$WRAPPER.C4_$LI$()), Math.floor(def.TimeUnit_$WRAPPER.MAX_$LI$() / (Math.floor(def.TimeUnit_$WRAPPER.C5_$LI$() / def.TimeUnit_$WRAPPER.C4_$LI$()))));
            };
            TimeUnit$5_$WRAPPER.prototype.toHours = function (d) {
                return d;
            };
            TimeUnit$5_$WRAPPER.prototype.toDays = function (d) {
                return Math.floor(d / (Math.floor(def.TimeUnit_$WRAPPER.C6_$LI$() / def.TimeUnit_$WRAPPER.C5_$LI$())));
            };
            TimeUnit$5_$WRAPPER.prototype.convert = function (d, u) {
                return def.TimeUnit["_$wrappers"][u].toHours(d);
            };
            TimeUnit$5_$WRAPPER.prototype.excessNanos = function (d, m) {
                return 0;
            };
            return TimeUnit$5_$WRAPPER;
        }(TimeUnit_$WRAPPER));
        TimeUnit.TimeUnit$5_$WRAPPER = TimeUnit$5_$WRAPPER;
        /** @ignore */
        var TimeUnit$6_$WRAPPER = (function (_super) {
            __extends(TimeUnit$6_$WRAPPER, _super);
            function TimeUnit$6_$WRAPPER(_$ordinal, _$name) {
                return _super.call(this, _$ordinal, _$name) || this;
            }
            TimeUnit$6_$WRAPPER.prototype.toNanos = function (d) {
                return TimeUnit_$WRAPPER.x(d, Math.floor(def.TimeUnit_$WRAPPER.C6_$LI$() / def.TimeUnit_$WRAPPER.C0_$LI$()), Math.floor(def.TimeUnit_$WRAPPER.MAX_$LI$() / (Math.floor(def.TimeUnit_$WRAPPER.C6_$LI$() / def.TimeUnit_$WRAPPER.C0_$LI$()))));
            };
            TimeUnit$6_$WRAPPER.prototype.toMicros = function (d) {
                return TimeUnit_$WRAPPER.x(d, Math.floor(def.TimeUnit_$WRAPPER.C6_$LI$() / def.TimeUnit_$WRAPPER.C1_$LI$()), Math.floor(def.TimeUnit_$WRAPPER.MAX_$LI$() / (Math.floor(def.TimeUnit_$WRAPPER.C6_$LI$() / def.TimeUnit_$WRAPPER.C1_$LI$()))));
            };
            TimeUnit$6_$WRAPPER.prototype.toMillis = function (d) {
                return TimeUnit_$WRAPPER.x(d, Math.floor(def.TimeUnit_$WRAPPER.C6_$LI$() / def.TimeUnit_$WRAPPER.C2_$LI$()), Math.floor(def.TimeUnit_$WRAPPER.MAX_$LI$() / (Math.floor(def.TimeUnit_$WRAPPER.C6_$LI$() / def.TimeUnit_$WRAPPER.C2_$LI$()))));
            };
            TimeUnit$6_$WRAPPER.prototype.toSeconds = function (d) {
                return TimeUnit_$WRAPPER.x(d, Math.floor(def.TimeUnit_$WRAPPER.C6_$LI$() / def.TimeUnit_$WRAPPER.C3_$LI$()), Math.floor(def.TimeUnit_$WRAPPER.MAX_$LI$() / (Math.floor(def.TimeUnit_$WRAPPER.C6_$LI$() / def.TimeUnit_$WRAPPER.C3_$LI$()))));
            };
            TimeUnit$6_$WRAPPER.prototype.toMinutes = function (d) {
                return TimeUnit_$WRAPPER.x(d, Math.floor(def.TimeUnit_$WRAPPER.C6_$LI$() / def.TimeUnit_$WRAPPER.C4_$LI$()), Math.floor(def.TimeUnit_$WRAPPER.MAX_$LI$() / (Math.floor(def.TimeUnit_$WRAPPER.C6_$LI$() / def.TimeUnit_$WRAPPER.C4_$LI$()))));
            };
            TimeUnit$6_$WRAPPER.prototype.toHours = function (d) {
                return TimeUnit_$WRAPPER.x(d, Math.floor(def.TimeUnit_$WRAPPER.C6_$LI$() / def.TimeUnit_$WRAPPER.C5_$LI$()), Math.floor(def.TimeUnit_$WRAPPER.MAX_$LI$() / (Math.floor(def.TimeUnit_$WRAPPER.C6_$LI$() / def.TimeUnit_$WRAPPER.C5_$LI$()))));
            };
            TimeUnit$6_$WRAPPER.prototype.toDays = function (d) {
                return d;
            };
            TimeUnit$6_$WRAPPER.prototype.convert = function (d, u) {
                return def.TimeUnit["_$wrappers"][u].toDays(d);
            };
            TimeUnit$6_$WRAPPER.prototype.excessNanos = function (d, m) {
                return 0;
            };
            return TimeUnit$6_$WRAPPER;
        }(TimeUnit_$WRAPPER));
        TimeUnit.TimeUnit$6_$WRAPPER = TimeUnit$6_$WRAPPER;
    })(TimeUnit = def.TimeUnit || (def.TimeUnit = {}));
    TimeUnit["_$wrappers"] = [new TimeUnit.TimeUnit$0_$WRAPPER(0, "NANOSECONDS"), new TimeUnit.TimeUnit$1_$WRAPPER(1, "MICROSECONDS"), new TimeUnit.TimeUnit$2_$WRAPPER(2, "MILLISECONDS"), new TimeUnit.TimeUnit$3_$WRAPPER(3, "SECONDS"), new TimeUnit.TimeUnit$4_$WRAPPER(4, "MINUTES"), new TimeUnit.TimeUnit$5_$WRAPPER(5, "HOURS"), new TimeUnit.TimeUnit$6_$WRAPPER(6, "DAYS")];
})(def || (def = {}));
var desmoj;
(function (desmoj) {
    var core;
    (function (core) {
        var dist;
        (function (dist) {
            /**
             * Creates a DefaultrandomGenerator with given value as initial seed.
             *
             * @param {number} seed
             * long : The initial seed of the underlying pseudo random
             * generator
             * @class
             * @author Tim Lechler
             */
            var LinearCongruentialRandomGenerator = (function () {
                function LinearCongruentialRandomGenerator(seed) {
                    var _this = this;
                    if (((typeof seed === 'number') || seed === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        this.javaAPIRandomGenerator = null;
                        this.javaAPIRandomGenerator = null;
                        (function () {
                            _this.javaAPIRandomGenerator = new def.Random(seed);
                        })();
                    }
                    else if (seed === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        this.javaAPIRandomGenerator = null;
                        this.javaAPIRandomGenerator = null;
                        (function () {
                            _this.javaAPIRandomGenerator = new def.Random(42);
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns the next pseudo random uniform [0,1] distributed double value
                 * from the stream produced by the underlying pseudo random number
                 * generator.
                 *
                 * @return {number} double : The next pseudo random uniform [0,1] distributed double
                 * value
                 */
                LinearCongruentialRandomGenerator.prototype.nextDouble = function () {
                    return this.javaAPIRandomGenerator.nextDouble();
                };
                /**
                 * Sets the seed for the pseudo random number generator.
                 *
                 * @param {number} newSeed
                 * long : The new initial seed value for the pseudo random number
                 * generator
                 */
                LinearCongruentialRandomGenerator.prototype.setSeed = function (newSeed) {
                    this.javaAPIRandomGenerator.setSeed(newSeed);
                };
                return LinearCongruentialRandomGenerator;
            }());
            dist.LinearCongruentialRandomGenerator = LinearCongruentialRandomGenerator;
            LinearCongruentialRandomGenerator["__class"] = "desmoj.core.dist.LinearCongruentialRandomGenerator";
            LinearCongruentialRandomGenerator["__interfaces"] = ["desmoj.core.dist.UniformRandomGenerator"];
        })(dist = core.dist || (core.dist = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var dist;
        (function (dist) {
            /**
             * Creates a MersenneTwisterRandomGenerator with given value as initial
             * seed.
             *
             * @param {number} seed
             * long : The initial seed of the underlying pseudo random
             * generator
             * @class
             * @author Tim Lechler, Johannes G&ouml;bel
             */
            var MersenneTwisterRandomGenerator = (function () {
                function MersenneTwisterRandomGenerator(seed) {
                    var _this = this;
                    if (((typeof seed === 'number') || seed === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        this.javaAPIRandomGenerator = null;
                        this.mersenneTwister = null;
                        this.currentIndex = 0;
                        this.javaAPIRandomGenerator = null;
                        this.mersenneTwister = null;
                        this.currentIndex = 0;
                        (function () {
                            _this.mersenneTwister = (function (s) { var a = []; while (s-- > 0)
                                a.push(0); return a; })(624);
                            _this.javaAPIRandomGenerator = new def.Random(42);
                            _this.setSeed(seed);
                        })();
                    }
                    else if (seed === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        {
                            var __args_1 = Array.prototype.slice.call(arguments);
                            var seed_1 = 42;
                            this.javaAPIRandomGenerator = null;
                            this.mersenneTwister = null;
                            this.currentIndex = 0;
                            this.javaAPIRandomGenerator = null;
                            this.mersenneTwister = null;
                            this.currentIndex = 0;
                            (function () {
                                _this.mersenneTwister = (function (s) { var a = []; while (s-- > 0)
                                    a.push(0); return a; })(624);
                                _this.javaAPIRandomGenerator = new def.Random(42);
                                _this.setSeed(seed_1);
                            })();
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns the next pseudo random uniform [0,1] distributed double value
                 * from the stream produced by the underlying pseudo random number
                 * generator.
                 *
                 * @return {number} double : The next pseudo random uniform [0,1] distributed double
                 * value
                 */
                MersenneTwisterRandomGenerator.prototype.nextDouble = function () {
                    return ((Math.floor(this.nextInt(26)) << 27) + this.nextInt(27)) / (1 << 53);
                };
                /**
                 * Returns the next pseudo random uniform distributed long value
                 * from the stream produced by the underlying pseudo random number
                 * generator.
                 * @return {number}
                 */
                MersenneTwisterRandomGenerator.prototype.nextLong = function () {
                    return (Math.floor((this.nextInt(32))) << 32) + this.nextInt(32);
                };
                /**
                 * Returns the next pseudo random integer of a given bit length.
                 *
                 * @param {number} bits
                 * int : Bit length of the integer to be returned
                 *
                 * @return {number} double : The next pseudo random integer of a given bit length
                 */
                MersenneTwisterRandomGenerator.prototype.nextInt = function (bits) {
                    var y = this.mersenneTwister[this.currentIndex];
                    this.currentIndex++;
                    if (this.currentIndex > 623)
                        this.twistNumbers();
                    y = y ^ y >>> 11;
                    y = y ^ (y << 7) & -1658038656;
                    y = y ^ (y << 15) & -272236544;
                    y = y ^ y >>> 18;
                    return y >>> 32 - bits;
                };
                /**
                 * Internal procedure to create ("twist") 624 new pseudo random numbers
                 * based on the last 624 pseudo random numbers.
                 */
                MersenneTwisterRandomGenerator.prototype.twistNumbers = function () {
                    for (var i = 0; i < 624; i++) {
                        var y = this.mersenneTwister[i] & -2147483648 | this.mersenneTwister[(i + 1) % 624] & 2147483647;
                        if (y % 2 === 0) {
                            this.mersenneTwister[i] = this.mersenneTwister[(i + 397) % 624] ^ y >>> 1;
                        }
                        else {
                            this.mersenneTwister[i] = this.mersenneTwister[(i + 397) % 624] ^ y >>> 1 ^ -1727483681;
                        }
                    }
                    ;
                    this.currentIndex = 0;
                };
                /**
                 * Sets the seed for the pseudo random number generator.
                 *
                 * @param {number} newSeed
                 * long : The new initial seed value for the pseudo random number
                 * generator
                 */
                MersenneTwisterRandomGenerator.prototype.setSeed = function (newSeed) {
                    var javaAPIRandomGenerator = new def.Random(newSeed);
                    for (var i = 0; i < 624; i++) {
                        this.mersenneTwister[i] = javaAPIRandomGenerator.nextInt();
                    }
                    ;
                    this.twistNumbers();
                };
                return MersenneTwisterRandomGenerator;
            }());
            dist.MersenneTwisterRandomGenerator = MersenneTwisterRandomGenerator;
            MersenneTwisterRandomGenerator["__class"] = "desmoj.core.dist.MersenneTwisterRandomGenerator";
            MersenneTwisterRandomGenerator["__interfaces"] = ["desmoj.core.dist.UniformRandomGenerator"];
        })(dist = core.dist || (core.dist = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var exception;
        (function (exception) {
            /**
             * Constructs a standard DESMO-J exception with an error message needed to
             * properly describe what error occurred, where it occurred, what reasons
             * could be responsible for it and what could be done to prevent this error
             * from occurring. The exception that caused this one is specified, too.
             *
             * @param {desmoj.core.report.ErrorMessage} message
             * desmoj.report.ErrorMessage : Describes the error leading to
             * this exception
             * @param {Error} cause
             * The exception describing the underlying cause.
             * @class
             * @extends Error
             * @author Tim lechler
             */
            var DESMOJException = (function (_super) {
                __extends(DESMOJException, _super);
                function DESMOJException(message, cause) {
                    var _this = this;
                    if (((message != null && message instanceof desmoj.core.report.ErrorMessage) || message === null) && ((cause != null && (cause["__classes"] && cause["__classes"].indexOf("java.lang.Throwable") >= 0) || cause != null && cause instanceof Error) || cause === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        _this = _super.call(this, "DESMOJException\n" + "Description: " + message.getDescription() + "\n" + "Location:    " + message.getLocation() + "\n" + "Reason:      " + message.getReason() + "\n" + "Prevention:  " + message.getPrevention()) || this;
                        _this.message = "DESMOJException\n" + "Description: " + message.getDescription() + "\n" + "Location:    " + message.getLocation() + "\n" + "Reason:      " + message.getReason() + "\n" + "Prevention:  " + message.getPrevention();
                        _this._errMsg = null;
                        _this._errMsg = null;
                        (function () {
                            _this._errMsg = message;
                        })();
                    }
                    else if (((message != null && message instanceof desmoj.core.report.ErrorMessage) || message === null) && cause === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        _this = _super.call(this, "DESMOJException\n" + "Description: " + message.getDescription() + "\n" + "Location:    " + message.getLocation() + "\n" + "Reason:      " + message.getReason() + "\n" + "Prevention:  " + message.getPrevention()) || this;
                        _this.message = "DESMOJException\n" + "Description: " + message.getDescription() + "\n" + "Location:    " + message.getLocation() + "\n" + "Reason:      " + message.getReason() + "\n" + "Prevention:  " + message.getPrevention();
                        _this._errMsg = null;
                        _this._errMsg = null;
                        (function () {
                            _this._errMsg = message;
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                    return _this;
                }
                /**
                 * Returns the error message describing the circumstances leading to this
                 * exception being thrown. Use this method to extract the message and pass
                 * it to the Experiment's MessageDistributor to write it to the ErrorFile.
                 *
                 * @return {desmoj.core.report.ErrorMessage} desmoj.report.ErrorMessage : The errormessage describing the
                 * reasons for this Exception
                 */
                DESMOJException.prototype.getErrorMessage = function () {
                    return this._errMsg;
                };
                return DESMOJException;
            }(Error));
            DESMOJException.serialVersionUID = 1;
            exception.DESMOJException = DESMOJException;
            DESMOJException["__class"] = "desmoj.core.exception.DESMOJException";
            DESMOJException["__interfaces"] = ["java.io.Serializable"];
        })(exception = core.exception || (core.exception = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var observer;
        (function (observer_1) {
            /**
             * Helper class for the subject interface to make the administration code reusable
             *
             * @author Christian Mentz
             *
             * @param <T>
             * Class of an possible Subject
             * @param <X>
             * Type of the Event which is passed in the update Method
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License. You
             * may obtain a copy of the License at
             * http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS"
             * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
             * or implied. See the License for the specific language governing
             * permissions and limitations under the License.
             * @class
             */
            var SubjectAdministration = (function () {
                function SubjectAdministration() {
                    /**
                     * a list of all registered observers of this subject
                     */
                    /*private*/ this.observers = ([]);
                }
                /**
                 * Adds an observer to the observer list
                 *
                 * @param {*} observer
                 * the observer to be added
                 */
                SubjectAdministration.prototype.addObserver = function (observer) {
                    if (!(this.observers.indexOf((observer)) >= 0)) {
                        /* add */ (this.observers.push(observer) > 0);
                    }
                };
                /**
                 * Deletes an observer from the observer list
                 *
                 * @param {*} observer
                 * the observer to be deleted
                 */
                SubjectAdministration.prototype.deleteObserver = function (observer) {
                    /* remove */ (function (a) { return a.splice(a.indexOf(observer), 1); })(this.observers);
                };
                /**
                 * Notifies all registered observers and passes a reference of the subject and a eventtype to the observer
                 *
                 * @param {*} subject
                 * the reference of the actual subject
                 * @param {*} eventObject
                 * the event type of the notify call. This is optional to distinguish the events and can be null
                 */
                SubjectAdministration.prototype.notifyObservers = function (subject, eventObject) {
                    for (var index758 = 0; index758 < this.observers.length; index758++) {
                        var observer_2 = this.observers[index758];
                        {
                            observer_2.update(subject, eventObject);
                        }
                    }
                };
                return SubjectAdministration;
            }());
            observer_1.SubjectAdministration = SubjectAdministration;
            SubjectAdministration["__class"] = "desmoj.core.observer.SubjectAdministration";
        })(observer = core.observer || (core.observer = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            /**
             * A basic implementation of the TableFormatter interface realizing common
             * properties of table formatters.
             *
             * @version DESMO-J, Ver. 2.5.1e copyright (c) 2017
             * @author Nicolas Knaak
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License. You
             * may obtain a copy of the License at
             * http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS"
             * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
             * or implied. See the License for the specific language governing
             * permissions and limitations under the License.
             * @class
             */
            var AbstractTableFormatter = (function () {
                function AbstractTableFormatter() {
                    /**
                     * Flag indicating if table is open
                     */
                    this.tableOpen = false;
                    /**
                     * Flag indicating if table row is open
                     */
                    this.rowOpen = false;
                    /**
                     * Precision of time values printed to table
                     */
                    /*private*/ this._timeFloats = 0;
                    /**
                     * The FileOutput this table writer writes to.
                     */
                    this.out = null;
                    /**
                     * The Reporter displayed in current row.
                     */
                    this._currentReporter = null;
                }
                /**
                 * Sets tableOpen flag to true. Should always be called from subclass
                 * implementations of this method.
                 *
                 * @return {boolean} value of row open flag
                 * @see desmoj.core.report.TableFormatter#rowIsOpen()
                 */
                AbstractTableFormatter.prototype.rowIsOpen = function () {
                    return this.rowOpen;
                };
                /**
                 * @return {boolean} value of table open flag;
                 * @see desmoj.core.report.TableFormatter#tableIsOpen()
                 */
                AbstractTableFormatter.prototype.tableIsOpen = function () {
                    return false;
                };
                /**
                 * Returns a formatted time string
                 *
                 * @param {string} t
                 * time string
                 * @return {string} formatted version of time string
                 * @see desmoj.core.report.TableFormatter#writeTime(java.lang.String)
                 */
                AbstractTableFormatter.prototype.writeTime = function (t) {
                    return t;
                };
                /**
                 * @return {number} time precision
                 * @see desmoj.core.report.TableFormatter#timePrecision()
                 */
                AbstractTableFormatter.prototype.timePrecision = function () {
                    return this._timeFloats;
                };
                /**
                 * Sets an output file to write the table to
                 *
                 * @param {desmoj.core.report.FileOutput} out
                 * desmoj.report.FileOutput
                 */
                AbstractTableFormatter.prototype.setOutput = function (out) {
                    this.out = out;
                };
                /**
                 * Sets the time precision
                 *
                 * @param {number} tf
                 * time precision
                 */
                AbstractTableFormatter.prototype.setTimePrecision = function (tf) {
                    this._timeFloats = tf;
                };
                AbstractTableFormatter.prototype.openRow$desmoj_core_report_Reporter = function (rep) {
                    this._currentReporter = rep;
                    this.openRow();
                };
                /**
                 * Opens a new row. Calls openRow() and saves reference on
                 * reporter which will we displayed in that row.
                 * Reference on reporter is not necessary for getting content of reporter!!!
                 * But maybe its useful for some kind of extended reports.
                 *
                 * @param {desmoj.core.report.Reporter} rep Reporter which will be displayed in new row
                 */
                AbstractTableFormatter.prototype.openRow = function (rep) {
                    if (((rep != null && rep instanceof desmoj.core.report.Reporter) || rep === null)) {
                        return this.openRow$desmoj_core_report_Reporter(rep);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the reporter which is displayed in current row.
                 * Maybe null, if openRow() insted of openRow(Reporter) was called.
                 * @return {desmoj.core.report.Reporter} the reporter which is displayed in current row.
                 */
                AbstractTableFormatter.prototype.getReporterForCurrentRow = function () {
                    return this._currentReporter;
                };
                return AbstractTableFormatter;
            }());
            report.AbstractTableFormatter = AbstractTableFormatter;
            AbstractTableFormatter["__class"] = "desmoj.core.report.AbstractTableFormatter";
            AbstractTableFormatter["__interfaces"] = ["desmoj.core.report.TableFormatter"];
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            /**
             * This class helps writing the JavaScript codes to draw charts.
             *
             * @version DESMO-J, Ver. 2.5.1e copyright (c) 2017
             * @author Johanna Djimandjaja
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License. You
             * may obtain a copy of the License at
             * http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS"
             * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
             * or implied. See the License for the specific language governing
             * permissions and limitations under the License.
             * @class
             */
            var JavaScriptFormatter = (function () {
                function JavaScriptFormatter() {
                    this._canvas = null;
                    this._out = null;
                    this._functionsToWrite = null;
                    this._functionsToWrite = ([]);
                }
                /**
                 * Sets an output file to write the script to
                 *
                 * @param {desmoj.core.report.FileOutput} out
                 * desmoj.report.FileOutput
                 */
                JavaScriptFormatter.prototype.setOutput = function (out) {
                    this._out = out;
                };
                JavaScriptFormatter.prototype.writeDrawingScript = function (canvas) {
                    this._canvas = canvas;
                    this._out.writeln("var myCanvas = document.getElementById(\'" + this._canvas.getCanvasID() + "\');");
                    this._out.writeln("var myContext = myCanvas.getContext(\'2d\');");
                    this.setDefaultColor();
                    if (this._canvas != null && (this._canvas["__interfaces"] != null && this._canvas["__interfaces"].indexOf("desmoj.core.report.html5chart.CanvasCoordinateChart") >= 0 || this._canvas.constructor != null && this._canvas.constructor["__interfaces"] != null && this._canvas.constructor["__interfaces"].indexOf("desmoj.core.report.html5chart.CanvasCoordinateChart") >= 0)) {
                        this.drawXScale();
                        this.drawYScale();
                        this.drawXAxis();
                        this.drawYAxis();
                        if (this._canvas != null && this._canvas instanceof desmoj.core.report.html5chart.CanvasTimeSeries)
                            this.drawTimeSeries();
                        else {
                            if ((this._canvas != null && this._canvas instanceof desmoj.core.report.html5chart.CanvasHistogramLong) || (this._canvas != null && this._canvas instanceof desmoj.core.report.html5chart.CanvasHistogramDouble)) {
                                this.drawVerticalBars();
                                this.drawTextLabels();
                            }
                        }
                        this.drawCanvasBorder();
                        this.writeFunctions();
                        this.reset();
                    }
                };
                /*private*/ JavaScriptFormatter.prototype.reset = function () {
                    this._canvas = null;
                    /* clear */ (this._functionsToWrite.length = 0);
                };
                /**
                 * Returns the hexadecimal notation for the given color.<br>
                 * The notation combines the red, green, and blue color values (RGB) in hexadecimal form.
                 * The lowest value that can be given to one of the light sources is 0 (hex 00). The highest value is 255 (hex FF).<br>
                 * When the given color is <code>null</code> returns <code>#000000</code>.
                 * @param {def.Color} color
                 * The color to be coded.
                 * @return
                 * String : The hexadecimal notation for the given color.
                 * @return {string}
                 * @private
                 */
                /*private*/ JavaScriptFormatter.prototype.toHexString = function (color) {
                    var hex = "";
                    if (color == null)
                        hex = "#000000";
                    else {
                        var r = color.getRed();
                        var g = color.getGreen();
                        var b = color.getBlue();
                        hex = "#" + this.intToHexString(r) + this.intToHexString(g) + this.intToHexString(b);
                    }
                    return hex;
                };
                /**
                 * Changes a given number into a 2-digit hexadecimal string.<br>
                 * Numbers less then 0 will be changed to the String 00 and numbers higher then 255 will be changed to FF.
                 * @param {number} number
                 * The number, that should be changed into hexadecimal.
                 * @return
                 * String : The given number as a 2-digit hexadecimal string.
                 * @return {string}
                 * @private
                 */
                /*private*/ JavaScriptFormatter.prototype.intToHexString = function (number) {
                    if (number <= 0)
                        return "00";
                    if (number >= 255)
                        return "FF";
                    var hex;
                    if (number < 16) {
                        hex = "0" + def.Integer.toHexString(number);
                    }
                    else {
                        hex = def.Integer.toHexString(number);
                    }
                    return hex;
                };
                /**
                 * Writes the functions needed to display the chart in the canvas.
                 * @private
                 */
                /*private*/ JavaScriptFormatter.prototype.writeFunctions = function () {
                    var writtenSet = ([]);
                    while ((!(function (a1, a2) { if (a1 == null && a2 == null)
                        return true; if (a1 == null || a2 == null)
                        return false; if (a1.length != a2.length)
                        return false; for (var i = 0; i < a1.length; i++) {
                        if (a1[i] != a2[i])
                            return false;
                    } return true; })(writtenSet, this._functionsToWrite))) {
                        var buffFunctionsToWrite = ([]);
                        for (var index759 = 0; index759 < this._functionsToWrite.length; index759++) {
                            var func = this._functionsToWrite[index759];
                            {
                                /* add */ (function (s, e) { if (s.indexOf(e) == -1) {
                                    s.push(e);
                                    return true;
                                }
                                else {
                                    return false;
                                } })(buffFunctionsToWrite, func);
                            }
                        }
                        for (var index760 = 0; index760 < buffFunctionsToWrite.length; index760++) {
                            var func = buffFunctionsToWrite[index760];
                            {
                                if (!(writtenSet.indexOf((func)) >= 0)) {
                                    switch ((func)) {
                                        case "drawVBars":
                                            this.writeFuncDrawVerticalBars();
                                            break;
                                        case "drawXAxis":
                                            this.writeFuncDrawXAxis();
                                            break;
                                        case "drawYAxis":
                                            this.writeFuncDrawYAxis();
                                            break;
                                        case "drawXScale":
                                            this.writeFuncDrawXScale();
                                            break;
                                        case "drawYScale":
                                            this.writeFuncDrawYScale();
                                            break;
                                        case "toCanvCoor":
                                            this.writeFuncToGetCanvasCoordinate();
                                            break;
                                        case "toRad":
                                            this.writeFuncToRad();
                                            break;
                                        case "drawTextLabels":
                                            this.writeFuncDrawTextLabels();
                                            break;
                                        case "drawTimeSeries":
                                            this.writeFuncDrawTimeSeries();
                                            break;
                                        default:
                                            break;
                                    }
                                    /* add */ (function (s, e) { if (s.indexOf(e) == -1) {
                                        s.push(e);
                                        return true;
                                    }
                                    else {
                                        return false;
                                    } })(writtenSet, func);
                                }
                            }
                        }
                    }
                    ;
                };
                /**
                 * Writes the code to draw the y-axis and
                 * to put the label for the y-axis into the JavaScript.
                 * @private
                 */
                /*private*/ JavaScriptFormatter.prototype.drawYAxis = function () {
                    this._out.writeln("drawYAxis();");
                    /* add */ (function (s, e) { if (s.indexOf(e) == -1) {
                        s.push(e);
                        return true;
                    }
                    else {
                        return false;
                    } })(this._functionsToWrite, "drawYAxis");
                };
                /**
                 * Writes the code to draw the x-axis and
                 * to put the label for the x-axis into the JavaScript.
                 * @private
                 */
                /*private*/ JavaScriptFormatter.prototype.drawXAxis = function () {
                    this._out.writeln("drawXAxis();");
                    /* add */ (function (s, e) { if (s.indexOf(e) == -1) {
                        s.push(e);
                        return true;
                    }
                    else {
                        return false;
                    } })(this._functionsToWrite, "drawXAxis");
                };
                /*private*/ JavaScriptFormatter.prototype.drawTextLabels = function () {
                    this._out.writeln("drawTextLabels();");
                    /* add */ (function (s, e) { if (s.indexOf(e) == -1) {
                        s.push(e);
                        return true;
                    }
                    else {
                        return false;
                    } })(this._functionsToWrite, "drawTextLabels");
                };
                /**
                 * Writes the code to draw the TimeSeries into the JavaScript.
                 * @private
                 */
                /*private*/ JavaScriptFormatter.prototype.drawTimeSeries = function () {
                    this._out.writeln("drawTimeSeries();");
                    /* add */ (function (s, e) { if (s.indexOf(e) == -1) {
                        s.push(e);
                        return true;
                    }
                    else {
                        return false;
                    } })(this._functionsToWrite, "drawTimeSeries");
                };
                /**
                 * Writes the code to draw the vertical bars into the JavaScript.
                 * @private
                 */
                /*private*/ JavaScriptFormatter.prototype.drawVerticalBars = function () {
                    this._out.writeln("drawVBars();");
                    /* add */ (function (s, e) { if (s.indexOf(e) == -1) {
                        s.push(e);
                        return true;
                    }
                    else {
                        return false;
                    } })(this._functionsToWrite, "drawVBars");
                };
                /**
                 * Writes the code to draw the scales of the x-axis and
                 * to write the labels for the scales into the JavaScript.
                 * @private
                 */
                /*private*/ JavaScriptFormatter.prototype.drawXScale = function () {
                    this._out.writeln("drawXScale();");
                    /* add */ (function (s, e) { if (s.indexOf(e) == -1) {
                        s.push(e);
                        return true;
                    }
                    else {
                        return false;
                    } })(this._functionsToWrite, "drawXScale");
                };
                /**
                 * Writes the code to draw the scales of the y-axis and
                 * to write the labels for the scales into the JavaScript.
                 * @private
                 */
                /*private*/ JavaScriptFormatter.prototype.drawYScale = function () {
                    this._out.writeln("drawYScale();");
                    /* add */ (function (s, e) { if (s.indexOf(e) == -1) {
                        s.push(e);
                        return true;
                    }
                    else {
                        return false;
                    } })(this._functionsToWrite, "drawYScale");
                };
                /**
                 * Writes the code to set the default color used in for the drawings.
                 * @private
                 */
                /*private*/ JavaScriptFormatter.prototype.setDefaultColor = function () {
                    this._out.writeln("");
                    this._out.writeln("myContext.strokeStyle = \'" + this.toHexString(this._canvas.getDefaultColor()) + "\';");
                };
                /**
                 * Writes the code to draw the canvas border into the JavaScript.
                 * @private
                 */
                /*private*/ JavaScriptFormatter.prototype.drawCanvasBorder = function () {
                    this._out.writeln("");
                    this._out.writeln("myContext.strokeRect(0, 0, myCanvas.width, myCanvas.height);");
                };
                /*private*/ JavaScriptFormatter.prototype.writeFuncDrawTextLabels = function () {
                    this._out.writeln("");
                    this._out.writeln("function drawTextLabels() {");
                    if ((this._canvas != null && this._canvas instanceof desmoj.core.report.html5chart.CanvasHistogramLong) && this._canvas.getNumOfData() !== 0) {
                        var thCanvas = this._canvas;
                        var verTextPos = (thCanvas.getCanvasHeight() - thCanvas.getBottomGap() + 10);
                        var labelsString = "\'" + thCanvas.getText(0) + "\'";
                        for (var i = 1; i < thCanvas.getNumOfData(); i++) {
                            labelsString = labelsString + ", \'" + thCanvas.getText(i) + "\'";
                        }
                        ;
                        this._out.writeln("\tvar labels = [" + labelsString + "];");
                        this._out.writeln("\tvar numOfData = " + thCanvas.getNumOfData() + ";");
                        this._out.writeln("\tvar barWidth = 4/5*" + thCanvas.getChartWidth() + " /numOfData;");
                        this._out.writeln("\tvar barGap = 1/5*" + thCanvas.getChartWidth() + "/(numOfData+1);");
                        this._out.writeln("");
                        this._out.writeln("\tmyContext.save();");
                        this._out.writeln("\tmyContext.textAlign = \'center\';");
                        this._out.writeln("\tmyContext.textBaseline = \'top\';");
                        this._out.writeln("\tfor (var i=0; numOfData>i; i++) {");
                        this._out.writeln("\t\tvar horTextPos = (i+1)*barGap + (i+0.5)*barWidth + " + thCanvas.getLeftGap() + ";");
                        this._out.writeln("\t\tmyContext.fillText(labels[i], horTextPos, " + verTextPos + ", barWidth);");
                        this._out.writeln("\t}");
                        this._out.writeln("\tmyContext.restore();");
                    }
                    if ((this._canvas != null && this._canvas instanceof desmoj.core.report.html5chart.CanvasHistogramDouble) && this._canvas.getNumOfData() !== 0) {
                        var thCanvas = this._canvas;
                        var verTextPos = (thCanvas.getCanvasHeight() - thCanvas.getBottomGap() + 10);
                        var labelsString = "\'" + thCanvas.getText(0) + "\'";
                        for (var i = 1; i < thCanvas.getNumOfData(); i++) {
                            labelsString = labelsString + ", \'" + thCanvas.getText(i) + "\'";
                        }
                        ;
                        this._out.writeln("  var labels = [" + labelsString + "];");
                        this._out.writeln("  var numOfData = " + thCanvas.getNumOfData() + ";");
                        this._out.writeln("  var barWidth = 4/5*" + thCanvas.getChartWidth() + " /numOfData;");
                        this._out.writeln("  var barGap = 1/5*" + thCanvas.getChartWidth() + "/(numOfData+1);");
                        this._out.writeln("");
                        this._out.writeln("  myContext.save();");
                        this._out.writeln("  myContext.textAlign = \'center\';");
                        this._out.writeln("  myContext.textBaseline = \'top\';");
                        this._out.writeln("  for (var i=0; numOfData>i; i++) {");
                        this._out.writeln("      var horTextPos = (i+1)*barGap + (i+0.5)*barWidth + " + thCanvas.getLeftGap() + ";");
                        this._out.writeln("      myContext.fillText(labels[i], horTextPos, " + verTextPos + ", barWidth);");
                        this._out.writeln("  }");
                        this._out.writeln("  myContext.restore();");
                    }
                    this._out.writeln("}");
                };
                /**
                 * Writes the function to draw the TimeSeries.
                 * @private
                 */
                /*private*/ JavaScriptFormatter.prototype.writeFuncDrawTimeSeries = function () {
                    this._out.writeln("");
                    this._out.writeln("function drawTimeSeries() {");
                    if (this._canvas != null && this._canvas instanceof desmoj.core.report.html5chart.CanvasTimeSeries) {
                        this.writeData();
                        var tsCanvas = this._canvas;
                        var tsColorString = "\'" + this.toHexString(tsCanvas.getDataColor(0)) + "\'";
                        for (var i = 1; i < tsCanvas.getNumOfTimeSeries(); i++) {
                            tsColorString = tsColorString + ", \'" + this.toHexString(tsCanvas.getDataColor(i)) + "\'";
                        }
                        ;
                        this._out.writeln("\tvar colors = [" + tsColorString + "];");
                        this._out.writeln("\tvar startXScale = " + tsCanvas.getStartXScale() + ";");
                        this._out.writeln("\tvar xScale = " + tsCanvas.getXScale() + ";");
                        this._out.writeln("\tvar numOfXScale = " + tsCanvas.getNumOfXScale() + ";");
                        this._out.writeln("\tvar yScale = " + tsCanvas.getYScale() + ";");
                        this._out.writeln("\tvar numOfYScale = " + tsCanvas.getNumOfYScale() + ";");
                        this._out.writeln("\tvar chartHeight = " + tsCanvas.getChartHeight() + ";");
                        this._out.writeln("\tvar chartWidth = " + tsCanvas.getChartWidth() + ";");
                        this._out.writeln("");
                        this._out.writeln("\tmyContext.save();");
                        this._out.writeln("\tfor (var i=0; dataValues.length>i; i++) {");
                        this._out.writeln("\t\tvar data = dataValues[i];");
                        this._out.writeln("\t\tvar time = timeValues[i]");
                        this._out.writeln("\t\tvar xCoor = (time[0]-startXScale) * chartWidth/(xScale*numOfXScale);");
                        this._out.writeln("\t\tvar yCoor = data[0] * chartHeight/(yScale*numOfYScale);");
                        this._out.writeln("");
                        this._out.writeln("\t\tmyContext.strokeStyle = colors[i];");
                        this._out.writeln("\t\tmyContext.beginPath();");
                        this._out.writeln("\t\tmyContext.moveTo(xToCanvasCoordinate(xCoor), yToCanvasCoordinate(yCoor));");
                        this._out.writeln("\t\tfor (var j=1; data.length>j; j++) {");
                        this._out.writeln("\t\t\tvar newXCoor = (time[j] - startXScale) * chartWidth/(xScale*numOfXScale);");
                        this._out.writeln("\t\t\tvar newYCoor = data[j] * chartHeight/(yScale*numOfYScale);");
                        this._out.writeln("\t\t\tmyContext.lineTo(xToCanvasCoordinate(newXCoor), yToCanvasCoordinate(yCoor));");
                        this._out.writeln("\t\t\tmyContext.lineTo(xToCanvasCoordinate(newXCoor), yToCanvasCoordinate(newYCoor));");
                        this._out.writeln("\t\t\txCoor = newXCoor;");
                        this._out.writeln("\t\t\tyCoor = newYCoor;");
                        this._out.writeln("\t\t}");
                        this._out.writeln("\t\tmyContext.stroke();");
                        this._out.writeln("\t\tmyContext.closePath();");
                        this._out.writeln("\t}");
                        this._out.writeln("\tmyContext.restore();");
                        /* add */ (function (s, e) { if (s.indexOf(e) == -1) {
                            s.push(e);
                            return true;
                        }
                        else {
                            return false;
                        } })(this._functionsToWrite, "toCanvCoor");
                    }
                    this._out.writeln("}");
                };
                /**
                 * Write the code to draw vertical bars.<br>
                 * This method should be used after the codes to draw the scales on the y-axis are written.
                 * @private
                 */
                /*private*/ JavaScriptFormatter.prototype.writeFuncDrawVerticalBars = function () {
                    this._out.writeln("");
                    this._out.writeln("function drawVBars() {");
                    if (this._canvas != null && (this._canvas["__interfaces"] != null && this._canvas["__interfaces"].indexOf("desmoj.core.report.html5chart.CanvasCoordinateChart") >= 0 || this._canvas.constructor != null && this._canvas.constructor["__interfaces"] != null && this._canvas.constructor["__interfaces"].indexOf("desmoj.core.report.html5chart.CanvasCoordinateChart") >= 0)) {
                        this.writeData();
                        var canvas = this._canvas;
                        var barColorString = "\'" + this.toHexString(canvas.getDataColor(0)) + "\'";
                        for (var i = 1; i < canvas.getNumOfData(); i++) {
                            barColorString = barColorString + ", \'" + this.toHexString(canvas.getDataColor(i)) + "\'";
                        }
                        ;
                        this._out.writeln("\tvar colors = [" + barColorString + "];");
                        this._out.writeln("\tvar yScale = " + canvas.getYScale() + ";");
                        this._out.writeln("\tvar numOfYScale = " + canvas.getNumOfYScale() + ";");
                        this._out.writeln("\tvar chartHeight = " + canvas.getChartHeight() + ";");
                        this._out.writeln("\tvar chartWidth = " + canvas.getChartWidth() + ";");
                        this._out.writeln("\tvar xScale = " + canvas.getXScale() + ";");
                        this._out.writeln("\tvar numOfXScale = " + canvas.getNumOfXScale() + ";");
                        this._out.writeln("\tvar startXScale = " + canvas.getStartXScale() + ";");
                        if (canvas != null && (canvas["__interfaces"] != null && canvas["__interfaces"].indexOf("desmoj.core.report.html5chart.CanvasCoordinateChartInterval") >= 0 || canvas.constructor != null && canvas.constructor["__interfaces"] != null && canvas.constructor["__interfaces"].indexOf("desmoj.core.report.html5chart.CanvasCoordinateChartInterval") >= 0)) {
                            this._out.writeln("");
                            this._out.writeln("\tmyContext.save();");
                            this._out.writeln("\tfor (var i=0; dataValues.length>i; i++) {");
                            this._out.writeln("\t\tvar startX = (lowerLimits[i]-startXScale)/(xScale*numOfXScale) * chartWidth");
                            this._out.writeln("\t\tvar endX = (upperLimits[i]-startXScale)/(xScale*numOfXScale) * chartWidth");
                            this._out.writeln("\t\tvar barWidth = endX-startX");
                            this._out.writeln("\t\tvar barHeight = dataValues[i]/(yScale*numOfYScale) * chartHeight;");
                            this._out.writeln("\t\tmyContext.fillStyle = colors[i];");
                            this._out.writeln("\t\tmyContext.fillRect(xToCanvasCoordinate(startX), yToCanvasCoordinate(0), barWidth, 0-barHeight);");
                            this._out.writeln("\t}");
                            this._out.writeln("\tmyContext.restore();");
                            /* add */ (function (s, e) { if (s.indexOf(e) == -1) {
                                s.push(e);
                                return true;
                            }
                            else {
                                return false;
                            } })(this._functionsToWrite, "toCanvCoor");
                        }
                        else {
                            if ((canvas != null && canvas instanceof desmoj.core.report.html5chart.CanvasHistogramDouble) || (canvas != null && canvas instanceof desmoj.core.report.html5chart.CanvasHistogramLong)) {
                                this._out.writeln("\tvar barWidth = 4/5*" + canvas.getChartWidth() + " /dataValues.length;");
                                this._out.writeln("\tvar barGap = 1/5*" + canvas.getChartWidth() + "/(dataValues.length+1);");
                                this._out.writeln("");
                                this._out.writeln("\tmyContext.save();");
                                this._out.writeln("\tfor (var i=0; dataValues.length>i; i++) {");
                                this._out.writeln("\t\tvar startX = (i+1)*barGap + i*barWidth;");
                                this._out.writeln("\t\tvar barHeight = dataValues[i]/(yScale*numOfYScale) * chartHeight;");
                                this._out.writeln("\t\tmyContext.fillStyle = colors[i];");
                                this._out.writeln("\t\tmyContext.fillRect(xToCanvasCoordinate(startX), yToCanvasCoordinate(0), barWidth, 0-barHeight);");
                                this._out.writeln("\t}");
                                this._out.writeln("\tmyContext.restore();");
                                /* add */ (function (s, e) { if (s.indexOf(e) == -1) {
                                    s.push(e);
                                    return true;
                                }
                                else {
                                    return false;
                                } })(this._functionsToWrite, "toCanvCoor");
                            }
                        }
                    }
                    this._out.writeln("}");
                };
                /**
                 * Writes the function to draw the x-Axis at the bottom of the chart area.
                 * @private
                 */
                /*private*/ JavaScriptFormatter.prototype.writeFuncDrawXAxis = function () {
                    this._out.writeln("");
                    this._out.writeln("function drawXAxis() {");
                    if (this._canvas != null && (this._canvas["__interfaces"] != null && this._canvas["__interfaces"].indexOf("desmoj.core.report.html5chart.CanvasCoordinateChart") >= 0 || this._canvas.constructor != null && this._canvas.constructor["__interfaces"] != null && this._canvas.constructor["__interfaces"].indexOf("desmoj.core.report.html5chart.CanvasCoordinateChart") >= 0)) {
                        var canvas = this._canvas;
                        this._out.writeln("\tmyContext.beginPath();");
                        this._out.writeln("\tmyContext.moveTo(" + canvas.getLeftGap() + ", myCanvas.height-" + canvas.getBottomGap() + ");");
                        this._out.writeln("\tmyContext.lineTo(myCanvas.width-" + canvas.getRightGap() + ", myCanvas.height-" + canvas.getBottomGap() + ");");
                        this._out.writeln("\tmyContext.stroke();");
                        this._out.writeln("\tmyContext.closePath();");
                        var xAxisTitle = canvas.getXAxisTitle();
                        var horTitlePos = canvas.getLeftGap() + (canvas.getChartWidth() / 2 | 0);
                        var verTitlePos = canvas.getCanvasHeight() - 10;
                        this._out.writeln("");
                        this._out.writeln("\tmyContext.save();");
                        this._out.writeln("\tmyContext.textAlign = \'center\';");
                        this._out.writeln("\tmyContext.textBaseline = \'bottom\';");
                        this._out.writeln("\tmyContext.font = \'bold 8pt Georgia\';");
                        this._out.writeln("\tmyContext.fillText(\'" + xAxisTitle + "\', " + horTitlePos + ", " + verTitlePos + ");");
                        this._out.writeln("\tmyContext.restore();");
                    }
                    this._out.writeln("}");
                };
                /**
                 * Writes the function to draw the y-Axis at the left of the chart area.
                 * @private
                 */
                /*private*/ JavaScriptFormatter.prototype.writeFuncDrawYAxis = function () {
                    this._out.writeln("");
                    this._out.writeln("function drawYAxis() {");
                    if (this._canvas != null && (this._canvas["__interfaces"] != null && this._canvas["__interfaces"].indexOf("desmoj.core.report.html5chart.CanvasCoordinateChart") >= 0 || this._canvas.constructor != null && this._canvas.constructor["__interfaces"] != null && this._canvas.constructor["__interfaces"].indexOf("desmoj.core.report.html5chart.CanvasCoordinateChart") >= 0)) {
                        var canvas = this._canvas;
                        this._out.writeln("\tmyContext.beginPath();");
                        this._out.writeln("\tmyContext.moveTo(" + canvas.getLeftGap() + ", " + canvas.getTopGap() + ");");
                        this._out.writeln("\tmyContext.lineTo(" + canvas.getLeftGap() + ", myCanvas.height-" + canvas.getBottomGap() + ");");
                        this._out.writeln("\tmyContext.stroke();");
                        this._out.writeln("\tmyContext.closePath();");
                        var yAxisTitle = canvas.getYAxisTitle();
                        var horTitlePos = canvas.getBottomGap() + (canvas.getChartHeight() / 2 | 0);
                        var verTitlePos = 10;
                        this._out.writeln("");
                        this._out.writeln("\tmyContext.save();");
                        this._out.writeln("\tmyContext.translate(0, myCanvas.height);");
                        this._out.writeln("\tmyContext.rotate(toRad(270));");
                        this._out.writeln("\tmyContext.textAlign = \'center\';");
                        this._out.writeln("\tmyContext.textBaseline = \'top\';");
                        this._out.writeln("\tmyContext.font = \'bold 8pt Georgia\';");
                        this._out.writeln("\tmyContext.fillText(\'" + yAxisTitle + "\', " + horTitlePos + ", " + verTitlePos + ");");
                        this._out.writeln("\tmyContext.restore();");
                        /* add */ (function (s, e) { if (s.indexOf(e) == -1) {
                            s.push(e);
                            return true;
                        }
                        else {
                            return false;
                        } })(this._functionsToWrite, "toRad");
                    }
                    this._out.writeln("}");
                };
                /**
                 * Writes the function to draw the scales on the x-axis
                 * if it is a CanvasCoordinateChart and the number of scales aren't 0.
                 * @private
                 */
                /*private*/ JavaScriptFormatter.prototype.writeFuncDrawXScale = function () {
                    this._out.writeln("");
                    this._out.writeln("function drawXScale() {");
                    if (this._canvas != null && (this._canvas["__interfaces"] != null && this._canvas["__interfaces"].indexOf("desmoj.core.report.html5chart.CanvasCoordinateChart") >= 0 || this._canvas.constructor != null && this._canvas.constructor["__interfaces"] != null && this._canvas.constructor["__interfaces"].indexOf("desmoj.core.report.html5chart.CanvasCoordinateChart") >= 0)) {
                        var coorCanvas = this._canvas;
                        var startXScale = coorCanvas.getStartXScale().doubleValue();
                        var xScale = coorCanvas.getXScale().doubleValue();
                        var numOfXScale = coorCanvas.getNumOfXScale();
                        var chartHeight = coorCanvas.getChartHeight();
                        var chartWidth = coorCanvas.getChartWidth();
                        var scaleColor = this.toHexString(coorCanvas.getScaleLineColor());
                        var verTextPos = (coorCanvas.getCanvasHeight() - coorCanvas.getBottomGap() + 10);
                        if (numOfXScale > 0) {
                            this._out.writeln("\tvar startXScale = " + startXScale + ";");
                            this._out.writeln("\tvar xScale = " + xScale + ";");
                            this._out.writeln("\tvar numOfXScale = " + numOfXScale + ";");
                            this._out.writeln("\tvar chartHeight = " + chartHeight + ";");
                            this._out.writeln("\tvar chartWidth = " + chartWidth + ";");
                            this._out.writeln("");
                            this._out.writeln("\tmyContext.save();");
                            this._out.writeln("\tmyContext.strokeStyle = \'" + scaleColor + "\';");
                            this._out.writeln("\tfor (var i=0; numOfXScale>=i; i++) {");
                            this._out.writeln("\t\tmyContext.beginPath();");
                            this._out.writeln("\t\tmyContext.moveTo(xToCanvasCoordinate(i*chartWidth/numOfXScale), yToCanvasCoordinate(0-5));");
                            this._out.writeln("\t\tmyContext.lineTo(xToCanvasCoordinate(i*chartWidth/numOfXScale),  yToCanvasCoordinate(chartHeight));");
                            this._out.writeln("\t\tmyContext.stroke();");
                            this._out.writeln("\t\tmyContext.closePath();");
                            this._out.writeln("\t}");
                            this._out.writeln("\tmyContext.restore();");
                            this._out.writeln("");
                            this._out.writeln("\tmyContext.save();");
                            this._out.writeln("\tmyContext.textAlign = \'center\';");
                            this._out.writeln("\tmyContext.textBaseline = \'top\';");
                            this._out.writeln("\tfor (var i=0; numOfXScale>=i; i++) {");
                            this._out.writeln("\t\tvar scaleText = i*xScale + startXScale;");
                            this._out.writeln("\t\tmyContext.fillText(scaleText, xToCanvasCoordinate(i*chartWidth/numOfXScale), " + verTextPos + ");");
                            this._out.writeln("\t}");
                            this._out.writeln("\tmyContext.restore();");
                            /* add */ (function (s, e) { if (s.indexOf(e) == -1) {
                                s.push(e);
                                return true;
                            }
                            else {
                                return false;
                            } })(this._functionsToWrite, "toCanvCoor");
                        }
                    }
                    this._out.writeln("}");
                };
                /**
                 * Writes the function to draw the scales on the y-axis
                 * if it is a CanvasCoordinateChart and the number of scales aren't 0.
                 * @private
                 */
                /*private*/ JavaScriptFormatter.prototype.writeFuncDrawYScale = function () {
                    this._out.writeln("");
                    this._out.writeln("function drawYScale() {");
                    if (this._canvas != null && (this._canvas["__interfaces"] != null && this._canvas["__interfaces"].indexOf("desmoj.core.report.html5chart.CanvasCoordinateChart") >= 0 || this._canvas.constructor != null && this._canvas.constructor["__interfaces"] != null && this._canvas.constructor["__interfaces"].indexOf("desmoj.core.report.html5chart.CanvasCoordinateChart") >= 0)) {
                        var canvas = this._canvas;
                        if (canvas.getNumOfYScale() !== 0) {
                            this._out.writeln("\tvar yScale = " + canvas.getYScale() + ";");
                            this._out.writeln("\tvar numOfYScale = " + canvas.getNumOfYScale() + ";");
                            this._out.writeln("\tvar chartHeight = " + canvas.getChartHeight() + ";");
                            this._out.writeln("\tvar chartWidth = " + canvas.getChartWidth() + ";");
                            this._out.writeln("");
                            this._out.writeln("\tmyContext.save();");
                            this._out.writeln("\tmyContext.strokeStyle = \'" + this.toHexString(canvas.getScaleLineColor()) + "\';");
                            this._out.writeln("\tfor (var i=1; numOfYScale>=i; i++) {");
                            this._out.writeln("\t\tmyContext.beginPath();");
                            this._out.writeln("\t\tmyContext.moveTo(xToCanvasCoordinate(0-5), yToCanvasCoordinate(i*chartHeight/numOfYScale));");
                            this._out.writeln("\t\tmyContext.lineTo(xToCanvasCoordinate(chartWidth),  yToCanvasCoordinate(i*chartHeight/numOfYScale));");
                            this._out.writeln("\t\tmyContext.stroke();");
                            this._out.writeln("\t\tmyContext.closePath();");
                            this._out.writeln("\t}");
                            this._out.writeln("\tmyContext.restore();");
                            this._out.writeln("");
                            this._out.writeln("\tmyContext.save();");
                            this._out.writeln("\tmyContext.textAlign = \'right\';");
                            this._out.writeln("\tmyContext.textBaseline = \'middle\';");
                            this._out.writeln("\tfor (var i=0; numOfYScale>=i; i++) {");
                            this._out.writeln("\t\tvar scaleText = i*yScale;");
                            this._out.writeln("\t\tmyContext.fillText(scaleText, " + (canvas.getLeftGap() - 10) + ", yToCanvasCoordinate(i*chartHeight/numOfYScale));");
                            this._out.writeln("\t}");
                            this._out.writeln("\tmyContext.restore();");
                            /* add */ (function (s, e) { if (s.indexOf(e) == -1) {
                                s.push(e);
                                return true;
                            }
                            else {
                                return false;
                            } })(this._functionsToWrite, "toCanvCoor");
                        }
                    }
                    this._out.writeln("}");
                };
                /**
                 * Write the functions to get the canvas-coordinate from
                 * a given x-coordinate or y-coordinate into the JavaScript.
                 * @private
                 */
                /*private*/ JavaScriptFormatter.prototype.writeFuncToGetCanvasCoordinate = function () {
                    if (this._canvas != null && (this._canvas["__interfaces"] != null && this._canvas["__interfaces"].indexOf("desmoj.core.report.html5chart.CanvasCoordinateChart") >= 0 || this._canvas.constructor != null && this._canvas.constructor["__interfaces"] != null && this._canvas.constructor["__interfaces"].indexOf("desmoj.core.report.html5chart.CanvasCoordinateChart") >= 0)) {
                        var canvas = this._canvas;
                        this._out.writeln("");
                        this._out.writeln("function xToCanvasCoordinate(xCoordinate) {");
                        this._out.writeln("\treturn " + canvas.getLeftGap() + " + xCoordinate;");
                        this._out.writeln("}");
                        this._out.writeln("");
                        this._out.writeln("function yToCanvasCoordinate(yCoordinate) {");
                        this._out.writeln("\treturn myCanvas.height-" + canvas.getBottomGap() + " - yCoordinate;");
                        this._out.writeln("}");
                    }
                    else {
                        this._out.writeln("");
                        this._out.writeln("function xToCanvasCoordinate(xCoordinate) {");
                        this._out.writeln("}");
                        this._out.writeln("");
                        this._out.writeln("function yToCanvasCoordinate(yCoordinate) {");
                        this._out.writeln("}");
                    }
                };
                /**
                 * Writes the function to calculate the radiant from a given angular degree.
                 * @private
                 */
                /*private*/ JavaScriptFormatter.prototype.writeFuncToRad = function () {
                    this._out.writeln("");
                    this._out.writeln("function toRad(x) {");
                    this._out.writeln("\treturn (x*Math.PI)/180;");
                    this._out.writeln("};");
                };
                /**
                 * Writes the data, that should be represented by the chart into the JavaScript.
                 * @private
                 */
                /*private*/ JavaScriptFormatter.prototype.writeData = function () {
                    if ((this._canvas != null && this._canvas instanceof desmoj.core.report.html5chart.CanvasHistogramLong) || (this._canvas != null && this._canvas instanceof desmoj.core.report.html5chart.CanvasHistogramDouble)) {
                        var dataString = "";
                        if (this._canvas != null && this._canvas instanceof desmoj.core.report.html5chart.CanvasHistogramLong) {
                            var canvas = this._canvas;
                            dataString = "" + canvas.getDataValue(0);
                            for (var i = 1; i < canvas.getNumOfData(); i++) {
                                dataString = dataString + ", " + canvas.getDataValue(i);
                            }
                            ;
                        }
                        else if (this._canvas != null && this._canvas instanceof desmoj.core.report.html5chart.CanvasHistogramDouble) {
                            var canvas = this._canvas;
                            for (var i = 0; i < canvas.getNumOfData(); i++) {
                                var dataValue = canvas.getDataValue(i);
                                if (dataValue === Number.POSITIVE_INFINITY) {
                                    dataValue = (canvas.getChartHeight() + canvas.getTopGap()) / canvas.getChartHeight() * canvas.getNumOfYScale() * canvas.getYScale();
                                }
                                if (i === 0)
                                    dataString = "" + dataValue;
                                else
                                    dataString = dataString + ", " + dataValue;
                            }
                            ;
                        }
                        this._out.writeln("\tvar dataValues = [" + dataString + "];");
                    }
                    if (this._canvas != null && (this._canvas["__interfaces"] != null && this._canvas["__interfaces"].indexOf("desmoj.core.report.html5chart.CanvasCoordinateChartInterval") >= 0 || this._canvas.constructor != null && this._canvas.constructor["__interfaces"] != null && this._canvas.constructor["__interfaces"].indexOf("desmoj.core.report.html5chart.CanvasCoordinateChartInterval") >= 0)) {
                        var intervalCanvas = this._canvas;
                        var lowerLimitsString = "";
                        var upperLimitsString = "";
                        for (var i = 0; i < intervalCanvas.getNumOfData(); i++) {
                            var lowerLimit = intervalCanvas.getLowerLimit(i);
                            var upperLimit = intervalCanvas.getUpperLimit(i);
                            if (lowerLimit === Number.NEGATIVE_INFINITY)
                                lowerLimit = intervalCanvas.getStartXScale().doubleValue();
                            if (upperLimit === Number.POSITIVE_INFINITY)
                                upperLimit = intervalCanvas.getXScale().doubleValue() * intervalCanvas.getNumOfXScale() + intervalCanvas.getStartXScale().doubleValue();
                            if (i === 0) {
                                lowerLimitsString = lowerLimitsString + lowerLimit;
                                upperLimitsString = upperLimitsString + upperLimit;
                            }
                            else {
                                lowerLimitsString = lowerLimitsString + ", " + lowerLimit;
                                upperLimitsString = upperLimitsString + ", " + upperLimit;
                            }
                        }
                        ;
                        this._out.writeln("\tvar lowerLimits = [" + lowerLimitsString + "];");
                        this._out.writeln("\tvar upperLimits = [" + upperLimitsString + "];");
                    }
                    if (this._canvas != null && this._canvas instanceof desmoj.core.report.html5chart.CanvasTimeSeries) {
                        var tsCanvas = this._canvas;
                        var dataValueBuff = void 0;
                        var timeValueBuff = void 0;
                        var dataString = "";
                        var timeString = "";
                        for (var i = 0; i < tsCanvas.getNumOfTimeSeries(); i++) {
                            if (i === 0) {
                                dataString = dataString + "[";
                                timeString = timeString + "[";
                            }
                            else {
                                dataString = dataString + ", [";
                                timeString = timeString + ", [";
                            }
                            dataValueBuff = tsCanvas.getDataValues(i);
                            timeValueBuff = tsCanvas.getTimeValues(i);
                            var numOfPair = void 0;
                            if (dataValueBuff.length <= timeValueBuff.length)
                                numOfPair = dataValueBuff.length;
                            else
                                numOfPair = timeValueBuff.length;
                            for (var j = 0; j < numOfPair; j++) {
                                if (j !== 0) {
                                    dataString = dataString + ", ";
                                    timeString = timeString + ", ";
                                }
                                dataString = dataString + dataValueBuff[j];
                                timeString = timeString + timeValueBuff[j];
                            }
                            ;
                            dataString = dataString + "]";
                            timeString = timeString + "]";
                        }
                        ;
                        this._out.writeln("\tvar dataValues = [" + dataString + "];");
                        this._out.writeln("\tvar timeValues = [" + timeString + "];");
                    }
                };
                return JavaScriptFormatter;
            }());
            report.JavaScriptFormatter = JavaScriptFormatter;
            JavaScriptFormatter["__class"] = "desmoj.core.report.JavaScriptFormatter";
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            /**
             * Constructs a message with the given parameters.
             *
             * @param {desmoj.core.simulator.Model} origin
             * Model : The model that produced this message
             * @param {string} description
             * java.lang.String : The actual message text
             * @param {desmoj.core.simulator.TimeInstant} time
             * TimeInstant : The point in simulation time this message was
             * created
             * @class
             * @author Tim Lechler
             */
            var Message = (function () {
                function Message(origin, description, time) {
                    this._modName = null;
                    this._msgDescription = null;
                    this._msgTime = null;
                    this._expName = null;
                    if (origin == null) {
                        this._modName = "----";
                        this._expName = "----";
                    }
                    else {
                        this._modName = origin.getName();
                        this._expName = origin.getExperiment().getName();
                    }
                    if (description == null)
                        this._msgDescription = "----";
                    else
                        this._msgDescription = description;
                    this._msgTime = time;
                }
                /**
                 * Returns the textual description of this message as a String.
                 *
                 * @return {string} java.lang.String : The message's description
                 */
                Message.prototype.getDescription = function () {
                    return this._msgDescription;
                };
                /**
                 * Returns the name of the model that produced this message.
                 *
                 * @return {string} java.lang.String : The the name of the model that produced this
                 * message
                 */
                Message.prototype.getModelName = function () {
                    return this._modName;
                };
                Message.prototype.getExperimentName = function () {
                    return this._expName;
                };
                /**
                 * Returns the time the message was (created) sent as a TimeInstant object.
                 *
                 * @return {desmoj.core.simulator.TimeInstant} desmoj.core.simulator.TimeInstant : The time the message was sent
                 * as a TimeInstant object.
                 */
                Message.prototype.getSendTime = function () {
                    return this._msgTime;
                };
                /**
                 * Returns the point of simulation time that this message was created as a
                 * String.
                 *
                 * @return {string} java.lang.String : the point of simulation time this message was
                 * created
                 */
                Message.prototype.getTime = function () {
                    if (this._msgTime == null)
                        return "----";
                    else
                        return this._msgTime.toString();
                };
                /**
                 * Overrides the Object's <code>toString()</code> method to return the
                 * message's description when this object is used as a String.
                 *
                 * @return {string} java.lang.String : The message's description
                 */
                Message.prototype.toString = function () {
                    return this._msgDescription;
                };
                return Message;
            }());
            report.Message = Message;
            Message["__class"] = "desmoj.core.report.Message";
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            /**
             * Constructs a new messagedistributor.
             * @class
             * @author Tim Lechler
             */
            var MessageDistributor = (function () {
                function MessageDistributor() {
                    this._head = null;
                    try {
                        MessageDistributor.reporters = eval("desmoj.core.report.Reporter");
                    }
                    catch (cnfEx) {
                        throw (new desmoj.core.exception.DESMOJException(new desmoj.core.report.ErrorMessage(null, "Can\'t find class \"desmoj.core.report.Reporter\"!", "MessageDistributor-Contructor.", "The classfile is probably missing or does not reside in thefolder /desmoj/report.", "Make sure to have the DESMOJ framework installed correctly", null)));
                    }
                    ;
                }
                MessageDistributor.prototype.deRegister$desmoj_core_report_MessageReceiver = function (out) {
                    if (out == null)
                        return;
                    if (this._head == null)
                        return;
                    for (var tmp = this._head; tmp != null; tmp = tmp.next) {
                        /* removeElement */ (function (a) { return a.splice(a.indexOf(out), 1); })(tmp.clients);
                        if ((tmp.clients.length == 0)) {
                            if (tmp === this._head) {
                                this._head = this._head.next;
                                return;
                            }
                            else {
                                tmp = tmp.next;
                                if (tmp == null)
                                    return;
                            }
                        }
                    }
                    ;
                };
                MessageDistributor.prototype.deRegister$desmoj_core_report_MessageReceiver$java_lang_Class = function (out, messageType) {
                    if (out == null)
                        return;
                    if (messageType == null)
                        return;
                    var tmp = this.linkOf(messageType);
                    if (tmp == null)
                        return;
                    /* removeElement */ (function (a) { return a.splice(a.indexOf(out), 1); })(tmp.clients);
                    if ((tmp.clients.length == 0)) {
                        if (tmp === this._head) {
                            this._head = this._head.next;
                        }
                        else {
                            tmp = tmp.next;
                        }
                    }
                };
                /**
                 * De-registers a messagereceiver object to stop receiving messages of the
                 * given type. The given messagereceiver object is taken from the list of
                 * messagereceiver receiving messages of the passed messagetype. If invalid
                 * parameters are given (i.e. <code>null</code> references) this method
                 * simply returns
                 *
                 * @param {*} out
                 * MessageReceiver : The messagereceiver to be de-registered
                 * @param {*} messageType
                 * java.lang.Class : The type of messages the messagereceiver
                 * should be deregistered from
                 */
                MessageDistributor.prototype.deRegister = function (out, messageType) {
                    if (((out != null && (out["__interfaces"] != null && out["__interfaces"].indexOf("desmoj.core.report.MessageReceiver") >= 0 || out.constructor != null && out.constructor["__interfaces"] != null && out.constructor["__interfaces"].indexOf("desmoj.core.report.MessageReceiver") >= 0)) || out === null) && ((messageType != null) || messageType === null)) {
                        return this.deRegister$desmoj_core_report_MessageReceiver$java_lang_Class(out, messageType);
                    }
                    else if (((out != null && (out["__interfaces"] != null && out["__interfaces"].indexOf("desmoj.core.report.MessageReceiver") >= 0 || out.constructor != null && out.constructor["__interfaces"] != null && out.constructor["__interfaces"].indexOf("desmoj.core.report.MessageReceiver") >= 0)) || out === null) && ((typeof messageType === 'string') || messageType === null)) {
                        return this.deRegister$desmoj_core_report_MessageReceiver$java_lang_String(out, messageType);
                    }
                    else if (((out != null && (out["__interfaces"] != null && out["__interfaces"].indexOf("desmoj.core.report.MessageReceiver") >= 0 || out.constructor != null && out.constructor["__interfaces"] != null && out.constructor["__interfaces"].indexOf("desmoj.core.report.MessageReceiver") >= 0)) || out === null) && messageType === undefined) {
                        return this.deRegister$desmoj_core_report_MessageReceiver(out);
                    }
                    else
                        throw new Error('invalid overload');
                };
                MessageDistributor.prototype.deRegister$desmoj_core_report_MessageReceiver$java_lang_String = function (out, className) {
                    if (out == null)
                        return;
                    if (className == null)
                        return;
                    var messageType = null;
                    try {
                        messageType = eval(className);
                    }
                    catch (cnfx) {
                        return;
                    }
                    ;
                    var tmp = this.linkOf(messageType);
                    if (tmp == null)
                        return;
                    /* removeElement */ (function (a) { return a.splice(a.indexOf(out), 1); })(tmp.clients);
                    if ((tmp.clients.length == 0)) {
                        if (tmp === this._head) {
                            this._head = this._head.next;
                        }
                        else {
                            tmp = tmp.next;
                        }
                    }
                };
                /**
                 * Checks if the current messagetype is switched on to be distributed. If
                 * not, no messages of the given type are distributed or the given type of
                 * message is not registered here.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if the type of message is
                 * distributed <code>false</code> if not or messagetype is not
                 * registered here
                 * @param {*} messageType
                 */
                MessageDistributor.prototype.isOn = function (messageType) {
                    if (messageType == null)
                        return false;
                    var tmp = this.linkOf(messageType);
                    if (tmp == null)
                        return false;
                    if (tmp.isOn) {
                        return true;
                    }
                    else
                        return false;
                };
                /**
                 * Checks if the given messagetype is registered at this messagedistributor.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if the messagetype is
                 * registered, <code>false</code> if not
                 * @param {*} messageType
                 */
                MessageDistributor.prototype.isRegistered = function (messageType) {
                    if (messageType == null)
                        return false;
                    var tmp = this.linkOf(messageType);
                    if (tmp == null)
                        return false;
                    else
                        return true;
                };
                /**
                 * Returns the messagelink for the given class or <code>null</code> if the
                 * class is not already registered.
                 *
                 * @return {desmoj.core.report.MessageDistributor.MLink} MessageLink : The messagelink for the given class or
                 * <code>null</code> if the given class is not registered yet
                 * @param {*} messageType
                 * java.lang.Class : The class that the link is needed for
                 * @private
                 */
                MessageDistributor.prototype.linkOf = function (messageType) {
                    if (this._head == null)
                        return null;
                    else {
                        for (var tmp = this._head; tmp != null; tmp = tmp.next) {
                            if (tmp.msgType === messageType)
                                return tmp;
                        }
                        ;
                    }
                    return null;
                };
                MessageDistributor.prototype.receive$desmoj_core_report_Message = function (m) {
                    if (m == null)
                        return;
                    var tmp = this.linkOf(m.constructor);
                    if (tmp == null)
                        return;
                    if (tmp.skipCount > 0) {
                        tmp.skipCount--;
                        return;
                    }
                    if (!tmp.isOn)
                        return;
                    for (var i = 0; i < tmp.clients.length; i++) {
                        /* elementAt */ tmp.clients[i]['receive$desmoj_core_report_Message'](m);
                    }
                    ;
                };
                /**
                 * Receives a message and forwards it to all messagereceiver objects
                 * registered with the type of message sent. Messages are sent, if the type
                 * of message is switched on and if the skipCounter is zero, thus not
                 * skipping any messages of that type.
                 *
                 * @param {desmoj.core.report.Message} m
                 * Message : The message to be forwarded to all registered
                 * MessageReceivers
                 */
                MessageDistributor.prototype.receive = function (m) {
                    if (((m != null && m instanceof desmoj.core.report.Message) || m === null)) {
                        return this.receive$desmoj_core_report_Message(m);
                    }
                    else if (((m != null && m instanceof desmoj.core.report.Reporter) || m === null)) {
                        return this.receive$desmoj_core_report_Reporter(m);
                    }
                    else
                        throw new Error('invalid overload');
                };
                MessageDistributor.prototype.receive$desmoj_core_report_Reporter = function (r) {
                    if (r == null)
                        return;
                    var tmp = this.linkOf(MessageDistributor.reporters);
                    if (tmp == null)
                        return;
                    for (var i = 0; i < tmp.clients.length; i++) {
                        tmp.clients[i]['receive$desmoj_core_report_Reporter'](r);
                    }
                    ;
                };
                MessageDistributor.prototype.register$desmoj_core_report_MessageReceiver$java_lang_Class = function (out, messageType) {
                    if (out == null)
                        return;
                    if (messageType == null)
                        return;
                    var tmp = this.linkOf(messageType);
                    if (tmp != null) {
                        if ((tmp.clients.indexOf((out)) >= 0)) {
                            return;
                        }
                        else {
                            /* addElement */ (tmp.clients.push(out) > 0);
                            return;
                        }
                    }
                    else {
                        this._head = new MessageDistributor.MLink(this._head, messageType, true);
                        /* addElement */ (this._head.clients.push(out) > 0);
                    }
                };
                /**
                 * Registers a messagereceiver object to receive messages of the given type.
                 *
                 * @param {*} out
                 * MessageReceiver : The messagereceiver to be registered
                 * @param {*} messageType
                 * java.lang.Class : The type of messages the messagereceiver is
                 * registered with
                 */
                MessageDistributor.prototype.register = function (out, messageType) {
                    if (((out != null && (out["__interfaces"] != null && out["__interfaces"].indexOf("desmoj.core.report.MessageReceiver") >= 0 || out.constructor != null && out.constructor["__interfaces"] != null && out.constructor["__interfaces"].indexOf("desmoj.core.report.MessageReceiver") >= 0)) || out === null) && ((messageType != null) || messageType === null)) {
                        return this.register$desmoj_core_report_MessageReceiver$java_lang_Class(out, messageType);
                    }
                    else if (((out != null && (out["__interfaces"] != null && out["__interfaces"].indexOf("desmoj.core.report.MessageReceiver") >= 0 || out.constructor != null && out.constructor["__interfaces"] != null && out.constructor["__interfaces"].indexOf("desmoj.core.report.MessageReceiver") >= 0)) || out === null) && ((typeof messageType === 'string') || messageType === null)) {
                        return this.register$desmoj_core_report_MessageReceiver$java_lang_String(out, messageType);
                    }
                    else
                        throw new Error('invalid overload');
                };
                MessageDistributor.prototype.register$desmoj_core_report_MessageReceiver$java_lang_String = function (out, className) {
                    if (out == null)
                        return;
                    if ((className == null) || (className.length === 0))
                        return;
                    var messageType = null;
                    try {
                        messageType = eval(className);
                    }
                    catch (cnfx) {
                        return;
                    }
                    ;
                    var tmp = this.linkOf(messageType);
                    if (tmp != null) {
                        if ((tmp.clients.indexOf((out)) >= 0)) {
                            return;
                        }
                        else {
                            /* addElement */ (tmp.clients.push(out) > 0);
                            return;
                        }
                    }
                    else {
                        this._head = new MessageDistributor.MLink(this._head, messageType, true);
                        /* addElement */ (this._head.clients.push(out) > 0);
                    }
                };
                MessageDistributor.prototype.skip$java_lang_Class = function (messageType) {
                    if (messageType == null)
                        return;
                    var tmp = this.linkOf(messageType);
                    if (tmp == null)
                        return;
                    tmp.skipCount++;
                };
                MessageDistributor.prototype.skip$java_lang_Class$int = function (messageType, skipNumber) {
                    if (skipNumber < 1)
                        return;
                    if (messageType == null)
                        return;
                    var tmp = this.linkOf(messageType);
                    if (tmp == null)
                        return;
                    tmp.skipCount += skipNumber;
                };
                /**
                 * Skips the transmission of a number of future messages by increasing the
                 * skipCount by the given number. This is necessary to blend out any
                 * activities managed by the framework that would otherwise confuse the
                 * modeller.
                 *
                 * @param {number} skipNumber
                 * int : The number of messages to skip
                 * @param {*} messageType
                 */
                MessageDistributor.prototype.skip = function (messageType, skipNumber) {
                    if (((messageType != null) || messageType === null) && ((typeof skipNumber === 'number') || skipNumber === null)) {
                        return this.skip$java_lang_Class$int(messageType, skipNumber);
                    }
                    else if (((messageType != null) || messageType === null) && skipNumber === undefined) {
                        return this.skip$java_lang_Class(messageType);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Disables messages of the given type to be sent to the registered
                 * receivers.
                 *
                 * @param {*} messageType
                 * Class : The type of messages to be switched off
                 */
                MessageDistributor.prototype.switchOff = function (messageType) {
                    if (messageType == null)
                        return;
                    var tmp = this.linkOf(messageType);
                    if (tmp == null)
                        return;
                    tmp.isOn = false;
                };
                /**
                 * Enables messages of the given type to be sent to the registered
                 * receivers.
                 *
                 * @param {*} messageType
                 * Class : The type of messages to be switched on
                 */
                MessageDistributor.prototype.switchOn = function (messageType) {
                    if (messageType == null)
                        return;
                    var tmp = this.linkOf(messageType);
                    if (tmp == null)
                        return;
                    tmp.isOn = true;
                };
                return MessageDistributor;
            }());
            /**
             * The special class for reporters to send all reporters to the experiment's
             * standard report ouput.
             */
            MessageDistributor.reporters = null;
            report.MessageDistributor = MessageDistributor;
            MessageDistributor["__class"] = "desmoj.core.report.MessageDistributor";
            MessageDistributor["__interfaces"] = ["desmoj.core.report.MessageReceiver"];
            (function (MessageDistributor) {
                /**
                 * The inner class messagelink keeps track of the types of messages and
                 * their related messagereceiver objects. Designed as an inner class to
                 * messagedistributor, not visible outside.
                 *
                 * @author Tim Lechler
                 * @class
                 */
                var MLink = (function () {
                    function MLink(nextLink, messageType, showing) {
                        this.next = null;
                        this.msgType = null;
                        this.clients = null;
                        this.isOn = false;
                        this.skipCount = 0;
                        this.isOn = showing;
                        this.next = nextLink;
                        this.skipCount = 0;
                        this.msgType = messageType;
                        this.clients = ([]);
                    }
                    return MLink;
                }());
                MessageDistributor.MLink = MLink;
                MLink["__class"] = "desmoj.core.report.MessageDistributor.MLink";
            })(MessageDistributor = report.MessageDistributor || (report.MessageDistributor = {}));
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            /**
             * Creates a reporter for the given reportable information source.
             *
             * @param {desmoj.core.simulator.Reportable} informationSource
             * desmoj.core.simulator.Reportable : The source of information to report
             * about
             * @class
             * @author Tim Lechler
             */
            var Reporter = (function () {
                function Reporter(informationSource) {
                    var _this = this;
                    if (((informationSource != null && informationSource instanceof desmoj.core.simulator.Reportable) || informationSource === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        this.groupID = 0;
                        this.columns = null;
                        this.entries = null;
                        this.groupHeading = null;
                        this.source = null;
                        this.__numColumns = 0;
                        this.groupID = 0;
                        this.columns = null;
                        this.entries = null;
                        this.groupHeading = null;
                        this.source = null;
                        this.__numColumns = 0;
                        (function () {
                            _this.source = informationSource;
                        })();
                    }
                    else if (((informationSource != null && informationSource instanceof desmoj.core.simulator.Schedulable) || informationSource === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        var source_1 = __args[0];
                        this.groupID = 0;
                        this.columns = null;
                        this.entries = null;
                        this.groupHeading = null;
                        this.source = null;
                        this.__numColumns = 0;
                        this.groupID = 0;
                        this.columns = null;
                        this.entries = null;
                        this.groupHeading = null;
                        this.source = null;
                        this.__numColumns = 0;
                        (function () {
                            _this.source = source_1.getCorrespondingReportable();
                        })();
                    }
                    else if (informationSource === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        this.groupID = 0;
                        this.columns = null;
                        this.entries = null;
                        this.groupHeading = null;
                        this.source = null;
                        this.__numColumns = 0;
                        this.groupID = 0;
                        this.columns = null;
                        this.entries = null;
                        this.groupHeading = null;
                        this.source = null;
                        this.__numColumns = 0;
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns an array of Strings each containing the title for the
                 * corresponding entry in array <code>entries[]</code>.
                 *
                 * @return {Array} java.lang.String[] : Array containing column titles
                 */
                Reporter.prototype.getColumnTitles = function () {
                    return this.columns.slice(0);
                };
                /**
                 * Returns the ID of the group this reporter belongs to. The group-ID is
                 * used to give reporters a key to be ordered by. This allows reporters of
                 * the same group to be printed together in one table in a report file.
                 *
                 * @return {number} int : The reporter's group ID
                 */
                Reporter.prototype.getGroupID = function () {
                    return this.groupID;
                };
                /**
                 * Returns the heading for the group this reporter belongs to. This can
                 * easily be used as a heading in the reporter to introduce a new group of
                 * reporters.
                 *
                 * @return {string} java.lang.String : The group heading for this group of reporters
                 */
                Reporter.prototype.getHeading = function () {
                    return this.groupHeading;
                };
                /**
                 * Returns the Model that the Reportable belongs to that this reporter
                 * produces a report about.
                 *
                 * @return {desmoj.core.simulator.Model} Model : The Model the reporter's reportable belongs to
                 */
                Reporter.prototype.getModel = function () {
                    return this.source.getModel();
                };
                /**
                 * Returns the reportable object that this reporter contains informations
                 * about.
                 *
                 * @return {desmoj.core.simulator.Reportable} desmoj.core.simulator.Reportable : The reportable this reporter carries
                 * information about
                 */
                Reporter.prototype.getReportable = function () {
                    return this.source;
                };
                /**
                 * Compares the ID's of the two given reporters and returns
                 * <code>true</code> if both have the same ID, <code>false</code> if
                 * their ID's are different.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if both reporter's ID's are the
                 * same, <code>false</code> if not
                 * @param {desmoj.core.report.Reporter} a
                 * desmoj.report.Reporter : comparand a
                 * @param {desmoj.core.report.Reporter} b
                 * desmoj.report.Reporter : comparand b
                 */
                Reporter.isEqual = function (a, b) {
                    return (a.getGroupID() === b.getGroupID());
                };
                /**
                 * Compares the ID's of the two given reporters and returns
                 * <code>true</code> if reporter 'a' has a higher ID than reporter 'b',
                 * <code>false</code> if not.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if reporter 'a' has a higher ID
                 * than reporter 'b', <code>false</code> if not
                 * @param {desmoj.core.report.Reporter} a
                 * desmoj.report.Reporter : comparand a
                 * @param {desmoj.core.report.Reporter} b
                 * desmoj.report.Reporter : comparand b
                 */
                Reporter.isLarger = function (a, b) {
                    return (a.getGroupID() > b.getGroupID());
                };
                /**
                 * Compares the ID's of the two given reporters and returns
                 * <code>true</code> if reporter 'a' belongs to a different group of ID's
                 * than reporter 'b', <code>false</code> if not.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if reporter 'a' has an ID
                 * belonging to a different group than reporter 'b',
                 * <code>false</code> if not
                 * @param {desmoj.core.report.Reporter} a
                 * desmoj.report.Reporter : comparand a
                 * @param {desmoj.core.report.Reporter} b
                 * desmoj.report.Reporter : comparand b
                 */
                Reporter.isOtherGroup = function (a, b) {
                    return !Reporter.isSameGroup(a, b);
                };
                /**
                 * Compares the ID's of the two given reporters and returns
                 * <code>true</code> if reporter 'a' belongs to the same group of ID's as
                 * reporter 'b', <code>false</code> if not.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if reporter 'a' has an ID
                 * belonging to the same group as reporter 'b', <code>false</code>
                 * if not
                 * @param {desmoj.core.report.Reporter} a
                 * desmoj.report.Reporter : comparand a
                 * @param {desmoj.core.report.Reporter} b
                 * desmoj.report.Reporter : comparand b
                 */
                Reporter.isSameGroup = function (a, b) {
                    if (a.getModel() !== b.getModel())
                        return false;
                    var groupStep = 100;
                    if (a.groupID >= 1300 && a.groupID < 1800 && b.groupID >= 1300 && b.groupID < 1800) {
                        groupStep = 50;
                    }
                    return ((a.getGroupID() / groupStep | 0) === (b.getGroupID() / groupStep | 0));
                };
                /**
                 * Returns the number of columns or data this reporter is containing.
                 *
                 * @return {number} int : The number of columns/data this reporter is containing
                 */
                Reporter.prototype.numColumns = function () {
                    return this.__numColumns;
                };
                /**
                 * Get an optional description of this Reporter's Reportable to be
                 * included in the report. Default is null.
                 * @return {string} String : Description
                 */
                Reporter.prototype.getDescription = function () {
                    return this.source.getDescription();
                };
                Reporter.prototype.isContinuingReporter = function () {
                    return false;
                };
                Reporter.prototype.isTwoRowReporter = function () {
                    return false;
                };
                Reporter.prototype.getNumOfSlaveQueues = function () {
                    return 0;
                };
                Reporter.prototype.makeAdditionalColorEntryIfHTMLColorChartIsGenerated = function () {
                    return false;
                };
                return Reporter;
            }());
            report.Reporter = Reporter;
            Reporter["__class"] = "desmoj.core.report.Reporter";
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            var html5chart;
            (function (html5chart) {
                /**
                 * A chart data table with data values from type <code>N</code>.
                 *
                 * @version DESMO-J, Ver. 2.5.1e copyright (c) 2017
                 * @author Johanna Djimandjaja
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License. You
                 * may obtain a copy of the License at
                 * http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS"
                 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
                 * or implied. See the License for the specific language governing
                 * permissions and limitations under the License.
                 * @class
                 */
                var AbstractChartDataTable = (function () {
                    function AbstractChartDataTable() {
                        this.table = null;
                        this.ownerModel = null;
                    }
                    /**
                     * Returns the highest data value.
                     * If there is no entry or the highest data value is a negative number,
                     * null will be returned. Entries of <code>Double.POSITIVE_INFINITY</code>
                     * will be ignored.
                     *
                     * @return
                     * N: the highest data value for this chart
                     * @return {number}
                     */
                    AbstractChartDataTable.prototype.getHighestDataValue = function () {
                        var max = null;
                        for (var index761 = 0; index761 < this.table.length; index761++) {
                            var entry = this.table[index761];
                            {
                                if ((max == null || def.NumberValueHelper.doubleValue(entry) > def.NumberValueHelper.doubleValue(max)) && def.NumberValueHelper.doubleValue(entry) !== (1.0 / 0.0))
                                    max = entry;
                            }
                        }
                        return max;
                    };
                    /**
                     * Returns the number of data for this chart.
                     * @return
                     * int: the number of data for this chart
                     * @return {number}
                     */
                    AbstractChartDataTable.prototype.getNumOfData = function () {
                        return this.table.length;
                    };
                    /**
                     * Returns the data value at a given index.
                     * If the data doesn't exist, <code>null</code> will be returned.
                     * @param {number} index
                     * @return
                     * N: the data value at a given index
                     * @return {number}
                     */
                    AbstractChartDataTable.prototype.getDataValue = function (index) {
                        if (index < 0 || index >= this.table.length)
                            return null;
                        else
                            return this.table[index];
                    };
                    /**
                     *
                     * @return {desmoj.core.simulator.Model}
                     */
                    AbstractChartDataTable.prototype.getOwnerModel = function () {
                        return this.ownerModel;
                    };
                    /**
                     * Returns whether this chart data is empty or not.<br>
                     * Returns <code>true</code> if <code>this.getNumOfData()==0</code>,
                     * else returns <code>false</code>.
                     *
                     * @return
                     * boolean: whether this chart data is empty or not
                     * @return {boolean}
                     */
                    AbstractChartDataTable.prototype.isEmpty = function () {
                        return (this.getNumOfData() === 0);
                    };
                    return AbstractChartDataTable;
                }());
                html5chart.AbstractChartDataTable = AbstractChartDataTable;
                AbstractChartDataTable["__class"] = "desmoj.core.report.html5chart.AbstractChartDataTable";
                AbstractChartDataTable["__interfaces"] = ["desmoj.core.report.html5chart.AbstractChartData"];
            })(html5chart = report.html5chart || (report.html5chart = {}));
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * This interface describes the set of methods an event-list carrying the
             * scheduled events and entities in a temporal order has to implement. This is a
             * part of the framework that does not have to be implemented by the user in
             * order to get a simulation running, since the scheduler already uses the class
             * EventVector as default EventList construction. Since each step in the
             * discrete simulation requires searching and manipulating the event-list, this
             * is probably one of the best places in the framework to optimize execution
             * performance. Especially if special models show specific behaviour i.e.
             * primarily inserting new events at the very end of the event-list, other
             * implementations of the event-list might support faster access times.
             *
             * @see EventVectorList
             *
             * @version DESMO-J, Ver. 2.5.1e copyright (c) 2017
             * @author Tim Lechler
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License. You
             * may obtain a copy of the License at
             * http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS"
             * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
             * or implied. See the License for the specific language governing
             * permissions and limitations under the License.
             * @class
             */
            var EventList = (function () {
                function EventList() {
                }
                return EventList;
            }());
            simulator.EventList = EventList;
            EventList["__class"] = "desmoj.core.simulator.EventList";
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Event notes can only be created if all relevant data can be supplied at
             * creation time. Note that all relevant associations of the given
             * Schedulables towards this event-note are built in this constructor
             * ensuring that each scheduled Schedulable has access to its associated
             * EventNote.
             *
             * @param {desmoj.core.simulator.Entity} who1
             * Entity : The first entity that is scheduled to be change during the
             * course of the event or the SimProcess (or null, if such an entity is not defined)
             * @param {desmoj.core.simulator.Entity} who2
             * Entity : The second entity that is scheduled to be change during the
             * course of the event or the SimProcess (or null, if such an entity is not defined)
             * @param {desmoj.core.simulator.Entity} who3
             * Entity : The third entity that is scheduled to be change during the
             * course of the event or the SimProcess (or null, if such an entity is not defined)
             * @param {desmoj.core.simulator.EventAbstract} what
             * Event : The type of Event that scheduled to happen to the
             * Entity or entities
             * @param {desmoj.core.simulator.TimeInstant} when
             * TimeInstant : The point of time that this event-note is supposed to
             * be processed by the scheduling mechanism
             * @param {number} howImportant
             * int : The scheduling priority of this event note. Higher means more important.
             * @param {desmoj.core.simulator.Schedulable} source
             * Schedulable : The Schedulable responsible for creating this event note
             * @class
             * @author Tim Lechler
             */
            var EventNote = (function () {
                function EventNote(who1, who2, who3, what, when, howImportant, source) {
                    this._myEntity1 = null;
                    this._myEntity2 = null;
                    this._myEntity3 = null;
                    this._myEvent = null;
                    this._myTimeInstant = null;
                    this._myPriority = 0;
                    this._mySource = null;
                    this._isConnected = false;
                    this._myEntity1 = who1;
                    this._myEntity2 = who2;
                    this._myEntity3 = who3;
                    this._myEvent = what;
                    this._myTimeInstant = when;
                    this._myPriority = howImportant;
                    this._mySource = source;
                    if (what != null)
                        what.addEventNote(this);
                }
                /**
                 * Copies the event-note.
                 * WARNING: No additional reference is set to linked Entity.
                 *
                 * @param {desmoj.core.simulator.Schedulable} source
                 * Schedulable : The Schedulable responsible for copying this event note
                 *
                 * @return {desmoj.core.simulator.EventNote} The Entity associated to this event-note
                 */
                EventNote.prototype.copy = function (source) {
                    var evn = null;
                    if (this.getNumberOfEntities() <= 1) {
                        evn = new EventNote(this._myEntity1, null, null, this._myEvent, this._myTimeInstant, this._myPriority, source);
                        evn._isConnected = this.isConnected();
                    }
                    else if (this.getNumberOfEntities() === 2) {
                        evn = new EventNote(this._myEntity1, this._myEntity2, null, this._myEvent, this._myTimeInstant, this._myPriority, source);
                        evn._isConnected = this.isConnected();
                    }
                    else if (this.getNumberOfEntities() === 3) {
                        evn = new EventNote(this._myEntity1, this._myEntity2, this._myEntity3, this._myEvent, this._myTimeInstant, this._myPriority, source);
                        evn._isConnected = this.isConnected();
                    }
                    {
                        return evn;
                    }
                    ;
                };
                /**
                 * Returns whether this <code>EventNote</code> equals another one or not.
                 *
                 * @return {boolean} <code>true</code> or <code>false</code>.
                 * @param {*} object
                 */
                EventNote.prototype.equals = function (object) {
                    if (!(object != null && object instanceof desmoj.core.simulator.EventNote)) {
                        return false;
                    }
                    var note = object;
                    return this._myTimeInstant.equals(note._myTimeInstant) && EventNote.equalsWithNull(this._myEvent, note._myEvent) && EventNote.equalsWithNull(this._myEntity1, note._myEntity1) && EventNote.equalsWithNull(this._myEntity2, note._myEntity2) && EventNote.equalsWithNull(this._myEntity3, note._myEntity3) && this._myPriority === note._myPriority;
                };
                /*private*/ EventNote.equalsWithNull = function (o1, o2) {
                    return o1 === o2 || (o1 != null && (function (o1, o2) { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(o1, o2));
                };
                /**
                 * Returns a hash code value for the object. This method overrides
                 * java.lang.Object.hashCode() to support efficient treatment in
                 * HashMaps.
                 *
                 * @return: int: A hash code value for this EventNote.
                 * @return {number}
                 */
                EventNote.prototype.hashCode = function () {
                    return (this._myEntity1 == null ? 13 : (function (o) { if (o.hashCode) {
                        return o.hashCode();
                    }
                    else {
                        return o.toString();
                    } })(this._myEntity1)) ^ (this._myEntity2 == null ? 983 : (function (o) { if (o.hashCode) {
                        return o.hashCode();
                    }
                    else {
                        return o.toString();
                    } })(this._myEntity2)) ^ (this._myEntity3 == null ? 33637 : (function (o) { if (o.hashCode) {
                        return o.hashCode();
                    }
                    else {
                        return o.toString();
                    } })(this._myEntity3)) ^ (this._myEvent == null ? 7288583 : (function (o) { if (o.hashCode) {
                        return o.hashCode();
                    }
                    else {
                        return o.toString();
                    } })(this._myEvent)) ^ (function (o) { if (o.hashCode) {
                        return o.hashCode();
                    }
                    else {
                        return o.toString();
                    } })(this._myTimeInstant);
                };
                /**
                 * Compares the given EventNote to this event-note. This method
                 * implements the Comparable<EventNote> Interface
                 *
                 * @param {desmoj.core.simulator.EventNote} note The event-note to be compared to this event-note
                 *
                 * @return {number} Returns a negative integer, zero, or a positive integer as
                 * this event-note is before, at the same time, or after the given
                 * EventNote.
                 */
                EventNote.prototype.compareTo = function (note) {
                    var time_comparison = this.getTime().compareTo(note.getTime());
                    if (time_comparison !== 0)
                        return time_comparison;
                    else
                        return -(this._myPriority - note._myPriority);
                };
                /**
                 * Returns the entity that is associated with this event-note.
                 *
                 * @return {desmoj.core.simulator.Entity} Entity : The Entity associated to this event-note
                 */
                EventNote.prototype.getEntity1 = function () {
                    return this._myEntity1;
                };
                /**
                 * Returns the entity that is associated with this event-note.
                 *
                 * @return {desmoj.core.simulator.Entity} Entity : The Entity associated to this event-note
                 */
                EventNote.prototype.getEntity2 = function () {
                    return this._myEntity2;
                };
                /**
                 * Returns the entity that is associated with this event-note.
                 *
                 * @return {desmoj.core.simulator.Entity} Entity : The Entity associated to this event-note
                 */
                EventNote.prototype.getEntity3 = function () {
                    return this._myEntity3;
                };
                /**
                 * Returns the event associated with this event-note.
                 *
                 * @return {desmoj.core.simulator.EventAbstract} Event : The event associated with this event-note
                 */
                EventNote.prototype.getEvent = function () {
                    return this._myEvent;
                };
                /**
                 * Returns the number of included entities.
                 *
                 * @return {number} <code>int</code> : The number of entities
                 */
                EventNote.prototype.getNumberOfEntities = function () {
                    var i = 0;
                    if (this._myEntity1 != null) {
                        i++;
                    }
                    if (this._myEntity2 != null) {
                        i++;
                    }
                    if (this._myEntity3 != null) {
                        i++;
                    }
                    return i;
                };
                /**
                 * Returns the point of time associated with this event-note.
                 *
                 * @return {desmoj.core.simulator.TimeInstant} TimeInstant : Point of time in simulation associated with this
                 * EventNote
                 */
                EventNote.prototype.getTime = function () {
                    return this._myTimeInstant;
                };
                /**
                 * Returns the priority of this event-note.
                 *
                 * @return {number} int : The scheduling priority of this EventNote
                 */
                EventNote.prototype.getPriority = function () {
                    return this._myPriority;
                };
                /**
                 * Associates this event-note with the given Entity. This is a package
                 * visibility method for internal framework use only.
                 *
                 * @param {desmoj.core.simulator.Entity} e
                 * Entity : The Entity to be associated with this event-note
                 */
                EventNote.prototype.setEntity1 = function (e) {
                    this._myEntity1 = e;
                };
                /**
                 * Associates this event-note with the given Entity. This is a package
                 * visibility method for internal framework use only.
                 *
                 * @param {desmoj.core.simulator.Entity} e
                 * Entity : The Entity to be associated with this event-note
                 */
                EventNote.prototype.setEntity2 = function (e) {
                    this._myEntity2 = e;
                };
                /**
                 * Associates this event-note with the given Entity. This is a package
                 * visibility method for internal framework use only.
                 *
                 * @param {desmoj.core.simulator.Entity} e
                 * Entity : The Entity to be associated with this event-note
                 */
                EventNote.prototype.setEntity3 = function (e) {
                    this._myEntity3 = e;
                };
                /**
                 * Associates this event-note with the given event. This is a package
                 * visibility method for internal framework use only.
                 *
                 * @param {desmoj.core.simulator.EventAbstract} e
                 * Event : The event to be associated with this event-note
                 */
                EventNote.prototype.setEvent = function (e) {
                    this._myEvent = e;
                };
                /**
                 * Sets the point of time for this event-note to the time given as parameter.
                 * This method is to be used by the scheduler to correct the point of time
                 * of an event-note after inserting it relative to some other EventNote to
                 * preserve the temporal order of the event-list. This is a package
                 * visibility method for internal framework use only.
                 *
                 * @param {desmoj.core.simulator.TimeInstant} time
                 * TimeInstant : the new point of simulation time this event-note is
                 * associated with.
                 */
                EventNote.prototype.setTime = function (time) {
                    this._myTimeInstant = time;
                };
                /**
                 * Sets the priority for this event-note to the time given as parameter.
                 * This method is to be used by the scheduler to correct the point of time
                 * of an event-note after inserting it relative to some other EventNote to
                 * preserve the temporal+priority order of the event-list. This is a package
                 * visibility method for internal framework use only.
                 *
                 * @param {number} priority The new priority this event-note is associated with.
                 */
                EventNote.prototype.setPriority = function (priority) {
                    this._myPriority = priority;
                };
                /**
                 * Tests if this event-note is connected to its predecessor.
                 * If a connection exists (true), <code>RandomizingEventVector</code> or
                 * <code>RandomizingEventTreeList</code> will not insert another event-note scheduled for
                 * the same instant (but not explicity scheduled using
                 * <code>scheduleBefore()</code> or <code>scheduelAfter()</code>)
                 * between this event-note and its predecessor  scheduled for
                 * the same instant. This is a package
                 * visibility method for internal framework use only.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if a connection to the predecessor exists,
                 * <code>false</code> otherwise.
                 */
                EventNote.prototype.isConnected = function () {
                    return this._isConnected;
                };
                /**
                 * Returns the Schedulable that has created this event note.
                 *
                 * @return {desmoj.core.simulator.Schedulable} Entity : The Schedulable that has created this event note
                 */
                EventNote.prototype.getSource = function () {
                    return this._mySource;
                };
                /**
                 * Sets this event node connected to its predecessor (true), so that
                 * <code>RandomizingEventVector</code> or
                 * <code>RandomizingEventTreeList</code> will not insert another EventNote
                 * (but not explicity scheduled using
                 * <code>scheduleBefore()</code> or <code>scheduelAfter()</code>)
                 * between this event-note and its predecessor scheduled for
                 * the same instant or removes
                 * such a connection (false). This is a package
                 * visibility method for internal framework use only.
                 *
                 * @param {boolean} isConnected
                 * boolean : establishes (true) or removes (false) a connection between
                 * this event-note and its predecessor.
                 */
                EventNote.prototype.setConnected = function (isConnected) {
                    this._isConnected = isConnected;
                };
                /**
                 * Returns a string representing the elements bundled in this event-note. It
                 * calls the <code>toString()</code> methods of every element putting each
                 * in brackets containing one or two letters to indicate the type of
                 * element.
                 * <p>
                 * <ul>
                 * <li>En: Entity, SimProcess or <code>null</code></li>
                 * <li>Ev: Event, external event or <code>null</code></li>
                 * <li>t: simulation time</li>
                 * </ul>
                 *
                 * @return {string} java.lang.String : String representing the contained elements.
                 */
                EventNote.prototype.toString = function () {
                    var EntityString = "";
                    if (this.getNumberOfEntities() === 1) {
                        EntityString = "En: " + this._myEntity1 + " ";
                    }
                    if (this.getNumberOfEntities() === 2) {
                        EntityString = "En:" + this._myEntity1 + "," + this._myEntity2 + " ";
                    }
                    if (this.getNumberOfEntities() === 3) {
                        EntityString = "En:" + this._myEntity1 + "," + this._myEntity2 + "," + this._myEntity3 + " ";
                    }
                    return (EntityString + "Ev:" + this._myEvent + " t:" + this._myTimeInstant);
                };
                return EventNote;
            }());
            simulator.EventNote = EventNote;
            EventNote["__class"] = "desmoj.core.simulator.EventNote";
            EventNote["__interfaces"] = ["java.lang.Comparable"];
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Keeps track of the names given for Schedulables within an experiment. To help
             * identify individual entities, events and all other types of Schedulables,
             * this class registers all names given to these objects. If an object is
             * created with the same name as some other object before, a number is added to
             * the object's name as a suffix. The number represents the amount of objects
             * already created with that name.
             *
             * @version DESMO-J, Ver. 2.5.1e copyright (c) 2017
             * @author Tim Lechler
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License. You
             * may obtain a copy of the License at
             * http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS"
             * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
             * or implied. See the License for the specific language governing
             * permissions and limitations under the License.
             * @class
             */
            var NameCatalog = (function () {
                function NameCatalog() {
                    this._catalog = null;
                    this._catalog = ({});
                }
                /**
                 * Registers the given name in the namecatalog and returns the correct name
                 * with the added number if necessary. If a <code>null</code> reference is
                 * given as parameter, the returned name will be set to "unnamed" with the
                 * number of unnamed objects so far added as a suffix.
                 *
                 * @return {string} java.lang.String : The registered name including the number if
                 * necessary
                 * @param {string} name
                 * java.lang.String : The name for a new Schedulable
                 */
                NameCatalog.prototype.registeredName = function (name) {
                    if (name == null)
                        name = "unnamed";
                    var number = (function (m, k) { return m[k] ? m[k] : null; })(this._catalog, name);
                    if (number != null) {
                        var i = (number | 0);
                        i++;
                        /* put */ (this._catalog[name] = i);
                        return name + "#" + i;
                    }
                    else {
                        /* put */ (this._catalog[name] = 1);
                        return name + "#1";
                    }
                };
                /**
                 * Returns the first part of name without added number as suffix.
                 *
                 * @return {string} java.lang.String : The first part of the name without number suffix
                 * @param {string} name
                 * java.lang.String : The name obtain the first part from.
                 */
                NameCatalog.prototype.getNameWithoutSuffix = function (name) {
                    if (name == null || (function (o1, o2) { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(name, "unnamed") || name.indexOf("#") === -1)
                        return name;
                    else
                        return name.substring(0, name.lastIndexOf("#"));
                };
                return NameCatalog;
            }());
            simulator.NameCatalog = NameCatalog;
            NameCatalog["__class"] = "desmoj.core.simulator.NameCatalog";
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Constructs a named object with the given initial name. Note, that this
             * allows clients to produce more than one object with one name, thus being
             * unable to distinguish those objects in reports!
             *
             * @param {string} name
             * java.lang.String : The given initial name for the named object
             * @class
             * @author Tim Lechler
             */
            var NamedObject = (function () {
                function NamedObject(name) {
                    this._myName = null;
                    if (name == null)
                        this._myName = "unnamed";
                    else
                        this._myName = name;
                }
                /**
                 * Returns the name of the named object. This is the same name displayed in
                 * reports and trace files when this named object is shown in those reports
                 * or trace files.
                 *
                 * @return {string} java.lang.String : The name of the named object
                 */
                NamedObject.prototype.getName = function () {
                    return this._myName;
                };
                /**
                 * Returns the quoted name of the named object. This is the name displayed
                 * in reports and trace files when this named object is shown.
                 *
                 * @return {string} java.lang.String : The quoted name of the named object
                 */
                NamedObject.prototype.getQuotedName = function () {
                    return "\'" + this._myName + "\'";
                };
                /**
                 * Changes the name of the named object. This might be necessary for
                 * automatically created named object of a user defined model, but should
                 * not be used for elements of the framework or basic objects of the user
                 * model. Changing names of objects while runtime will confuse any trace
                 * output and generally make traces more difficult if not impossible to
                 * follow.
                 *
                 * @param {string} newName
                 * java.lang.String : The new name for the named object
                 */
                NamedObject.prototype.rename = function (newName) {
                    this._myName = newName;
                };
                /**
                 * Overrides the java.lang.Object's toString method to return the named
                 * object's name when given as parameter to a method that expects a string
                 * to be passed.
                 *
                 * @return {string} java.lang.String : The named object's name
                 */
                NamedObject.prototype.toString = function () {
                    return this._myName;
                };
                NamedObject.prototype.clone = function () {
                    return (function (o) { var clone = Object.create(o); for (var p in o) {
                        if (o.hasOwnProperty(p))
                            clone[p] = o[p];
                    } return clone; })(this);
                };
                return NamedObject;
            }());
            simulator.NamedObject = NamedObject;
            NamedObject["__class"] = "desmoj.core.simulator.NamedObject";
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Class to Represent a Parameter. This parameter can be an experiment-
             * parameter or a model-parameter. Parameters are variables that are
             * accessible from everywhere in the model. Model-parameters are assignable
             * from model, experiment-parameters from experiment.
             *
             * @see desmoj.core.simulator.ParameterManager
             * @see desmoj.core.simulator.ModelParameterManager
             * @see desmoj.core.simulator.ExperimentParameterManager
             *
             * @author Tim Janz
             * @version DESMO-J, Ver. 2.5.1e copyright (c) 2017
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License. You
             * may obtain a copy of the License at
             * http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS"
             * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
             * or implied. See the License for the specific language governing
             * permissions and limitations under the License.
             * @class
             */
            var Parameter = (function () {
                function Parameter(parameterType, type, name, value, defaultValue) {
                    this._parameterType = null;
                    this._type = null;
                    this._name = null;
                    this._value = null;
                    this._defaultValue = null;
                    this._parameterType = parameterType;
                    this._type = type;
                    this._name = name;
                    this._value = value;
                    this._defaultValue = defaultValue;
                }
                /**
                 * Returns the parameter's type.
                 *
                 * @return
                 * the parameter's type
                 * @return {*}
                 */
                Parameter.prototype.getType = function () {
                    return this._type;
                };
                /**
                 * Returns the parameter's name
                 *
                 * @return
                 * the parameter's name
                 * @return {string}
                 */
                Parameter.prototype.getName = function () {
                    return this._name;
                };
                /**
                 * sets the parameter's value.
                 *
                 * @param {*} value
                 * the parameter's new value
                 */
                Parameter.prototype.setValue = function (value) {
                    if (this._type.isAssignableFrom(value.constructor)) {
                        this._value = value;
                    }
                    else {
                    }
                };
                /**
                 * returns the parameter's value
                 *
                 * @return
                 * the parameter's value
                 * @return {*}
                 */
                Parameter.prototype.getValue = function () {
                    if (!this.hasValue() && !this.hasDefaultValue()) {
                    }
                    return this.hasValue() ? this._value : this._defaultValue;
                };
                /**
                 * Checks, if this parameter has a value.
                 *
                 * @return
                 * if parameter has a value
                 * @return {boolean}
                 */
                Parameter.prototype.hasValue = function () {
                    return (this._value != null);
                };
                /**
                 * Checks, if this parameter has a default value.
                 *
                 * @return
                 * if parameter has a default value
                 * @return {boolean}
                 */
                Parameter.prototype.hasDefaultValue = function () {
                    return (this._defaultValue != null);
                };
                /**
                 * Is this parameter a model-parameter or an experiment-parameter?
                 *
                 * @return
                 * ParameterType.MODELPARAMETER if this parameter is a model-parameter, or
                 * ParameterType.EXPERIMENTPARAMETER if this parameter is an experiment-parameter
                 * @return {desmoj.core.simulator.Parameter.ParameterType}
                 */
                Parameter.prototype.getParameterType = function () {
                    return this._parameterType;
                };
                /**
                 * Returns the parameter as a String
                 *
                 * @return
                 * the parameter as a String
                 * @return {string}
                 */
                Parameter.prototype.toString = function () {
                    return "(" + this._type.toString() + ") " + this._name + ": " + this._value.toString();
                };
                Parameter.createExperimentParameter = function (type, name, defaultValue) {
                    if (defaultValue === void 0) { defaultValue = null; }
                    return new Parameter(Parameter.ParameterType.EXPERIMENTPARAMETER, type, name, null, defaultValue);
                };
                Parameter.createModelParameter = function (type, name, value) {
                    if (value === void 0) { value = null; }
                    return new Parameter(Parameter.ParameterType.MODELPARAMETER, type, name, value, null);
                };
                return Parameter;
            }());
            simulator.Parameter = Parameter;
            Parameter["__class"] = "desmoj.core.simulator.Parameter";
            (function (Parameter) {
                /**
                 * Enum to decide, if a parameter is a model-parameter or an experiment-
                 * parameter
                 * @enum
                 * @property {desmoj.core.simulator.Parameter.ParameterType} EXPERIMENTPARAMETER
                 * @property {desmoj.core.simulator.Parameter.ParameterType} MODELPARAMETER
                 * @class
                 */
                var ParameterType;
                (function (ParameterType) {
                    ParameterType[ParameterType["EXPERIMENTPARAMETER"] = 0] = "EXPERIMENTPARAMETER";
                    ParameterType[ParameterType["MODELPARAMETER"] = 1] = "MODELPARAMETER";
                })(ParameterType = Parameter.ParameterType || (Parameter.ParameterType = {}));
            })(Parameter = simulator.Parameter || (simulator.Parameter = {}));
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Constructs a ParameterManager
             * @class
             * @author Tim Janz
             */
            var ParameterManager = (function () {
                function ParameterManager() {
                    this._parameters = null;
                    this._parameters = ({});
                }
                ParameterManager.prototype.declareExperimentParameter$java_lang_Class$java_lang_String = function (type, name) {
                    /* put */ (this._parameters[name] = desmoj.core.simulator.Parameter.createExperimentParameter(type, name));
                };
                ParameterManager.prototype.declareExperimentParameter$java_lang_Class$java_lang_String$java_lang_Object = function (type, name, defaultValue) {
                    /* put */ (this._parameters[name] = desmoj.core.simulator.Parameter.createExperimentParameter(type, name, defaultValue));
                };
                /**
                 * Method to declare a experiment-parameter. The experiment-parameter's
                 * declarations are part of the simulation-model. The experiment-
                 * parameter's assignments are in contrast part of an experiment.
                 * The default value is used, if an experiment dosen't assign a
                 * value to this parameter.
                 *
                 * @param {*} type
                 * the experiment-parameter's type
                 * @param {string} name
                 * the experiment-parameter's name
                 * @param {*} defaultValue
                 * the experiment-parameter's default value
                 */
                ParameterManager.prototype.declareExperimentParameter = function (type, name, defaultValue) {
                    if (((type != null) || type === null) && ((typeof name === 'string') || name === null) && ((defaultValue != null) || defaultValue === null)) {
                        return this.declareExperimentParameter$java_lang_Class$java_lang_String$java_lang_Object(type, name, defaultValue);
                    }
                    else if (((type != null) || type === null) && ((typeof name === 'string') || name === null) && defaultValue === undefined) {
                        return this.declareExperimentParameter$java_lang_Class$java_lang_String(type, name);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Method to declare a model-parameter.
                 *
                 * @param {*} type
                 * the model-parameter's type
                 * @param {string} name
                 * the model-parameter's name
                 */
                ParameterManager.prototype.declareModelParameter = function (type, name) {
                    /* put */ (this._parameters[name] = desmoj.core.simulator.Parameter.createModelParameter(type, name));
                };
                /**
                 * Method to initialize (declare and assign) a model-parameter.
                 *
                 * @param {*} type
                 * the model-parameter's type
                 * @param {string} name
                 * the model-parameter's name
                 * @param {*} value
                 * the model-parameter's value
                 */
                ParameterManager.prototype.initializeModelParameter = function (type, name, value) {
                    /* put */ (this._parameters[name] = desmoj.core.simulator.Parameter.createModelParameter(type, name, value));
                };
                /**
                 * Method to assign a value to a model-parameter declared previously.
                 *
                 * @param {string} name
                 * the model-parameter's name
                 * @param {*} value
                 * the model-parameter's value
                 */
                ParameterManager.prototype.assignModelParameter = function (name, value) {
                    var param = (function (m, k) { return m[k] ? m[k] : null; })(this._parameters, name);
                    if (param.getParameterType() === desmoj.core.simulator.Parameter.ParameterType.MODELPARAMETER) {
                        param.setValue(value);
                    }
                    else {
                    }
                };
                /**
                 * Method assign a value to an experiment-parameter declared
                 * previously by calling the model's parameter-manager method
                 * to declare an experiment-parameter
                 *
                 * @param {string} name
                 * the parameter's name
                 * @param {*} value
                 * the parameter's value
                 */
                ParameterManager.prototype.assignExperimentParameter = function (name, value) {
                    var param = (function (m, k) { return m[k] ? m[k] : null; })(this._parameters, name);
                    if (param.getParameterType() === desmoj.core.simulator.Parameter.ParameterType.EXPERIMENTPARAMETER) {
                        param.setValue(value);
                    }
                    else {
                    }
                };
                /**
                 * Returns the value of an experiment- or model-parameter. Experiment-
                 * and model-parameters are accessible through the model, to be able
                 * to use the parameter's values at design-time.
                 *
                 * @param {string} name
                 * the parameter's name
                 * @return
                 * the parameter's value
                 * @return {*}
                 */
                ParameterManager.prototype.getParameterValue = function (name) {
                    var result = null;
                    if (this._parameters.hasOwnProperty(name)) {
                        result = (function (m, k) { return m[k] ? m[k] : null; })(this._parameters, name).getValue();
                    }
                    else {
                    }
                    return result;
                };
                /**
                 * Returns all declared parameters.
                 *
                 * @return
                 * the parameters
                 * @return {desmoj.core.simulator.Parameter[]}
                 */
                ParameterManager.prototype.getParameters = function () {
                    return (function (obj) { return Object.keys(obj).map(function (key) { return obj[key]; }); })(this._parameters);
                };
                return ParameterManager;
            }());
            simulator.ParameterManager = ParameterManager;
            ParameterManager["__class"] = "desmoj.core.simulator.ParameterManager";
            ParameterManager["__interfaces"] = ["desmoj.core.simulator.ModelParameterManager", "desmoj.core.simulator.ExperimentParameterManager"];
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Is the abstract superclass for all the classes implementing different
             * queueing strategies for a waiting-queue. It provides all the basic methods
             * for inserting objects in a queue, retrieving objects from a queue and getting
             * basic informations about the queue. It is used in many kinds of queue
             * implementations where collective functionalities are implemented by
             * <code>QueueListStandard</code> and are specified e.g. in <code>QueueListFifo</code>
             * or <code>QueueListLifo</code>.
             *
             * @see QueueBased
             * @see Queue
             * @see ProcessQueue
             * @see QueueListFifo
             * @see QueueListLifo
             *
             * @version DESMO-J, Ver. 2.5.1e copyright (c) 2017
             * @author Soenke Claassen
             * @author based upon ideas from Tim Lechler
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License. You
             * may obtain a copy of the License at
             * http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS"
             * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
             * or implied. See the License for the specific language governing
             * permissions and limitations under the License.
             * @class
             */
            var QueueList = (function () {
                function QueueList() {
                    this.clientQ = null;
                    this.timemap = null;
                }
                QueueList.prototype.get$int = function (index) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                QueueList.prototype.get$desmoj_core_simulator_Entity = function (element) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Returns the position of the named <code>Entity</code>.
                 * The first position is 0, the last one size()-1.
                 *
                 * @return {number} : The position of the <code>Entity</code> or <code>-1</code> if no such exists.
                 * @param {desmoj.core.simulator.Entity} element
                 */
                QueueList.prototype.get = function (element) {
                    if (((element != null) || element === null)) {
                        return this.get$desmoj_core_simulator_Entity(element);
                    }
                    else if (((typeof element === 'number') || element === null)) {
                        return this.get$int(element);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the <code>QueueBased</code> object this <code>QueueList</code>
                 * serves as a queue implementation for.
                 *
                 * @return {desmoj.core.simulator.QueueBased} QueueBased : The <code>QueueBased</code> object this
                 * <code>QueueList</code> serves as a container for.
                 */
                QueueList.prototype.getQueueBased = function () {
                    return this.clientQ;
                };
                QueueList.prototype.remove$desmoj_core_simulator_Entity = function (e) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Should remove the given <code>Entity</code> "e" from the queue. If this
                 * is done successfully <code>true</code> is returned, <code>false</code>
                 * otherwise.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if the given <code>Entity</code>
                 * is removed successfully, <code>false</code> otherwise.
                 * @param {desmoj.core.simulator.Entity} e
                 * E : The <code>Entity</code> which is to be
                 * removed from the queue.
                 */
                QueueList.prototype.remove = function (e) {
                    if (((e != null) || e === null)) {
                        return this.remove$desmoj_core_simulator_Entity(e);
                    }
                    else if (((typeof e === 'number') || e === null)) {
                        return this.remove$int(e);
                    }
                    else
                        throw new Error('invalid overload');
                };
                QueueList.prototype.remove$int = function (index) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                /**
                 * Sets the client queue for which the entities are stored. Is needed,
                 * because this can not be done in the no-arg constructor.
                 *
                 * @param {desmoj.core.simulator.QueueBased} queueBase
                 * desmoj.QueueBased : The QueueBased using this queueing system.
                 */
                QueueList.prototype.setQueueBased = function (queueBase) {
                    if (queueBase == null) {
                        throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can not create QueueListStandardFifo! Simulation aborted.", "Class : QueueListStandardFifo / Method : setClientQueue(QueueBased queueBase) ", "The reference to the QueueBased object needed is a null reference.", "Always check to give valid references only.", null)));
                    }
                    this.clientQ = queueBase;
                };
                /**
                 * Returns the actual size of the QueueList.
                 *
                 * @return {number} : The method returns the size as an <code>int</code>.
                 * The value is 0 if no Entity is in line.
                 */
                QueueList.prototype.size = function () {
                    return this.clientQ.length();
                };
                /**
                 * This method is used for statistical data in the class QueueBased.
                 *
                 * @param {desmoj.core.simulator.Entity} e
                 */
                QueueList.prototype.statisticalInsert = function (e) {
                    /* put */ (function (m, k, v) { if (m.entries == null)
                        m.entries = []; for (var i = 0; i < m.entries.length; i++)
                        if (m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) {
                            m.entries[i].value = v;
                            return;
                        } m.entries.push({ key: k, value: v, getKey: function () { return this.key; }, getValue: function () { return this.value; } }); })(this.timemap, e, this.clientQ.presentTime());
                    this.clientQ.addItem();
                };
                /**
                 * This method is used for statistical data in the class QueueBased.
                 *
                 * @param {desmoj.core.simulator.Entity} e
                 */
                QueueList.prototype.statisticalRemove = function (e) {
                    this.clientQ.deleteItem(/* get */ (function (m, k) { if (m.entries == null)
                        m.entries = []; for (var i = 0; i < m.entries.length; i++)
                        if (m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) {
                            return m.entries[i].value;
                        } return null; })(this.timemap, e));
                    /* remove */ (function (m, k) { if (m.entries == null)
                        m.entries = []; for (var i = 0; i < m.entries.length; i++)
                        if (m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) {
                            return m.entries.splice(i, 1)[0];
                        } })(this.timemap, e);
                };
                /**
                 * Returns an iterator over the entities enqueued.
                 *
                 * @return {*} java.lang.Iterator&lt;E&gt; : An iterator over the entities enqueued.
                 */
                QueueList.prototype.iterator = function () {
                    return new QueueList.QueueListIterator(this, this);
                };
                return QueueList;
            }());
            simulator.QueueList = QueueList;
            QueueList["__class"] = "desmoj.core.simulator.QueueList";
            QueueList["__interfaces"] = ["java.lang.Iterable"];
            (function (QueueList) {
                /**
                 * Private queue list iterator, e.g. required for processing all queue elements in a
                 * for-each-loop.
                 * @param {desmoj.core.simulator.QueueList} clientQ
                 * @class
                 */
                var QueueListIterator = (function () {
                    function QueueListIterator(__parent, clientQ) {
                        this.__parent = __parent;
                        this.clientQ = null;
                        this.__next = null;
                        this.lastReturned = null;
                        __parent.clientQ = clientQ;
                        this.__next = clientQ.first();
                        this.lastReturned = null;
                    }
                    QueueListIterator.prototype.hasNext = function () {
                        return this.__next != null;
                    };
                    QueueListIterator.prototype.next = function () {
                        this.lastReturned = this.__next;
                        this.__next = this.__parent.clientQ.succ(this.__next);
                        return this.lastReturned;
                    };
                    QueueListIterator.prototype.remove = function () {
                        this.__parent.clientQ.remove(this.lastReturned);
                    };
                    return QueueListIterator;
                }());
                QueueList.QueueListIterator = QueueListIterator;
                QueueListIterator["__class"] = "desmoj.core.simulator.QueueList.QueueListIterator";
                QueueListIterator["__interfaces"] = ["java.util.Iterator"];
            })(QueueList = simulator.QueueList || (simulator.QueueList = {}));
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Creates an real time wrapper for an external event.
             *
             * @param {desmoj.core.simulator.ExternalEvent} externalEvent
             * @param {number} nanoTimeStamp
             * @class
             * @author Felix Klueckmann
             */
            var RealTimeEventWrapper = (function () {
                function RealTimeEventWrapper(externalEvent, nanoTimeStamp) {
                    var _this = this;
                    if (((externalEvent != null && externalEvent instanceof desmoj.core.simulator.ExternalEvent) || externalEvent === null) && ((typeof nanoTimeStamp === 'number') || nanoTimeStamp === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        this._nanos = 0;
                        this._myExternalEvent = null;
                        this._nanos = 0;
                        this._myExternalEvent = null;
                        (function () {
                            _this._myExternalEvent = externalEvent;
                            _this._nanos = nanoTimeStamp;
                        })();
                    }
                    else if (((externalEvent != null && externalEvent instanceof desmoj.core.simulator.ExternalEvent) || externalEvent === null) && nanoTimeStamp === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        this._nanos = 0;
                        this._myExternalEvent = null;
                        this._nanos = 0;
                        this._myExternalEvent = null;
                        (function () {
                            _this._myExternalEvent = externalEvent;
                            _this.setNanos(def.System.nanoTime());
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns the encapsulated ExternalEvent
                 *
                 * @return {desmoj.core.simulator.ExternalEvent}
                 */
                RealTimeEventWrapper.prototype.getExternalEvent = function () {
                    return this._myExternalEvent;
                };
                /**
                 * Schedules the external event to happen at the simulation time equivalent
                 * to the nanosecond timestamp of this RealTimeEventWrapper.
                 *
                 */
                RealTimeEventWrapper.prototype.realTimeSchedule = function () {
                    this._myExternalEvent.getModel().getExperiment().getScheduler().realTimeSchedule(this);
                };
                /**
                 * Sets the nanosecond timestamp of this RealTimeEventWrapper. Use
                 * method System.nanoTime() to get a time stamp.
                 * @param {number} nanos
                 */
                RealTimeEventWrapper.prototype.setNanos = function (nanos) {
                    this._nanos = nanos;
                };
                /**
                 * Returns the nanosecond timestamp associated with the encapsulated ExternalEvent.	 *
                 * @return {number}
                 */
                RealTimeEventWrapper.prototype.getNanos = function () {
                    return this._nanos;
                };
                return RealTimeEventWrapper;
            }());
            simulator.RealTimeEventWrapper = RealTimeEventWrapper;
            RealTimeEventWrapper["__class"] = "desmoj.core.simulator.RealTimeEventWrapper";
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Constructs a DecimalTimeFormatter.
             *
             * @param {def.TimeUnit} unit
             * java.util.concurrent.TimeUnit : The time values that will be
             * used
             * @param {number} floats
             * int : The number of floating point digits to print
             * @param {boolean} writeUnit
             * boolean : Indicates if the time unit will be included in the
             * time String.
             * @param {def.TimeUnit} epsilon
             * @class
             * @author goebel
             */
            var SingleUnitTimeFormatter = (function () {
                function SingleUnitTimeFormatter(unit, epsilon, floats, writeUnit) {
                    this._myTimeUnit = null;
                    this._epsilon = null;
                    this._myFactor = 0;
                    this._floats = 0;
                    this._precisionFactor = 0;
                    this._writeUnit = false;
                    this._myTimeUnit = unit;
                    this._epsilon = epsilon;
                    this._floats = floats;
                    this._precisionFactor = Math.floor(Math.pow(10, floats));
                    this._writeUnit = writeUnit;
                    this._myFactor = def.TimeUnit["_$wrappers"][epsilon].convert(1, this._myTimeUnit);
                }
                SingleUnitTimeFormatter.prototype.buildTimeString$desmoj_core_simulator_TimeInstant = function (instant) {
                    return this.buildSingleUnitTimeString(instant.getTimeInEpsilon());
                };
                /**
                 * Returns the String-Representation of the given TimeInstant
                 *
                 * @param {desmoj.core.simulator.TimeInstant} instant
                 * @return {string}
                 */
                SingleUnitTimeFormatter.prototype.buildTimeString = function (instant) {
                    if (((instant != null && instant instanceof desmoj.core.simulator.TimeInstant) || instant === null)) {
                        return this.buildTimeString$desmoj_core_simulator_TimeInstant(instant);
                    }
                    else if (((instant != null && instant instanceof desmoj.core.simulator.TimeSpan) || instant === null)) {
                        return this.buildTimeString$desmoj_core_simulator_TimeSpan(instant);
                    }
                    else
                        throw new Error('invalid overload');
                };
                SingleUnitTimeFormatter.prototype.buildTimeString$desmoj_core_simulator_TimeSpan = function (span) {
                    return this.buildSingleUnitTimeString(span.getTimeInEpsilon());
                };
                /**
                 * Returns the String-Representation of the given time object.
                 *
                 * @param {number} timeValue
                 * @return {string}
                 * @private
                 */
                /*private*/ SingleUnitTimeFormatter.prototype.buildSingleUnitTimeString = function (timeValue) {
                    var _this = this;
                    var timeStringBuffer = { str: "", toString: function () { return this.str; } };
                    /* append */ (function (sb) { return sb.str = sb.str.concat(('' + (def.TimeUnit["_$wrappers"][_this._myTimeUnit].convert(timeValue, _this._epsilon)))); })(timeStringBuffer);
                    if (def.TimeUnit["_$wrappers"][this._myTimeUnit].compareTo2(this._epsilon) > 0) {
                        /* append */ (function (sb) { return sb.str = sb.str.concat('.'); })(timeStringBuffer);
                        var fractionTime = def.TimeUnit["_$wrappers"][this._myTimeUnit].convert((timeValue % this._myFactor) * this._precisionFactor, this._epsilon);
                        var fractionTimeString_1 = ('' + (fractionTime));
                        var zero_1 = '0';
                        for (var i = fractionTimeString_1.length; i < this._floats; i++) {
                            /* append */ (function (sb) { return sb.str = sb.str.concat(zero_1); })(timeStringBuffer);
                        }
                        ;
                        /* append */ (function (sb) { return sb.str = sb.str.concat(fractionTimeString_1); })(timeStringBuffer);
                    }
                    if (this._writeUnit) {
                        /* append */ (function (sb) { return sb.str = sb.str.concat(' '); })(timeStringBuffer);
                        /* append */ (function (sb) { return sb.str = sb.str.concat(def.TimeUnit[_this._myTimeUnit]); })(timeStringBuffer);
                    }
                    return timeStringBuffer.str;
                };
                SingleUnitTimeFormatter.prototype.getUnit = function () {
                    return def.TimeUnit["_$wrappers"][this._myTimeUnit].toString().toLowerCase();
                };
                return SingleUnitTimeFormatter;
            }());
            simulator.SingleUnitTimeFormatter = SingleUnitTimeFormatter;
            SingleUnitTimeFormatter["__class"] = "desmoj.core.simulator.SingleUnitTimeFormatter";
            SingleUnitTimeFormatter["__interfaces"] = ["desmoj.core.simulator.TimeFormatter"];
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Constructs a TimeInstant object with the given time value in the time
             * unit of the given parameter. It represents a time instant in simulation
             * time. Note that trying to create a TimeInstant object The simulation will
             * also stop immediately if the TimeSpan is larger than Long.MAX_VALUE-1 (in
             * the unit of epsilon).
             *
             * @param {number} time
             * long : The time value of this TimeInstant in the time unit of
             * unit.
             * @param {def.TimeUnit} unit
             * TimeUnit: the TimeUnit
             * @class
             * @author Felix Klueckmann
             */
            var TimeInstant = (function () {
                function TimeInstant(calendar, applyPrefferdTimeZoneFromCalendar) {
                    var _this = this;
                    if (((calendar != null && (calendar instanceof Date)) || calendar === null) && ((typeof applyPrefferdTimeZoneFromCalendar === 'boolean') || applyPrefferdTimeZoneFromCalendar === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        {
                            var __args_2 = Array.prototype.slice.call(arguments);
                            var time_1 = calendar.getTime();
                            var unit_1 = def.TimeUnit.MILLISECONDS;
                            this._timeInEpsilon = 0;
                            this._preferredTimeZone = null;
                            this._timeInEpsilon = 0;
                            this._preferredTimeZone = null;
                            (function () {
                                if (unit_1 == null) {
                                    throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t create TimeInstant object! Simulation aborted.", "Class : TimeInstant  Constructor : TimeInstant(long, TimeUnit)", "Time unit passed is null", "Make sure to pass a non-null time unit. \nNote that before connecting model and experiment, TimeInstants must explicitly\nrefer to a time unit as the reference unit is not yet defined,e.g. use \nTimeInstant(long time, TimeUnit unit) instead ofTimeInstant(long time).", null)));
                                }
                                if (def.TimeUnit["_$wrappers"][unit_1].compareTo2(desmoj.core.simulator.TimeOperations.getEpsilon()) < 0) {
                                    if (desmoj.core.simulator.TimeOperations.getStartTime() != null) {
                                        console.info("Starttime: " + desmoj.core.simulator.TimeOperations.getStartTime());
                                        var timeSinceStart = time_1 - def.TimeUnit["_$wrappers"][unit_1].convert(desmoj.core.simulator.TimeOperations.getStartTime().getTimeInEpsilon(), desmoj.core.simulator.TimeOperations.getEpsilon());
                                        console.info("TimeSinceStart: " + timeSinceStart);
                                        if (timeSinceStart !== 0) {
                                            time_1 = time_1 - (timeSinceStart % def.TimeUnit["_$wrappers"][unit_1].convert(1, desmoj.core.simulator.TimeOperations.getEpsilon()));
                                        }
                                    }
                                }
                                _this._timeInEpsilon = def.TimeUnit["_$wrappers"][desmoj.core.simulator.TimeOperations.getEpsilon()].convert(time_1, unit_1);
                                desmoj.core.simulator.TimeOperations.timeObjectsCreated = true;
                                if (_this._timeInEpsilon === Number.MAX_VALUE) {
                                    throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t create TimeInstant object! Simulation aborted.", "Class : TimeInstant  Constructor : TimeInstant(long,TimeUnit)", "the TimeInstant is too big. ", "Can only create TimeInstant objects which are smaller than Long.MAX_VALUE (in the TimeUnit of epsilon).", null)));
                                }
                                _this._preferredTimeZone = TimeInstant.DEFAULT_PREFERRED_TIMEZONE_$LI$();
                            })();
                        }
                        (function () {
                            if (applyPrefferdTimeZoneFromCalendar)
                                _this._preferredTimeZone = calendar.getTimeZone();
                        })();
                    }
                    else if (((typeof calendar === 'number') || calendar === null) && ((typeof applyPrefferdTimeZoneFromCalendar === 'number') || applyPrefferdTimeZoneFromCalendar === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        var time_2 = __args[0];
                        var unit_2 = __args[1];
                        this._timeInEpsilon = 0;
                        this._preferredTimeZone = null;
                        this._timeInEpsilon = 0;
                        this._preferredTimeZone = null;
                        (function () {
                            if (unit_2 == null) {
                                throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t create TimeInstant object! Simulation aborted.", "Class : TimeInstant  Constructor : TimeInstant(long, TimeUnit)", "Time unit passed is null", "Make sure to pass a non-null time unit. \nNote that before connecting model and experiment, TimeInstants must explicitly\nrefer to a time unit as the reference unit is not yet defined,e.g. use \nTimeInstant(long time, TimeUnit unit) instead ofTimeInstant(long time).", null)));
                            }
                            if (def.TimeUnit["_$wrappers"][unit_2].compareTo2(desmoj.core.simulator.TimeOperations.getEpsilon()) < 0) {
                                if (desmoj.core.simulator.TimeOperations.getStartTime() != null) {
                                    console.info("Starttime: " + desmoj.core.simulator.TimeOperations.getStartTime());
                                    var timeSinceStart = time_2 - def.TimeUnit["_$wrappers"][unit_2].convert(desmoj.core.simulator.TimeOperations.getStartTime().getTimeInEpsilon(), desmoj.core.simulator.TimeOperations.getEpsilon());
                                    console.info("TimeSinceStart: " + timeSinceStart);
                                    if (timeSinceStart !== 0) {
                                        time_2 = time_2 - (timeSinceStart % def.TimeUnit["_$wrappers"][unit_2].convert(1, desmoj.core.simulator.TimeOperations.getEpsilon()));
                                    }
                                }
                            }
                            _this._timeInEpsilon = def.TimeUnit["_$wrappers"][desmoj.core.simulator.TimeOperations.getEpsilon()].convert(time_2, unit_2);
                            desmoj.core.simulator.TimeOperations.timeObjectsCreated = true;
                            if (_this._timeInEpsilon === Number.MAX_VALUE) {
                                throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t create TimeInstant object! Simulation aborted.", "Class : TimeInstant  Constructor : TimeInstant(long,TimeUnit)", "the TimeInstant is too big. ", "Can only create TimeInstant objects which are smaller than Long.MAX_VALUE (in the TimeUnit of epsilon).", null)));
                            }
                            _this._preferredTimeZone = TimeInstant.DEFAULT_PREFERRED_TIMEZONE_$LI$();
                        })();
                    }
                    else if (((typeof calendar === 'number') || calendar === null) && ((typeof applyPrefferdTimeZoneFromCalendar === 'number') || applyPrefferdTimeZoneFromCalendar === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        var time_3 = __args[0];
                        var unit_3 = __args[1];
                        this._timeInEpsilon = 0;
                        this._preferredTimeZone = null;
                        this._timeInEpsilon = 0;
                        this._preferredTimeZone = null;
                        (function () {
                            if (unit_3 == null) {
                                throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t create TimeInstant object! Simulation aborted.", "Class : TimeInstant  Constructor : TimeInstant(double, TimeUnit)", "Time unit passed is null", "Make sure to pass a non-null time unit. \nNote that before connecting model and experiment, TimeInstants must explicitly\nrefer to a time unit as the reference unit is not yet defined,e.g. use \nTimeInstant(double time, TimeUnit unit) instead ofTimeInstant(double time).", null)));
                            }
                            if (def.TimeUnit["_$wrappers"][unit_3].compareTo2(desmoj.core.simulator.TimeOperations.getEpsilon()) < 0) {
                                if (desmoj.core.simulator.TimeOperations.getStartTime() != null) {
                                    console.info("Starttime: " + desmoj.core.simulator.TimeOperations.getStartTime());
                                    var timeSinceStart = time_3 - def.TimeUnit["_$wrappers"][unit_3].convert(desmoj.core.simulator.TimeOperations.getStartTime().getTimeInEpsilon(), desmoj.core.simulator.TimeOperations.getEpsilon());
                                    console.info("TimeSinceStart: " + timeSinceStart);
                                    if (timeSinceStart !== 0) {
                                        time_3 = time_3 - (timeSinceStart % def.TimeUnit["_$wrappers"][unit_3].convert(1, desmoj.core.simulator.TimeOperations.getEpsilon()));
                                    }
                                }
                            }
                            _this._timeInEpsilon = Math.floor((def.TimeUnit["_$wrappers"][desmoj.core.simulator.TimeOperations.getEpsilon()].convert(1, unit_3) * time_3));
                            desmoj.core.simulator.TimeOperations.timeObjectsCreated = true;
                            if (_this._timeInEpsilon === Number.MAX_VALUE) {
                                throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t create TimeInstant object! Simulation aborted.", "Class : TimeInstant  Constructor : TimeInstant(long,TimeUnit)", "the TimeInstant is too big. ", "Can only create TimeInstant objects which are smaller than Long.MAX_VALUE (in the TimeUnit of epsilon).", null)));
                            }
                            _this._preferredTimeZone = TimeInstant.DEFAULT_PREFERRED_TIMEZONE_$LI$();
                        })();
                    }
                    else if (((calendar != null && (calendar instanceof Date)) || calendar === null) && applyPrefferdTimeZoneFromCalendar === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        {
                            var __args_3 = Array.prototype.slice.call(arguments);
                            var applyPrefferdTimeZoneFromCalendar_1 = false;
                            {
                                var __args_4 = Array.prototype.slice.call(arguments);
                                var time_4 = calendar.getTime();
                                var unit_4 = def.TimeUnit.MILLISECONDS;
                                this._timeInEpsilon = 0;
                                this._preferredTimeZone = null;
                                this._timeInEpsilon = 0;
                                this._preferredTimeZone = null;
                                (function () {
                                    if (unit_4 == null) {
                                        throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t create TimeInstant object! Simulation aborted.", "Class : TimeInstant  Constructor : TimeInstant(long, TimeUnit)", "Time unit passed is null", "Make sure to pass a non-null time unit. \nNote that before connecting model and experiment, TimeInstants must explicitly\nrefer to a time unit as the reference unit is not yet defined,e.g. use \nTimeInstant(long time, TimeUnit unit) instead ofTimeInstant(long time).", null)));
                                    }
                                    if (def.TimeUnit["_$wrappers"][unit_4].compareTo2(desmoj.core.simulator.TimeOperations.getEpsilon()) < 0) {
                                        if (desmoj.core.simulator.TimeOperations.getStartTime() != null) {
                                            console.info("Starttime: " + desmoj.core.simulator.TimeOperations.getStartTime());
                                            var timeSinceStart = time_4 - def.TimeUnit["_$wrappers"][unit_4].convert(desmoj.core.simulator.TimeOperations.getStartTime().getTimeInEpsilon(), desmoj.core.simulator.TimeOperations.getEpsilon());
                                            console.info("TimeSinceStart: " + timeSinceStart);
                                            if (timeSinceStart !== 0) {
                                                time_4 = time_4 - (timeSinceStart % def.TimeUnit["_$wrappers"][unit_4].convert(1, desmoj.core.simulator.TimeOperations.getEpsilon()));
                                            }
                                        }
                                    }
                                    _this._timeInEpsilon = def.TimeUnit["_$wrappers"][desmoj.core.simulator.TimeOperations.getEpsilon()].convert(time_4, unit_4);
                                    desmoj.core.simulator.TimeOperations.timeObjectsCreated = true;
                                    if (_this._timeInEpsilon === Number.MAX_VALUE) {
                                        throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t create TimeInstant object! Simulation aborted.", "Class : TimeInstant  Constructor : TimeInstant(long,TimeUnit)", "the TimeInstant is too big. ", "Can only create TimeInstant objects which are smaller than Long.MAX_VALUE (in the TimeUnit of epsilon).", null)));
                                    }
                                    _this._preferredTimeZone = TimeInstant.DEFAULT_PREFERRED_TIMEZONE_$LI$();
                                })();
                            }
                            (function () {
                                if (applyPrefferdTimeZoneFromCalendar_1)
                                    _this._preferredTimeZone = calendar.getTimeZone();
                            })();
                        }
                    }
                    else if (((calendar != null && calendar instanceof Date) || calendar === null) && applyPrefferdTimeZoneFromCalendar === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        var date = __args[0];
                        {
                            var __args_5 = Array.prototype.slice.call(arguments);
                            var time_5 = date.getTime();
                            var unit_5 = def.TimeUnit.MILLISECONDS;
                            this._timeInEpsilon = 0;
                            this._preferredTimeZone = null;
                            this._timeInEpsilon = 0;
                            this._preferredTimeZone = null;
                            (function () {
                                if (unit_5 == null) {
                                    throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t create TimeInstant object! Simulation aborted.", "Class : TimeInstant  Constructor : TimeInstant(long, TimeUnit)", "Time unit passed is null", "Make sure to pass a non-null time unit. \nNote that before connecting model and experiment, TimeInstants must explicitly\nrefer to a time unit as the reference unit is not yet defined,e.g. use \nTimeInstant(long time, TimeUnit unit) instead ofTimeInstant(long time).", null)));
                                }
                                if (def.TimeUnit["_$wrappers"][unit_5].compareTo2(desmoj.core.simulator.TimeOperations.getEpsilon()) < 0) {
                                    if (desmoj.core.simulator.TimeOperations.getStartTime() != null) {
                                        console.info("Starttime: " + desmoj.core.simulator.TimeOperations.getStartTime());
                                        var timeSinceStart = time_5 - def.TimeUnit["_$wrappers"][unit_5].convert(desmoj.core.simulator.TimeOperations.getStartTime().getTimeInEpsilon(), desmoj.core.simulator.TimeOperations.getEpsilon());
                                        console.info("TimeSinceStart: " + timeSinceStart);
                                        if (timeSinceStart !== 0) {
                                            time_5 = time_5 - (timeSinceStart % def.TimeUnit["_$wrappers"][unit_5].convert(1, desmoj.core.simulator.TimeOperations.getEpsilon()));
                                        }
                                    }
                                }
                                _this._timeInEpsilon = def.TimeUnit["_$wrappers"][desmoj.core.simulator.TimeOperations.getEpsilon()].convert(time_5, unit_5);
                                desmoj.core.simulator.TimeOperations.timeObjectsCreated = true;
                                if (_this._timeInEpsilon === Number.MAX_VALUE) {
                                    throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t create TimeInstant object! Simulation aborted.", "Class : TimeInstant  Constructor : TimeInstant(long,TimeUnit)", "the TimeInstant is too big. ", "Can only create TimeInstant objects which are smaller than Long.MAX_VALUE (in the TimeUnit of epsilon).", null)));
                                }
                                _this._preferredTimeZone = TimeInstant.DEFAULT_PREFERRED_TIMEZONE_$LI$();
                            })();
                        }
                    }
                    else if (((typeof calendar === 'number') || calendar === null) && applyPrefferdTimeZoneFromCalendar === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        var timeInReferenceUnit = __args[0];
                        {
                            var __args_6 = Array.prototype.slice.call(arguments);
                            var time_6 = timeInReferenceUnit;
                            var unit_6 = desmoj.core.simulator.TimeOperations.getReferenceUnit();
                            this._timeInEpsilon = 0;
                            this._preferredTimeZone = null;
                            this._timeInEpsilon = 0;
                            this._preferredTimeZone = null;
                            (function () {
                                if (unit_6 == null) {
                                    throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t create TimeInstant object! Simulation aborted.", "Class : TimeInstant  Constructor : TimeInstant(long, TimeUnit)", "Time unit passed is null", "Make sure to pass a non-null time unit. \nNote that before connecting model and experiment, TimeInstants must explicitly\nrefer to a time unit as the reference unit is not yet defined,e.g. use \nTimeInstant(long time, TimeUnit unit) instead ofTimeInstant(long time).", null)));
                                }
                                if (def.TimeUnit["_$wrappers"][unit_6].compareTo2(desmoj.core.simulator.TimeOperations.getEpsilon()) < 0) {
                                    if (desmoj.core.simulator.TimeOperations.getStartTime() != null) {
                                        console.info("Starttime: " + desmoj.core.simulator.TimeOperations.getStartTime());
                                        var timeSinceStart = time_6 - def.TimeUnit["_$wrappers"][unit_6].convert(desmoj.core.simulator.TimeOperations.getStartTime().getTimeInEpsilon(), desmoj.core.simulator.TimeOperations.getEpsilon());
                                        console.info("TimeSinceStart: " + timeSinceStart);
                                        if (timeSinceStart !== 0) {
                                            time_6 = time_6 - (timeSinceStart % def.TimeUnit["_$wrappers"][unit_6].convert(1, desmoj.core.simulator.TimeOperations.getEpsilon()));
                                        }
                                    }
                                }
                                _this._timeInEpsilon = def.TimeUnit["_$wrappers"][desmoj.core.simulator.TimeOperations.getEpsilon()].convert(time_6, unit_6);
                                desmoj.core.simulator.TimeOperations.timeObjectsCreated = true;
                                if (_this._timeInEpsilon === Number.MAX_VALUE) {
                                    throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t create TimeInstant object! Simulation aborted.", "Class : TimeInstant  Constructor : TimeInstant(long,TimeUnit)", "the TimeInstant is too big. ", "Can only create TimeInstant objects which are smaller than Long.MAX_VALUE (in the TimeUnit of epsilon).", null)));
                                }
                                _this._preferredTimeZone = TimeInstant.DEFAULT_PREFERRED_TIMEZONE_$LI$();
                            })();
                        }
                    }
                    else if (((typeof calendar === 'number') || calendar === null) && applyPrefferdTimeZoneFromCalendar === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        var timeInReferenceUnit = __args[0];
                        {
                            var __args_7 = Array.prototype.slice.call(arguments);
                            var time_7 = timeInReferenceUnit;
                            var unit_7 = desmoj.core.simulator.TimeOperations.getReferenceUnit();
                            this._timeInEpsilon = 0;
                            this._preferredTimeZone = null;
                            this._timeInEpsilon = 0;
                            this._preferredTimeZone = null;
                            (function () {
                                if (unit_7 == null) {
                                    throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t create TimeInstant object! Simulation aborted.", "Class : TimeInstant  Constructor : TimeInstant(double, TimeUnit)", "Time unit passed is null", "Make sure to pass a non-null time unit. \nNote that before connecting model and experiment, TimeInstants must explicitly\nrefer to a time unit as the reference unit is not yet defined,e.g. use \nTimeInstant(double time, TimeUnit unit) instead ofTimeInstant(double time).", null)));
                                }
                                if (def.TimeUnit["_$wrappers"][unit_7].compareTo2(desmoj.core.simulator.TimeOperations.getEpsilon()) < 0) {
                                    if (desmoj.core.simulator.TimeOperations.getStartTime() != null) {
                                        console.info("Starttime: " + desmoj.core.simulator.TimeOperations.getStartTime());
                                        var timeSinceStart = time_7 - def.TimeUnit["_$wrappers"][unit_7].convert(desmoj.core.simulator.TimeOperations.getStartTime().getTimeInEpsilon(), desmoj.core.simulator.TimeOperations.getEpsilon());
                                        console.info("TimeSinceStart: " + timeSinceStart);
                                        if (timeSinceStart !== 0) {
                                            time_7 = time_7 - (timeSinceStart % def.TimeUnit["_$wrappers"][unit_7].convert(1, desmoj.core.simulator.TimeOperations.getEpsilon()));
                                        }
                                    }
                                }
                                _this._timeInEpsilon = Math.floor((def.TimeUnit["_$wrappers"][desmoj.core.simulator.TimeOperations.getEpsilon()].convert(1, unit_7) * time_7));
                                desmoj.core.simulator.TimeOperations.timeObjectsCreated = true;
                                if (_this._timeInEpsilon === Number.MAX_VALUE) {
                                    throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t create TimeInstant object! Simulation aborted.", "Class : TimeInstant  Constructor : TimeInstant(long,TimeUnit)", "the TimeInstant is too big. ", "Can only create TimeInstant objects which are smaller than Long.MAX_VALUE (in the TimeUnit of epsilon).", null)));
                                }
                                _this._preferredTimeZone = TimeInstant.DEFAULT_PREFERRED_TIMEZONE_$LI$();
                            })();
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                TimeInstant.DEFAULT_PREFERRED_TIMEZONE_$LI$ = function () { if (TimeInstant.DEFAULT_PREFERRED_TIMEZONE == null)
                    TimeInstant.DEFAULT_PREFERRED_TIMEZONE = "UTC"; return TimeInstant.DEFAULT_PREFERRED_TIMEZONE; };
                ;
                /**
                 * Returns the value of the TimeInstant object as a long type in the time
                 * unit of epsilon
                 *
                 * @return {number} long: the time value of the TimeInstant object as a long type in
                 * the time unit of epsilon
                 */
                TimeInstant.prototype.getTimeInEpsilon = function () {
                    return this._timeInEpsilon;
                };
                TimeInstant.prototype.getTimeTruncated$def_TimeUnit = function (unit) {
                    return def.TimeUnit["_$wrappers"][unit].convert(this._timeInEpsilon, desmoj.core.simulator.TimeOperations.getEpsilon());
                };
                /**
                 * Returns the value of this TimeInstant object as a long type in the time
                 * unit given as a parameter. If the parameter has a coarser granularity
                 * than epsilon the returned value will be truncated, so lose precision.
                 *
                 *
                 * @return {number} long: the time value of the TimeInstant object as a long type in
                 * the time unit given as a parameter or Long.MIN_VALUE if
                 * conversion would negatively overflow, or Long.MAX_VALUE if it
                 * would positively overflow.
                 * @param {def.TimeUnit} unit
                 */
                TimeInstant.prototype.getTimeTruncated = function (unit) {
                    if (((typeof unit === 'number') || unit === null)) {
                        return this.getTimeTruncated$def_TimeUnit(unit);
                    }
                    else if (unit === undefined) {
                        return this.getTimeTruncated$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                TimeInstant.prototype.getTimeTruncated$ = function () {
                    return this.getTimeTruncated$def_TimeUnit(desmoj.core.simulator.TimeOperations.getReferenceUnit());
                };
                TimeInstant.prototype.getTimeRounded$def_TimeUnit = function (unit) {
                    if (def.TimeUnit["_$wrappers"][unit].compareTo2(desmoj.core.simulator.TimeOperations.getEpsilon()) > 0) {
                        var halfAUnitInEpsilon = Math.floor(def.TimeUnit["_$wrappers"][desmoj.core.simulator.TimeOperations.getEpsilon()].convert(1, unit) / 2);
                        var durationInUnitTruncated = this.getTimeTruncated$def_TimeUnit(unit);
                        var difference = this._timeInEpsilon - def.TimeUnit["_$wrappers"][desmoj.core.simulator.TimeOperations.getEpsilon()].convert(durationInUnitTruncated, unit);
                        if (difference >= halfAUnitInEpsilon) {
                            return durationInUnitTruncated + 1;
                        }
                        return durationInUnitTruncated;
                    }
                    else {
                        return this.getTimeTruncated$def_TimeUnit(unit);
                    }
                };
                /**
                 * Returns the value of this TimeInstant object as a long type in the time
                 * unit given as a parameter. If the parameter has a coarser granularity
                 * than epsilon the returned value will be rounded, so lose precision.
                 *
                 * @param {def.TimeUnit} unit
                 * the TimeUnit
                 *
                 * @return {number} long: the time value of the TimeInstant object as a long type in
                 * the time unit given as a parameter or Long.MIN_VALUE if
                 * conversion would negatively overflow, or Long.MAX_VALUE if it
                 * would positively overflow.
                 */
                TimeInstant.prototype.getTimeRounded = function (unit) {
                    if (((typeof unit === 'number') || unit === null)) {
                        return this.getTimeRounded$def_TimeUnit(unit);
                    }
                    else if (unit === undefined) {
                        return this.getTimeRounded$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                TimeInstant.prototype.getTimeRounded$ = function () {
                    return this.getTimeRounded$def_TimeUnit(desmoj.core.simulator.TimeOperations.getReferenceUnit());
                };
                /**
                 * Returns the value of this TimeInstant object as a Date object.
                 *
                 * @return {java.util.Date} Date: a Date representation of this TimeInstant
                 */
                TimeInstant.prototype.getTimeAsDate = function () {
                    return new Date(this.getTimeRounded$def_TimeUnit(def.TimeUnit.MILLISECONDS));
                };
                TimeInstant.prototype.getTimeAsDouble$def_TimeUnit = function (unit) {
                    return this._timeInEpsilon / def.TimeUnit["_$wrappers"][desmoj.core.simulator.TimeOperations.getEpsilon()].convert(1, unit);
                };
                /**
                 * Returns the value of this TimeInstant object as a double type in the time
                 * unit given as a parameter.
                 *
                 * @return {number} double: the time value of the TimeInstant object as a double type
                 * in the time unit given as a parameter
                 * @param {def.TimeUnit} unit
                 */
                TimeInstant.prototype.getTimeAsDouble = function (unit) {
                    if (((typeof unit === 'number') || unit === null)) {
                        return this.getTimeAsDouble$def_TimeUnit(unit);
                    }
                    else if (unit === undefined) {
                        return this.getTimeAsDouble$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                TimeInstant.prototype.getTimeAsDouble$ = function () {
                    return this.getTimeAsDouble$def_TimeUnit(desmoj.core.simulator.TimeOperations.getReferenceUnit());
                };
                /**
                 * The preferred time zone for printing this time instant.
                 *
                 * @return {string} TimeZone: the time zone to use for printing this TimeInstant.
                 */
                TimeInstant.prototype.getPreferredTimeZone = function () {
                    return this._preferredTimeZone;
                };
                /**
                 * Sets the preferred time zone for printing this time instant.
                 * Note that this time zone does not affect the internal representation
                 * of this TimeInstant (stored as multiple of Experiment's epsilon
                 * since the start of the epoch, i.e. January 1, 1970, 00:00:00 GMT);
                 * the preferred TimeZone just servers TimeFormatters generating a
                 * convenient output.
                 *
                 * @param {string} preferredTimeZone
                 * java.util.TimeZone : The time value of this TimeInstant in the time unit of
                 * the reference time.
                 */
                TimeInstant.prototype.setPreferredTimeZone = function (preferredTimeZone) {
                    this._preferredTimeZone = preferredTimeZone;
                };
                /**
                 * Checks if the first of two points of simulation time is before the
                 * second. Before means, that the time value of TimeInstant a is smaller and
                 * hence "earlier" than TimeInstant b. Note that this is a static method
                 * available through calling the class <code>TimeInstant</code> i.e.
                 * <code>TimeInstant.isAfter(a,b)</code> where a and b are valid TimeInstant
                 * objects.
                 *
                 * @return {boolean} boolean : True if a is before (earlier) than b
                 * @param {desmoj.core.simulator.TimeInstant} a
                 * TimeInstant : first comparand
                 * @param {desmoj.core.simulator.TimeInstant} b
                 * TimeInstant : second comparand
                 */
                TimeInstant.isBefore = function (a, b) {
                    return (a._timeInEpsilon < b._timeInEpsilon);
                };
                /**
                 * Checks if the first of two points of simulation time is after the second.
                 * After means, that the time value of TimeInstant a is larger and hence
                 * "later" than TimeInstant b. Note that this is a static method available
                 * through calling the class <code>TimeInstant</code> i.e.
                 * <code>TimeInstant.isAfter(a,b)</code> where a and b are valid TimeInstant
                 * objects.
                 *
                 * @return {boolean} boolean : True if a is after (later) than b
                 * @param {desmoj.core.simulator.TimeInstant} a
                 * TimeInstant : first comparand
                 * @param {desmoj.core.simulator.TimeInstant} b
                 * TimeInstant : second comparand
                 */
                TimeInstant.isAfter = function (a, b) {
                    return (a._timeInEpsilon > b._timeInEpsilon);
                };
                /**
                 * Checks if the first of two points of simulation time is after the second
                 * or equal to the second. After means, that the time value of TimeInstant a
                 * is larger and hence after TimeInstant b. Equal means, that they both
                 * describe the same point in simulation time. Note that this is a static
                 * method available through calling the class <code>TimeInstant</code> i.e.
                 * <code>TimeInstant.isAfterOrEqual(a,b)</code> where a and b are valid
                 * timeInstant objects.
                 *
                 * @return {boolean} boolean : True if a is after (later than )b or equal to b
                 *
                 * @param {desmoj.core.simulator.TimeInstant} a
                 * TimeInstant : first comparand
                 * @param {desmoj.core.simulator.TimeInstant} b
                 * TimeInstant : second comparand
                 */
                TimeInstant.isAfterOrEqual = function (a, b) {
                    return (TimeInstant.isAfter(a, b) || TimeInstant.isEqual(a, b));
                };
                /**
                 * Checks if the two TimeInstant parameters describe the same point of
                 * simulation time. Note that this is a static method available through
                 * calling the class <code>TimeInstant</code> i.e.
                 * <code>TimeInstant.isEqual(a,b)</code> where a and b are valid TimeInstant
                 * objects.
                 *
                 * @return {boolean} boolean : True if both parameters describe same point of
                 * simulation time
                 * @param {desmoj.core.simulator.TimeInstant} a
                 * TimeInstant : first comparand
                 * @param {desmoj.core.simulator.TimeInstant} b
                 * TimeInstant : second comparand
                 */
                TimeInstant.isEqual = function (a, b) {
                    return (a._timeInEpsilon === b._timeInEpsilon);
                };
                /**
                 * Checks if the first of two points of simulation time is before the second
                 * or equal to the second. Before means, that the time value of TimeInstant
                 * a is smaller and hence before TimeInstant b. Equal means, that they both
                 * describe the same point in simulation time. Note that this is a static
                 * method available through calling the class <code>TimeInstant</code> i.e.
                 * <code>TimeInstant.isBeforeOrEqual(a,b)</code> where a and b are valid
                 * timeInstant objects.
                 *
                 * @return {boolean} boolean : True if a is before (earlier than )b or equal to b
                 *
                 * @param {desmoj.core.simulator.TimeInstant} a
                 * TimeInstant : first comparand
                 * @param {desmoj.core.simulator.TimeInstant} b
                 * TimeInstant : second comparand
                 */
                TimeInstant.isBeforeOrEqual = function (a, b) {
                    return (TimeInstant.isBefore(a, b) || TimeInstant.isEqual(a, b));
                };
                /**
                 * Determines that last instant prior to this instant at which
                 * a new period of the unit provided "begins", which means smaller
                 * units are zero. <br/>
                 * Examples: Assume this TimeInstant is 28.12.2011 11:23:45:678. <br\>
                 * Calling <code>getBeginOf(TimeUnit.TimeUnit.DAYS)</code> yields
                 * 28.12.2011 00:00:00:000 (begin of current hour).<br\>
                 * Calling <code>getBeginOf(TimeUnit.TimeUnit.MINUTES)</code> yields
                 * 28.12.2011 11:23:00:000 (begin of current day).<br\>
                 * Note that days are interpreted with respect to this instant's
                 * preferred time zone.
                 *
                 * @param {def.TimeUnit} smallestUnit
                 * TimeUnit : the unit to begin (i.e. smaller units set to zero);
                 * must be TimeUnit.DAYS, TimeUnit.HOURS, TimeUnit.MINUTES, TimeUnit.SECONDS or TimeUnit.MILLISECONDS.
                 *
                 * @return {desmoj.core.simulator.TimeInstant} TimeInstant: The TimeInstant at which the day/hour/minute/second/millisecond
                 * of the this TimeInstant has begun.
                 */
                TimeInstant.prototype.getBeginOf = function (smallestUnit) {
                    var date = new Date(this.getTimeRounded$def_TimeUnit(def.TimeUnit.MILLISECONDS));
                    switch ((smallestUnit)) {
                        case def.TimeUnit.DAYS:
                            date.setHours(0);
                            ;
                        case def.TimeUnit.HOURS:
                            date.setMinutes(0);
                        case def.TimeUnit.MINUTES:
                            date.setSeconds(0);
                        case def.TimeUnit.SECONDS:
                            date.setMilliseconds(0);
                        case def.TimeUnit.MILLISECONDS:
                        default:
                    }
                    return new TimeInstant(date.getTime(), def.TimeUnit.MILLISECONDS);
                };
                /**
                 * Returns a hash code value for the object. This method overrides
                 * java.lang.Object.hashCode() to support efficient treatment in
                 * HashMaps.
                 *
                 * @return: int: A hash code value for this TimeInstant.
                 * @return {number}
                 */
                TimeInstant.prototype.hashCode = function () {
                    return ((this._timeInEpsilon ^ (this._timeInEpsilon >>> 32)) | 0);
                };
                /**
                 * Indicates whether this TimeInstant is equal to the given parameter.
                 * Returns true if the obj argument is a TimeInstant and represents the same
                 * point of time as this TimeInstant; false otherwise. This method overrides
                 * java.lang.Object.equals()
                 *
                 * @param {*} o the reference object with which to compare.
                 * @return: true if the obj argument is a TimeInstant and represents the
                 * same point of time as this TimeInstant; false otherwise.
                 * @return {boolean}
                 */
                TimeInstant.prototype.equals = function (o) {
                    if (!(o != null && o instanceof desmoj.core.simulator.TimeInstant))
                        return false;
                    var instant = o;
                    return TimeInstant.isEqual(this, instant);
                };
                /**
                 * Compares the given TimeInstant to this TimeInstant. This method
                 * implements the Comparable<TimeInstant> Interface
                 *
                 * @param {desmoj.core.simulator.TimeInstant} anotherInstant : The TimeInstant to be compared to this TimeInstant
                 *
                 * @return: int: Returns a negative integer, zero, or a positive integer as
                 * this TimeInstant is before, at the same time, or after the given
                 * TimeInstant.
                 * @return {number}
                 */
                TimeInstant.prototype.compareTo = function (anotherInstant) {
                    return (this.getTimeInEpsilon() - anotherInstant.getTimeInEpsilon());
                };
                TimeInstant.prototype.toString$ = function () {
                    return desmoj.core.simulator.TimeOperations.formatTimeInstant(this);
                };
                TimeInstant.prototype.toString$int = function (digits) {
                    var result = desmoj.core.simulator.TimeOperations.formatTimeInstant(this);
                    if (result.lastIndexOf(".") >= 0) {
                        result = result.substring(0, Math.max(result.length - 1, result.lastIndexOf(".") + digits));
                    }
                    return result;
                };
                /**
                 * Returns the String Representation of this TimeInstant according to the
                 * TimeFormatter, truncating digits after the decimal point if necessary.
                 *
                 * @param {number} digits Maximum number of digits after decimal point
                 *
                 * @see java.lang.Object#toString()
                 * @see desmoj.core.simulator.TimeFormatter
                 * @return {string}
                 */
                TimeInstant.prototype.toString = function (digits) {
                    if (((typeof digits === 'number') || digits === null)) {
                        return this.toString$int(digits);
                    }
                    else if (digits === undefined) {
                        return this.toString$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                return TimeInstant;
            }());
            simulator.TimeInstant = TimeInstant;
            TimeInstant["__class"] = "desmoj.core.simulator.TimeInstant";
            TimeInstant["__interfaces"] = ["java.lang.Comparable"];
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Constructs a TimeSpan object with the given time value in the time unit
             * of the given parameter. It represents a time span in simulation time.
             * Note that trying to create a TimeSpan object with a negative value will
             * stop the simulation immediately. The simulation will also stop
             * immediately if the TimeSpan is larger than Long.MAX_VALUE-1 (in the unit
             * of epsilon).
             *
             * @param {number} duration
             * long : The time value of this TimeSpan
             * @param {def.TimeUnit} unit
             * TimeUnit: the TimeUnit
             * @class
             * @author Felix Klueckmann
             */
            var TimeSpan = (function () {
                function TimeSpan(duration, unit) {
                    var _this = this;
                    if (((typeof duration === 'number') || duration === null) && ((typeof unit === 'number') || unit === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        this._durationInEpsilon = 0;
                        this._durationInEpsilon = 0;
                        (function () {
                            if (unit == null) {
                                throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t create TimeSpan object! Simulation aborted.", "Class : TimeSpan  Constructor : TimeSpan(long, TimeUnit)", "Time unit passed is null", "Make sure to pass a non-null time unit. \nNote that before connecting model and experiment, TimeSpans must explicitly\nrefer to a time unit as the reference unit is not yet defined,e.g. use \nTimeSpan(long time, TimeUnit unit) instead ofTimeInstant(long time).", null)));
                            }
                            if (duration < 0) {
                                throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t create TimeSpan object! Simulation aborted.", "Class : TimeSpan  Constructor : TimeSpan(long, TimeUnit)", "the value passed for instantiation is negative : " + duration, "Negative values for simulation time are illegal.", null)));
                            }
                            _this._durationInEpsilon = def.TimeUnit["_$wrappers"][desmoj.core.simulator.TimeOperations.getEpsilon()].convert(duration, unit);
                            desmoj.core.simulator.TimeOperations.timeObjectsCreated = true;
                            if (_this._durationInEpsilon === Number.MAX_VALUE) {
                                throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t create TimeSpan object! Simulation aborted.", "Class : TimeSpan  Constructor : TimeSpan(long,TimeUnit)", "the TimeSpan is too big. ", "Can only create TimeSpan objects which are smaller than Long.MAX_VALUE (in the TimeUnit of epsilon).", null)));
                            }
                        })();
                    }
                    else if (((typeof duration === 'number') || duration === null) && ((typeof unit === 'number') || unit === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        this._durationInEpsilon = 0;
                        this._durationInEpsilon = 0;
                        (function () {
                            if (unit == null) {
                                throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t create TimeSpan object! Simulation aborted.", "Class : TimeSpan  Constructor : TimeSpan(double, TimeUnit)", "Time unit passed is null", "Make sure to pass a non-null time unit. \nNote that before connecting model and experiment, TimeSpans must explicitly\nrefer to a time unit as the reference unit is not yet defined,e.g. use \nTimeSpan(double time, TimeUnit unit) instead ofTimeInstant(double time).", null)));
                            }
                            _this._durationInEpsilon = Math.floor((duration * def.TimeUnit["_$wrappers"][desmoj.core.simulator.TimeOperations.getEpsilon()].convert(1, unit)));
                            desmoj.core.simulator.TimeOperations.timeObjectsCreated = true;
                            if (_this._durationInEpsilon < 0) {
                                throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t create TimeSpan object! Simulation aborted.", "Class : TimeSpan  Constructor : TimeSpan(long, TimeUnit)", "the value passed for instantiation is negative : " + _this._durationInEpsilon, "Negative values for simulation time are illegal.", null)));
                            }
                            if (_this._durationInEpsilon === Number.MAX_VALUE) {
                                throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t create TimeSpan object! Simulation aborted.", "Class : TimeSpan  Constructor : TimeSpan(long,TimeUnit)", "the TimeSpan is too big. ", "Can only create TimeSpan objects which are smaller than Long.MAX_VALUE (in the TimeUnit of epsilon).", null)));
                            }
                        })();
                    }
                    else if (((duration != null && duration instanceof desmoj.core.simulator.TimeSpan.Builder) || duration === null) && unit === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        var builder_1 = __args[0];
                        this._durationInEpsilon = 0;
                        this._durationInEpsilon = 0;
                        (function () {
                            _this._durationInEpsilon = builder_1.durationInEpsilon;
                        })();
                    }
                    else if (((typeof duration === 'number') || duration === null) && unit === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        {
                            var __args_8 = Array.prototype.slice.call(arguments);
                            var unit_8 = desmoj.core.simulator.TimeOperations.getReferenceUnit();
                            this._durationInEpsilon = 0;
                            this._durationInEpsilon = 0;
                            (function () {
                                if (unit_8 == null) {
                                    throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t create TimeSpan object! Simulation aborted.", "Class : TimeSpan  Constructor : TimeSpan(long, TimeUnit)", "Time unit passed is null", "Make sure to pass a non-null time unit. \nNote that before connecting model and experiment, TimeSpans must explicitly\nrefer to a time unit as the reference unit is not yet defined,e.g. use \nTimeSpan(long time, TimeUnit unit) instead ofTimeInstant(long time).", null)));
                                }
                                if (duration < 0) {
                                    throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t create TimeSpan object! Simulation aborted.", "Class : TimeSpan  Constructor : TimeSpan(long, TimeUnit)", "the value passed for instantiation is negative : " + duration, "Negative values for simulation time are illegal.", null)));
                                }
                                _this._durationInEpsilon = def.TimeUnit["_$wrappers"][desmoj.core.simulator.TimeOperations.getEpsilon()].convert(duration, unit_8);
                                desmoj.core.simulator.TimeOperations.timeObjectsCreated = true;
                                if (_this._durationInEpsilon === Number.MAX_VALUE) {
                                    throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t create TimeSpan object! Simulation aborted.", "Class : TimeSpan  Constructor : TimeSpan(long,TimeUnit)", "the TimeSpan is too big. ", "Can only create TimeSpan objects which are smaller than Long.MAX_VALUE (in the TimeUnit of epsilon).", null)));
                                }
                            })();
                        }
                    }
                    else if (((typeof duration === 'number') || duration === null) && unit === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        {
                            var __args_9 = Array.prototype.slice.call(arguments);
                            var unit_9 = desmoj.core.simulator.TimeOperations.getReferenceUnit();
                            this._durationInEpsilon = 0;
                            this._durationInEpsilon = 0;
                            (function () {
                                if (unit_9 == null) {
                                    throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t create TimeSpan object! Simulation aborted.", "Class : TimeSpan  Constructor : TimeSpan(double, TimeUnit)", "Time unit passed is null", "Make sure to pass a non-null time unit. \nNote that before connecting model and experiment, TimeSpans must explicitly\nrefer to a time unit as the reference unit is not yet defined,e.g. use \nTimeSpan(double time, TimeUnit unit) instead ofTimeInstant(double time).", null)));
                                }
                                _this._durationInEpsilon = Math.floor((duration * def.TimeUnit["_$wrappers"][desmoj.core.simulator.TimeOperations.getEpsilon()].convert(1, unit_9)));
                                desmoj.core.simulator.TimeOperations.timeObjectsCreated = true;
                                if (_this._durationInEpsilon < 0) {
                                    throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t create TimeSpan object! Simulation aborted.", "Class : TimeSpan  Constructor : TimeSpan(long, TimeUnit)", "the value passed for instantiation is negative : " + _this._durationInEpsilon, "Negative values for simulation time are illegal.", null)));
                                }
                                if (_this._durationInEpsilon === Number.MAX_VALUE) {
                                    throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t create TimeSpan object! Simulation aborted.", "Class : TimeSpan  Constructor : TimeSpan(long,TimeUnit)", "the TimeSpan is too big. ", "Can only create TimeSpan objects which are smaller than Long.MAX_VALUE (in the TimeUnit of epsilon).", null)));
                                }
                            })();
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * Returns the value of the TimeSpan object as a long type in the time unit
                 * of epsilon
                 *
                 * @return {number} long: the time value of the TimeSpan object as a long type in the
                 * time unit of epsilon
                 */
                TimeSpan.prototype.getTimeInEpsilon = function () {
                    return this._durationInEpsilon;
                };
                TimeSpan.prototype.getTimeTruncated$def_TimeUnit = function (unit) {
                    return def.TimeUnit["_$wrappers"][unit].convert(this._durationInEpsilon, desmoj.core.simulator.TimeOperations.getEpsilon());
                };
                /**
                 * Returns the value of this TimeSpan object as a long type in the time unit
                 * given as a parameter. If the parameter has a coarser granularity than
                 * epsilon the returned value will be truncated, so lose precision.
                 *
                 * @param {def.TimeUnit} unit
                 * : the TimeUnit
                 *
                 * @return {number} long: the time value of the TimeSpan object as a long type in the
                 * time unit given as a parameter or Long.MIN_VALUE if conversion
                 * would negatively overflow, or Long.MAX_VALUE if it would
                 * positively overflow.
                 */
                TimeSpan.prototype.getTimeTruncated = function (unit) {
                    if (((typeof unit === 'number') || unit === null)) {
                        return this.getTimeTruncated$def_TimeUnit(unit);
                    }
                    else if (unit === undefined) {
                        return this.getTimeTruncated$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                TimeSpan.prototype.getTimeTruncated$ = function () {
                    return this.getTimeTruncated$def_TimeUnit(desmoj.core.simulator.TimeOperations.getReferenceUnit());
                };
                TimeSpan.prototype.getTimeRounded$def_TimeUnit = function (unit) {
                    if (def.TimeUnit["_$wrappers"][unit].compareTo2(desmoj.core.simulator.TimeOperations.getEpsilon()) > 0) {
                        var halfAUnitInEpsilon = Math.floor(def.TimeUnit["_$wrappers"][desmoj.core.simulator.TimeOperations.getEpsilon()].convert(1, unit) / 2);
                        var durationInUnitTruncated = this.getTimeTruncated$def_TimeUnit(unit);
                        var difference = this._durationInEpsilon - def.TimeUnit["_$wrappers"][desmoj.core.simulator.TimeOperations.getEpsilon()].convert(durationInUnitTruncated, unit);
                        if (difference >= halfAUnitInEpsilon) {
                            return durationInUnitTruncated + 1;
                        }
                        return durationInUnitTruncated;
                    }
                    else {
                        return this.getTimeTruncated$def_TimeUnit(unit);
                    }
                };
                /**
                 * Returns the value of this TimeSpan object as a long type in the time unit
                 * given as a parameter. If the parameter has a coarser granularity than
                 * epsilon the returned value will be rounded, so lose precision.
                 *
                 * @param {def.TimeUnit} unit
                 * : the TimeUnit
                 *
                 * @return {number} long: the time value of the TimeSpan object as a long type in the
                 * time unit given as a parameter or Long.MIN_VALUE if conversion
                 * would negatively overflow, or Long.MAX_VALUE if it would
                 * positively overflow.
                 */
                TimeSpan.prototype.getTimeRounded = function (unit) {
                    if (((typeof unit === 'number') || unit === null)) {
                        return this.getTimeRounded$def_TimeUnit(unit);
                    }
                    else if (unit === undefined) {
                        return this.getTimeRounded$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                TimeSpan.prototype.getTimeRounded$ = function () {
                    return this.getTimeRounded$def_TimeUnit(desmoj.core.simulator.TimeOperations.getReferenceUnit());
                };
                TimeSpan.prototype.getTimeAsDouble$def_TimeUnit = function (unit) {
                    return this._durationInEpsilon / def.TimeUnit["_$wrappers"][desmoj.core.simulator.TimeOperations.getEpsilon()].convert(1, unit);
                };
                /**
                 * Returns the value of this TimeSpan object as a double type in the time unit
                 * given as a parameter.
                 *
                 * @return {number} double: the time value of the TimeSpan object as a double type in the
                 * time unit given as a parameter
                 * @param {def.TimeUnit} unit
                 */
                TimeSpan.prototype.getTimeAsDouble = function (unit) {
                    if (((typeof unit === 'number') || unit === null)) {
                        return this.getTimeAsDouble$def_TimeUnit(unit);
                    }
                    else if (unit === undefined) {
                        return this.getTimeAsDouble$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                TimeSpan.prototype.getTimeAsDouble$ = function () {
                    return this.getTimeAsDouble$def_TimeUnit(desmoj.core.simulator.TimeOperations.getReferenceUnit());
                };
                /**
                 * Checks if the first of two spans of simulation time is longer than the
                 * second. Note that this is a static method available through calling the
                 * class <code>TimeSpan</code> i.e. <code>TimeSpan.isLonger(a,b)</code>
                 * where a and b are valid TimeSpan objects.
                 *
                 * @return {boolean} boolean : True if a is longer than b
                 * @param {desmoj.core.simulator.TimeSpan} a
                 * TimeSpan : first comparand
                 * @param {desmoj.core.simulator.TimeSpan} b
                 * TimeSpan : second comparand
                 */
                TimeSpan.isLonger = function (a, b) {
                    return (a._durationInEpsilon > b._durationInEpsilon);
                };
                /**
                 * Checks if the first of two spans of simulation time is longer than the
                 * second or equal to the second. Note that this is a static method
                 * available through calling the class <code>TimeSpan</code> i.e.
                 * <code>TimeSpan.isLonger(a,b)</code> where a and b are valid TimeSpan
                 * objects.
                 *
                 * @return {boolean} boolean : True if a is longer than b or equal to b.
                 * @param {desmoj.core.simulator.TimeSpan} a
                 * TimeSpan : first comparand
                 * @param {desmoj.core.simulator.TimeSpan} b
                 * TimeSpan : second comparand
                 */
                TimeSpan.isLongerOrEqual = function (a, b) {
                    return (TimeSpan.isLonger(a, b) || TimeSpan.isEqual(a, b));
                };
                /**
                 * Checks if the first of two spans of simulation time is shorter than the
                 * second. Note that this is a static method available through calling the
                 * class <code>TimeSpan</code> i.e. <code>TimeSpan.isShorter(a,b)</code>
                 * where a and b are valid TimeSpan objects.
                 *
                 * @return {boolean} boolean : True if a is shorter than b
                 * @param {desmoj.core.simulator.TimeSpan} a
                 * TimeSpan : first comparand
                 * @param {desmoj.core.simulator.TimeSpan} b
                 * TimeSpan : second comparand
                 */
                TimeSpan.isShorter = function (a, b) {
                    return (a._durationInEpsilon < b._durationInEpsilon);
                };
                /**
                 * Checks if the first of two spans of simulation time is shorter than the
                 * second or equal to the second. Note that this is a static method
                 * available through calling the class <code>TimeSpan</code> i.e.
                 * <code>TimeSpan.isShorterOrEqual(a,b)</code> where a and b are valid
                 * TimeSpan objects.
                 *
                 * @return {boolean} boolean : True if a is shorter than b or equal to b.
                 * @param {desmoj.core.simulator.TimeSpan} a
                 * TimeSpan : first comparand
                 * @param {desmoj.core.simulator.TimeSpan} b
                 * TimeSpan : second comparand
                 */
                TimeSpan.isShorterOrEqual = function (a, b) {
                    return (TimeSpan.isShorter(a, b) || TimeSpan.isEqual(a, b));
                };
                /**
                 * Indicates whether TimeSpan a is equal to TimeSpan b, i.e. they are of
                 * equal length.
                 *
                 * @param {desmoj.core.simulator.TimeSpan} a TimeSpan: first comparand
                 * @param {desmoj.core.simulator.TimeSpan} b TimeSpan: second comparand
                 * @return {boolean} true if a is equal to b; false otherwise.
                 */
                TimeSpan.isEqual = function (a, b) {
                    return (a._durationInEpsilon === b._durationInEpsilon);
                };
                /**
                 * Indicates whether this TimeSpan is equal to the given parameter. Returns
                 * true if the obj argument is a TimeSpan and is of equal length as this
                 * TimeSpan; false otherwise. This method overrides
                 * java.lang.Object.equals()
                 *
                 * @param {*} obj the reference object with which to compare.
                 * @return {boolean} true if the obj argument is a TimeSpan and is of equal length as
                 * this TimeSpan; false otherwise.
                 */
                TimeSpan.prototype.equals = function (obj) {
                    if (!(obj != null && obj instanceof desmoj.core.simulator.TimeSpan))
                        return false;
                    var span = obj;
                    return TimeSpan.isEqual(this, span);
                };
                /**
                 * Indicates whether this TimeSpan is equal to 0.
                 *
                 * @return {boolean} true if this TimeSpan has a length of 0; false otherwise.
                 */
                TimeSpan.prototype.isZero = function () {
                    return this._durationInEpsilon === 0;
                };
                /**
                 * Returns a hash code value for the object. This methode overides
                 * java.lang.Object.hashCode().The method is supported for the benefit of
                 * hashtables such as those provided by java.util.Hashtable.
                 *
                 * @return {number} int: a hash code value for this TimeSpan.
                 */
                TimeSpan.prototype.hashCode = function () {
                    return ((this._durationInEpsilon ^ (this._durationInEpsilon >>> 32)) | 0);
                };
                /**
                 * Compares the given TimeSpan to this TimeSpan. This method implements the
                 * Comparable<TimeSpan> Interface
                 *
                 * @param {desmoj.core.simulator.TimeSpan} anotherTimeSpan The TimeSpan to be compared to this TimeSpan
                 *
                 * @return {number} int: Returns a negative integer, zero, or a positive integer as
                 * this TimeSpan is shorter than, equal to, or longer than the
                 * given parameter.
                 */
                TimeSpan.prototype.compareTo = function (anotherTimeSpan) {
                    var difference = this.getTimeInEpsilon() - anotherTimeSpan.getTimeInEpsilon();
                    if (difference < 0)
                        return -1;
                    if (difference > 0)
                        return 1;
                    return 0;
                };
                TimeSpan.prototype.toString$ = function () {
                    return desmoj.core.simulator.TimeOperations.formatTimeSpan(this);
                };
                TimeSpan.prototype.toString$int = function (digits) {
                    var result = desmoj.core.simulator.TimeOperations.formatTimeSpan(this);
                    if (result.lastIndexOf(".") >= 0) {
                        result = result.substring(0, Math.max(result.length - 1, result.lastIndexOf(".") + digits));
                    }
                    return result;
                };
                /**
                 * Returns the String Representation of this TimeSpan according to the
                 * TimeFormatter, truncating digits after the decimal point if necessary.
                 *
                 * @param {number} digits Maximum number of digits after decimal point
                 *
                 * @see java.lang.Object#toString()
                 * @see desmoj.core.simulator.TimeFormatter
                 * @return {string}
                 */
                TimeSpan.prototype.toString = function (digits) {
                    if (((typeof digits === 'number') || digits === null)) {
                        return this.toString$int(digits);
                    }
                    else if (digits === undefined) {
                        return this.toString$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                return TimeSpan;
            }());
            simulator.TimeSpan = TimeSpan;
            TimeSpan["__class"] = "desmoj.core.simulator.TimeSpan";
            TimeSpan["__interfaces"] = ["java.lang.Comparable"];
            (function (TimeSpan) {
                /**
                 * Use the Builder to create TimeSpans specified as the sum of durations
                 * with different TimeUnits Example (timeSpan with the length of one hour
                 * and 30 minutes): new TimeSpan.Builder().hours(1).minutes(30).build();
                 *
                 * @class
                 */
                var Builder = (function () {
                    function Builder() {
                        this.durationInEpsilon = 0;
                        this.durationInEpsilon = 0;
                    }
                    Builder.prototype.nanoseconds = function (nanoseconds) {
                        if (nanoseconds < 0) {
                            throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t set the value of nanoseconds of the Builder for TimeSpan object! Simulation aborted.", "Class : TimeSpan  Builder : Builder.nanoseconds(long)", "the value passed for the setting of nanoseconds is negative : " + nanoseconds, "Negative values for simulation time are illegal.", null)));
                        }
                        this.durationInEpsilon += def.TimeUnit["_$wrappers"][desmoj.core.simulator.TimeOperations.getEpsilon()].convert(nanoseconds, def.TimeUnit.NANOSECONDS);
                        return this;
                    };
                    Builder.prototype.microseconds = function (microseconds) {
                        if (microseconds < 0) {
                            throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t set the value of microseconds of the Builder for TimeSpan object! Simulation aborted.", "Class : TimeSpan  Builder : Builder.microseconds(long)", "the value passed for the setting of microseconds is negative : " + microseconds, "Negative values for simulation time are illegal.", null)));
                        }
                        this.durationInEpsilon += def.TimeUnit["_$wrappers"][desmoj.core.simulator.TimeOperations.getEpsilon()].convert(microseconds, def.TimeUnit.MICROSECONDS);
                        return this;
                    };
                    Builder.prototype.milliseconds = function (milliseconds) {
                        if (milliseconds < 0) {
                            throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t set the value of milliseconds of the Builder for TimeSpan object! Simulation aborted.", "Class : TimeSpan  Builder : Builder.milliseconds(long)", "the value passed for the setting of milliseconds is negative : " + milliseconds, "Negative values for simulation time are illegal.", null)));
                        }
                        this.durationInEpsilon += def.TimeUnit["_$wrappers"][desmoj.core.simulator.TimeOperations.getEpsilon()].convert(milliseconds, def.TimeUnit.MILLISECONDS);
                        return this;
                    };
                    Builder.prototype.seconds = function (seconds) {
                        if (seconds < 0) {
                            throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t set the value of seconds of the Builder for TimeSpan object! Simulation aborted.", "Class : TimeSpan  Builder : Builder.seconds(long)", "the value passed for the setting of seconds is negative : " + seconds, "Negative values for simulation time are illegal.", null)));
                        }
                        this.durationInEpsilon += def.TimeUnit["_$wrappers"][desmoj.core.simulator.TimeOperations.getEpsilon()].convert(seconds, def.TimeUnit.SECONDS);
                        return this;
                    };
                    Builder.prototype.minutes = function (minutes) {
                        if (minutes < 0) {
                            throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t set the value of minutes of the Builder for TimeSpan object! Simulation aborted.", "Class : TimeSpan  Builder : Builder.minutes(long)", "the value passed for the setting of minutes is negative : " + minutes, "Negative values for simulation time are illegal.", null)));
                        }
                        this.durationInEpsilon += def.TimeUnit["_$wrappers"][desmoj.core.simulator.TimeOperations.getEpsilon()].convert(minutes, def.TimeUnit.MINUTES);
                        return this;
                    };
                    Builder.prototype.hours = function (hours) {
                        if (hours < 0) {
                            throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t set the value of hours of the Builder for TimeSpan object! Simulation aborted.", "Class : TimeSpan  Builder : Builder.hours(long)", "the value passed for the setting of hours is negative : " + hours, "Negative values for simulation time are illegal.", null)));
                        }
                        this.durationInEpsilon += def.TimeUnit["_$wrappers"][desmoj.core.simulator.TimeOperations.getEpsilon()].convert(hours, def.TimeUnit.HOURS);
                        return this;
                    };
                    Builder.prototype.days = function (days) {
                        if (days < 0) {
                            throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t set the value of days of the Builder for TimeSpan object! Simulation aborted.", "Class : TimeSpan  Builder : Builder.days(long)", "the value passed for the setting of days is negative : " + days, "Negative values for simulation time are illegal.", null)));
                        }
                        this.durationInEpsilon += def.TimeUnit["_$wrappers"][desmoj.core.simulator.TimeOperations.getEpsilon()].convert(days, def.TimeUnit.DAYS);
                        return this;
                    };
                    /**
                     * Use this method to create TimeSpan objects with the builder pattern.
                     *
                     * @return {desmoj.core.simulator.TimeSpan}
                     */
                    Builder.prototype.build = function () {
                        return new desmoj.core.simulator.TimeSpan(this);
                    };
                    return Builder;
                }());
                TimeSpan.Builder = Builder;
                Builder["__class"] = "desmoj.core.simulator.TimeSpan.Builder";
            })(TimeSpan = simulator.TimeSpan || (simulator.TimeSpan = {}));
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Constructs a simulation clock with no parameters given. By default the
             * actual simulation time is set to zero.
             *
             * @author Tim Lechler
             * @author modified by Felix Klueckmann
             * @param {string} name
             * String : The name of the simulation clock
             * @class
             * @extends def.Observable
             * @author Tim Lechler
             */
            var SimClock = (function (_super) {
                __extends(SimClock, _super);
                function SimClock(name) {
                    var _this = _super.call(this) || this;
                    _this.name = null;
                    _this._timeNow = null;
                    _this.name = name + "_clock";
                    _this._timeNow = new desmoj.core.simulator.TimeInstant(0);
                    return _this;
                }
                /**
                 * Returns the clock's name as string. This method has become necessary
                 * since the simulation clock does not extend class
                 * <code>NamedObjectImp</code>.
                 *
                 * @return {string} java.lang.String : The clock's name
                 */
                SimClock.prototype.getName = function () {
                    return this.name;
                };
                /**
                 * Returns the actual simulation time.
                 *
                 * @return {desmoj.core.simulator.TimeInstant} TimeInstant : The actual simulation time
                 */
                SimClock.prototype.getTime = function () {
                    return this._timeNow;
                };
                /**
                 * Sets the actual simulation time to a new value. This method has to be
                 * protected from user access since it must not be manipulated by anyone but
                 * the scheduler.
                 *
                 * @param {desmoj.core.simulator.TimeInstant} newTime
                 * TimeInstant : The new simulation time
                 */
                SimClock.prototype.setTime = function (newTime) {
                    if (desmoj.core.simulator.TimeInstant.isBeforeOrEqual(newTime, this._timeNow)) {
                        if (desmoj.core.simulator.TimeInstant.isBefore(newTime, this._timeNow)) {
                        }
                        return;
                    }
                    this.setChanged();
                    this.notifyObserversWithArgument(this._timeNow);
                    this._timeNow = newTime;
                };
                /**
                 * Sets the initial simulation time, overriding potential previous calls
                 * to this method. Allows negative values. This method has to be protected
                 * from user access since it must not be manipulated by anyone but the scheduler.
                 *
                 * @param {desmoj.core.simulator.TimeInstant} initTime
                 * TimeInstant : The initial simulation time
                 */
                SimClock.prototype.setInitTime = function (initTime) {
                    this._timeNow = initTime;
                };
                /**
                 * Returns the clock's name as string. This method has become necessary
                 * since the simulation clock does not extend class
                 * <code>NamedObjectImp</code>.
                 *
                 * @return {string} java.lang.String : The clock's name
                 */
                SimClock.prototype.toString = function () {
                    return this.name;
                };
                return SimClock;
            }(def.Observable));
            simulator.SimClock = SimClock;
            SimClock["__class"] = "desmoj.core.simulator.SimClock";
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * TimeOperations is an utility class that provides arithmetic operations for
             * the time classes TimeInstant and TimeSpan. It also holds the time settings,
             * i.e. the granularity (epsilon) and the reference time unit.
             *
             * @version DESMO-J, Ver. 2.5.1e copyright (c) 2017
             * @author Felix Klueckmann
             *
             * Licensed under the Apache License, Version 2.0 (the "License"); you
             * may not use this file except in compliance with the License. You may
             * obtain a copy of the License at
             * http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
             * implied. See the License for the specific language governing
             * permissions and limitations under the License.
             *
             * @class
             */
            var TimeOperations = (function () {
                function TimeOperations() {
                }
                TimeOperations.epsilon_$LI$ = function () { if (TimeOperations.epsilon == null)
                    TimeOperations.epsilon = def.TimeUnit.MICROSECONDS; return TimeOperations.epsilon; };
                ;
                TimeOperations.referenceUnit_$LI$ = function () { if (TimeOperations.referenceUnit == null)
                    TimeOperations.referenceUnit = def.TimeUnit.SECONDS; return TimeOperations.referenceUnit; };
                ;
                TimeOperations.myTimeFormatter_$LI$ = function () { if (TimeOperations.myTimeFormatter == null)
                    TimeOperations.myTimeFormatter = TimeOperations.getDefaultTimeFormatter(); return TimeOperations.myTimeFormatter; };
                ;
                TimeOperations.add$desmoj_core_simulator_TimeSpan$desmoj_core_simulator_TimeSpan = function (a, b) {
                    if (Number.MAX_VALUE - a.getTimeInEpsilon() - b.getTimeInEpsilon() < 1) {
                        throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t add TimeSpan objects! Simulation aborted.", "Class : TimeOperations  Methode : add(TimeSpan a, TimeSpan b)", "the resulting sum is too big. ", "Can only create TimeSpan objects which are smaller than Long.MAX_VALUE (in the TimeUnit of epsilon).", null)));
                    }
                    return new desmoj.core.simulator.TimeSpan(a.getTimeInEpsilon() + b.getTimeInEpsilon(), TimeOperations.epsilon_$LI$());
                };
                /**
                 * Returns a new TimeSpan object representing the sum of the given TimeSpan
                 * objects. Note that the simulation will stop immediately if the resulting
                 * sum is larger than Long.MAX_VALUE-1 (in the unit of epsilon).
                 *
                 * @return {desmoj.core.simulator.TimeSpan} TimeSpan : A new TimeSpan as the sum of the TimeSpan parameters
                 * @param {desmoj.core.simulator.TimeSpan} a
                 * TimeSpan : TimeSpan a
                 * @param {desmoj.core.simulator.TimeSpan} b
                 * TimeSpan : TimeSpan b
                 */
                TimeOperations.add = function (a, b) {
                    if (((a != null && a instanceof desmoj.core.simulator.TimeSpan) || a === null) && ((b != null && b instanceof desmoj.core.simulator.TimeSpan) || b === null)) {
                        return desmoj.core.simulator.TimeOperations.add$desmoj_core_simulator_TimeSpan$desmoj_core_simulator_TimeSpan(a, b);
                    }
                    else if (((a != null && a instanceof desmoj.core.simulator.TimeSpan) || a === null) && ((b != null && b instanceof desmoj.core.simulator.TimeInstant) || b === null)) {
                        return desmoj.core.simulator.TimeOperations.add$desmoj_core_simulator_TimeSpan$desmoj_core_simulator_TimeInstant(a, b);
                    }
                    else if (((a != null && a instanceof desmoj.core.simulator.TimeInstant) || a === null) && ((b != null && b instanceof desmoj.core.simulator.TimeSpan) || b === null)) {
                        return desmoj.core.simulator.TimeOperations.add$desmoj_core_simulator_TimeInstant$desmoj_core_simulator_TimeSpan(a, b);
                    }
                    else
                        throw new Error('invalid overload');
                };
                TimeOperations.add$desmoj_core_simulator_TimeSpan$desmoj_core_simulator_TimeInstant = function (span, instant) {
                    return TimeOperations.add$desmoj_core_simulator_TimeInstant$desmoj_core_simulator_TimeSpan(instant, span);
                };
                TimeOperations.add$desmoj_core_simulator_TimeInstant$desmoj_core_simulator_TimeSpan = function (instant, span) {
                    if (instant.getTimeInEpsilon() > 0) {
                        if (Number.MAX_VALUE - span.getTimeInEpsilon() - instant.getTimeInEpsilon() < 1) {
                            throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t add TimeSpan and TimeInstant objects! Simulation aborted.", "Class : TimeOperations  Methode : add(TimeSpan a, TimeInstant b)", "the resulting sum is too big. ", "Can only create TimeInstant objects which are before Long.MAX_VALUE (in the TimeUnit of epsilon).", null)));
                        }
                    }
                    var result = new desmoj.core.simulator.TimeInstant(span.getTimeInEpsilon() + instant.getTimeInEpsilon(), TimeOperations.epsilon_$LI$());
                    result.setPreferredTimeZone(instant.getPreferredTimeZone());
                    return result;
                };
                /**
                 * Returns a new Time Instant determined from the instant passed to this
                 * method minus the time span passed to method.
                 * In other words, this method determines the instant that is a given
                 * span before the instant provided.
                 * Note that the simulation will stop immediately if the resulting
                 * instant is smaller than 0 (in the unit of epsilon).
                 * The preferred time zone of the result is equal to the preferred time zone
                 * of instant passed to this method.
                 *
                 * @return {desmoj.core.simulator.TimeInstant} TimeSpan : A new TimeInstant determined from given TimeInstant minus
                 * the given TimeSpan
                 * @param {desmoj.core.simulator.TimeInstant} instant
                 * TimeInstant : The TimeInstant, from which...
                 * @param {desmoj.core.simulator.TimeSpan} span
                 * TimeSpan : ...this TimeSpan will be subtracted
                 */
                TimeOperations.subtract = function (instant, span) {
                    if (instant.getTimeInEpsilon() > 0) {
                        if (instant.getTimeInEpsilon() - span.getTimeInEpsilon() < 0) {
                            throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t subtract TimeInstant and  TimeSpan objects! Simulation aborted.", "Class : TimeOperations  Methode : subtract(TimeInstant a, TimeSpan b)", "the resulting smaller than 0.", "Can only create TimeInstant objects which are non-negative (in the TimeUnit of epsilon).", null)));
                        }
                    }
                    var result = new desmoj.core.simulator.TimeInstant(instant.getTimeInEpsilon() - span.getTimeInEpsilon(), TimeOperations.epsilon_$LI$());
                    result.setPreferredTimeZone(instant.getPreferredTimeZone());
                    return result;
                };
                TimeOperations.diff$desmoj_core_simulator_TimeSpan$desmoj_core_simulator_TimeSpan = function (a, b) {
                    if (desmoj.core.simulator.TimeSpan.isShorter(a, b)) {
                        return new desmoj.core.simulator.TimeSpan(b.getTimeInEpsilon() - a.getTimeInEpsilon(), TimeOperations.epsilon_$LI$());
                    }
                    return new desmoj.core.simulator.TimeSpan(a.getTimeInEpsilon() - b.getTimeInEpsilon(), TimeOperations.epsilon_$LI$());
                };
                /**
                 * Returns a new TimeSpan object representing the absolute difference of the
                 * given TimeSpan objects.
                 *
                 * @return {desmoj.core.simulator.TimeSpan} TimeSpan : A new TimeSpan as the absolute difference of the
                 * TimeSpan parameters
                 * @param {desmoj.core.simulator.TimeSpan} a
                 * TimeSpan : TimeSpan a
                 * @param {desmoj.core.simulator.TimeSpan} b
                 * TimeSpan : TimeSpan b
                 */
                TimeOperations.diff = function (a, b) {
                    if (((a != null && a instanceof desmoj.core.simulator.TimeSpan) || a === null) && ((b != null && b instanceof desmoj.core.simulator.TimeSpan) || b === null)) {
                        return desmoj.core.simulator.TimeOperations.diff$desmoj_core_simulator_TimeSpan$desmoj_core_simulator_TimeSpan(a, b);
                    }
                    else if (((a != null && a instanceof desmoj.core.simulator.TimeInstant) || a === null) && ((b != null && b instanceof desmoj.core.simulator.TimeInstant) || b === null)) {
                        return desmoj.core.simulator.TimeOperations.diff$desmoj_core_simulator_TimeInstant$desmoj_core_simulator_TimeInstant(a, b);
                    }
                    else
                        throw new Error('invalid overload');
                };
                TimeOperations.diff$desmoj_core_simulator_TimeInstant$desmoj_core_simulator_TimeInstant = function (a, b) {
                    if (desmoj.core.simulator.TimeInstant.isAfter(a, b)) {
                        if (b.getTimeInEpsilon() < 0) {
                            if (Number.MAX_VALUE - 1 + b.getTimeInEpsilon() < a.getTimeInEpsilon()) {
                                throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t subtract TimeInstant objects! Simulation aborted.", "Class : TimeOperations  Methode : diff(TimeSpan a, TimeInstant b)", "the resulting difference is too big. ", "Can only create TimeSpan objects which are smaller than Long.MAX_VALUE (in the TimeUnit of epsilon).", null)));
                            }
                        }
                        return new desmoj.core.simulator.TimeSpan(a.getTimeInEpsilon() - b.getTimeInEpsilon(), TimeOperations.epsilon_$LI$());
                    }
                    else {
                        if (a.getTimeInEpsilon() < 0) {
                            if (Number.MAX_VALUE + a.getTimeInEpsilon() < b.getTimeInEpsilon()) {
                                throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t subtract TimeInstant objects! Simulation aborted.", "Class : TimeOperations  Methode : diff(TimeSpan a, TimeInstant b)", "the resulting difference is too big. ", "Can only create TimeSpan objects which are smaller than Long.MAX_VALUE (in the TimeUnit of epsilon).", null)));
                            }
                        }
                        return new desmoj.core.simulator.TimeSpan(b.getTimeInEpsilon() - a.getTimeInEpsilon(), TimeOperations.epsilon_$LI$());
                    }
                };
                TimeOperations.multiply$desmoj_core_simulator_TimeSpan$double = function (span, factor) {
                    if (factor > 1) {
                        if (Number.MAX_VALUE / factor < span.getTimeInEpsilon()) {
                            throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t multiply TimeSpan and double value! Simulation aborted.", "Class : TimeOperations  Methode : multiply(TimeSpan span, double factor)", "the resulting product is too big. ", "Can only create TimeSpan objects which are shorter than Long.MAX_VALUE (in the TimeUnit of epsilon).", null)));
                        }
                    }
                    return new desmoj.core.simulator.TimeSpan(Math.floor((span.getTimeInEpsilon() * factor)), TimeOperations.epsilon_$LI$());
                };
                /**
                 * Returns a new TimeSpan object representing the product of the given
                 * TimeSpan and the factor of type double. Note that the simulation will
                 * stop immediately if the resulting product is larger than <code>Long.MAX_VALUE-1</code>
                 * (in the unit of epsilon).
                 *
                 * @return {desmoj.core.simulator.TimeSpan} TimeSpan : A new TimeSpan as the product of span and factor
                 * @param {desmoj.core.simulator.TimeSpan} span
                 * TimeSpan : The span of time
                 * @param {number} factor
                 * double : The scalar factor
                 */
                TimeOperations.multiply = function (span, factor) {
                    if (((span != null && span instanceof desmoj.core.simulator.TimeSpan) || span === null) && ((typeof factor === 'number') || factor === null)) {
                        return desmoj.core.simulator.TimeOperations.multiply$desmoj_core_simulator_TimeSpan$double(span, factor);
                    }
                    else if (((typeof span === 'number') || span === null) && ((factor != null && factor instanceof desmoj.core.simulator.TimeSpan) || factor === null)) {
                        return desmoj.core.simulator.TimeOperations.multiply$double$desmoj_core_simulator_TimeSpan(span, factor);
                    }
                    else
                        throw new Error('invalid overload');
                };
                TimeOperations.multiply$double$desmoj_core_simulator_TimeSpan = function (factor, span) {
                    return TimeOperations.multiply$desmoj_core_simulator_TimeSpan$double(span, factor);
                };
                TimeOperations.divide$desmoj_core_simulator_TimeSpan$desmoj_core_simulator_TimeSpan = function (dividend, divisor) {
                    if (divisor.getTimeInEpsilon() === 0) {
                        throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t divide TimeSpan values! Simulation aborted.", "Class : TimeOperations  Methode : divide(TimeSpan dividend, TimeSpan divisor)", "Cannot devide by zero.", "Never try to devide by zero.", null)));
                    }
                    return (dividend.getTimeInEpsilon() / divisor.getTimeInEpsilon());
                };
                /**
                 * Returns a new TimeSpan object representing the quotient of the given
                 * TimeSpan objects.
                 *
                 * @return {number} TimeSpan : A new TimeSpan as the quotient of dividend and divisor
                 * @param {desmoj.core.simulator.TimeSpan} dividend
                 * TimeSpan : The dividend
                 * @param {desmoj.core.simulator.TimeSpan} divisor
                 * TimeSpan : The divisor
                 */
                TimeOperations.divide = function (dividend, divisor) {
                    if (((dividend != null && dividend instanceof desmoj.core.simulator.TimeSpan) || dividend === null) && ((divisor != null && divisor instanceof desmoj.core.simulator.TimeSpan) || divisor === null)) {
                        return desmoj.core.simulator.TimeOperations.divide$desmoj_core_simulator_TimeSpan$desmoj_core_simulator_TimeSpan(dividend, divisor);
                    }
                    else if (((dividend != null && dividend instanceof desmoj.core.simulator.TimeSpan) || dividend === null) && ((typeof divisor === 'number') || divisor === null)) {
                        return desmoj.core.simulator.TimeOperations.divide$desmoj_core_simulator_TimeSpan$double(dividend, divisor);
                    }
                    else
                        throw new Error('invalid overload');
                };
                TimeOperations.divide$desmoj_core_simulator_TimeSpan$double = function (dividend, divisor) {
                    if (divisor <= 0) {
                        throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t divide TimeSpan and double value! Simulation aborted.", "Class : TimeOperations  Methode : mdivide(TimeSpan dividend, double divisor)", "Cannot devide by zero.", "Never try to devide by zero.", null)));
                    }
                    if (divisor < 1) {
                        if (Number.MAX_VALUE * divisor < dividend.getTimeInEpsilon()) {
                            throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t divide TimeSpan and double value! Simulation aborted.", "Class : TimeOperations  Methode : mdivide(TimeSpan dividend, double divisor)", "the resulting quotient is too big. ", "Can only create TimeSpan objects which are shorter than Long.MAX_VALUE (in the TimeUnit of epsilon).", null)));
                        }
                    }
                    return new desmoj.core.simulator.TimeSpan(Math.floor((dividend.getTimeInEpsilon() / divisor)), TimeOperations.epsilon_$LI$());
                };
                /**
                 * Returns the epsilon value representing the granularity of simulation time
                 * for this experiment.
                 *
                 * @return {def.TimeUnit} TimeUnit : The granularity of simulation time
                 */
                TimeOperations.getEpsilon = function () {
                    return TimeOperations.epsilon_$LI$();
                };
                /**
                 * Returns the smallest distinguishable TimeSpan.
                 *
                 * @return {desmoj.core.simulator.TimeSpan} TimeSpan : The smallest distinguishable TimeSpan, i.e. one interval
                 * of the epsilon unit
                 */
                TimeOperations.getEpsilonSpan = function () {
                    return new desmoj.core.simulator.TimeSpan(1, TimeOperations.epsilon_$LI$());
                };
                /**
                 * Returns the reference time unit specifying what is meant by the
                 * simulation time step of 1 in statements without an explicit declaration
                 * of a time unit like in <code>new TimeSpan(5)</code>.
                 *
                 * @return {def.TimeUnit} the reference time unit
                 *
                 */
                TimeOperations.getReferenceUnit = function () {
                    return TimeOperations.referenceUnit_$LI$();
                };
                /**
                 * Sets the epsilon value representing the granularity of simulation time to
                 * the given TimeUnit parameter. This is a package private method for
                 * internal framework use only since calling this method after experiment setup
                 * will cause erroneous behavior.
                 *
                 * @param {def.TimeUnit} epsilon
                 * TimeUnit : The granularity of simulation time, i.e. the
                 * smallest distinguishable span of simulation time.
                 */
                TimeOperations.setEpsilonUnit = function (epsilon) {
                    if (!def.TimeUnit["_$wrappers"][epsilon].equals(TimeOperations.epsilon_$LI$())) {
                        TimeOperations.epsilon = epsilon;
                    }
                };
                /**
                 * Sets the reference time unit specifying what is meant by the simulation
                 * time step of 1 in statements without an explicit declaration of a time
                 * unit like in <code>new TimeSpan(5)</code>.
                 *
                 * @param {def.TimeUnit} referenceUnit
                 * the reference time unit
                 *
                 */
                TimeOperations.setReferenceUnitX = function (referenceUnit) {
                    TimeOperations.referenceUnit = referenceUnit;
                };
                /**
                 * Formats the given instant of time according to the timeFormatter.
                 *
                 * @param {desmoj.core.simulator.TimeInstant} instant
                 * the instant of time to be formatted
                 *
                 * @return {string}
                 */
                TimeOperations.formatTimeInstant = function (instant) {
                    return TimeOperations.myTimeFormatter_$LI$()['buildTimeString$desmoj_core_simulator_TimeInstant'](instant);
                };
                /**
                 * Formats the given span of time according to the timeFormatter.
                 *
                 * @param {desmoj.core.simulator.TimeSpan} span
                 * the span of time to be formatted
                 *
                 * @return {string}
                 */
                TimeOperations.formatTimeSpan = function (span) {
                    return TimeOperations.myTimeFormatter_$LI$()['buildTimeString$desmoj_core_simulator_TimeSpan'](span);
                };
                /**
                 * Returns the time Formatter. This is a package private method for internal
                 * framework use only.
                 * @return {*}
                 */
                TimeOperations.getTimeFormatter = function () {
                    return TimeOperations.myTimeFormatter_$LI$();
                };
                /**
                 * Sets the time Formatter.
                 *
                 * @param {*} myTimeFormatter
                 * the Time Formatter
                 * @param {boolean} override
                 * indicates that a custom <code>TimeFormatter</code> is supplied (<code>true</code>).
                 * This formatter will persist even if future calls to this method provide additional
                 * <code>TimeFormatter</code>s who have this parameter set to <code>false</code>.
                 * The default time <code>TimeFormatter</code> supplied during the <code>Experiment</code>
                 * setup will use <code>override = false</code>, so that the default formatter will only
                 * be used if no <code>TimeFormatter</code> has been explicitly set the the user.
                 */
                TimeOperations.setTimeFormatter = function (myTimeFormatter, override) {
                    if (override) {
                        TimeOperations.myTimeFormatter = myTimeFormatter;
                        TimeOperations.customTimeFormatterUsed = true;
                        return;
                    }
                    if (!TimeOperations.customTimeFormatterUsed) {
                        TimeOperations.myTimeFormatter = myTimeFormatter;
                        return;
                    }
                };
                /**
                 * Sets the TimeFormatter used by this environment to a
                 * <code>SingleUnitTimeFormatter</code>, using the current reference
                 * unit and four floating point digits.
                 * @return {*}
                 */
                TimeOperations.getDefaultTimeFormatter = function () {
                    return new desmoj.core.simulator.SingleUnitTimeFormatter(TimeOperations.referenceUnit_$LI$(), TimeOperations.epsilon_$LI$(), 4, false);
                };
                /**
                 * Returns the TimeInstant when the experiment has started.
                 *
                 * @return {desmoj.core.simulator.TimeInstant} TimeInstant : The point in simulation time, the experiment has
                 * started.
                 */
                TimeOperations.getStartTime = function () {
                    return TimeOperations.startTime;
                };
                /**
                 * Sets the experiment start time. This is a package private method for
                 * internal framework use only since calling this method after experiment setup
                 * does not make sense.
                 *
                 * @param {desmoj.core.simulator.TimeInstant} startTime
                 * TimeInstant : The start time of the current experiment.
                 */
                TimeOperations.setStartTime = function (startTime) {
                    TimeOperations.startTime = startTime;
                };
                return TimeOperations;
            }());
            /**
             * The point in simulation time when the experiment has started.
             */
            TimeOperations.startTime = null;
            /**
             * Flag to indicate that a user-defined <code>TimeFormatter</code> is used
             * (<code>true</code>), while <code>false</code> means the default is applied.
             */
            TimeOperations.customTimeFormatterUsed = false;
            /**
             * Flag to indicate that the user has already created <code>TimeInstants</code>
             * or <code>TimeSpans</code>, proving a means of sending a warning if <code>epislon</code>
             * is changed afterwards.
             */
            TimeOperations.timeObjectsCreated = false;
            simulator.TimeOperations = TimeOperations;
            TimeOperations["__class"] = "desmoj.core.simulator.TimeOperations";
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var exception;
        (function (exception) {
            /**
             * Creates a new SimAbortedException declaring the reason for the aborted
             * simulation run in the contents of the error message given as a parameter.
             *
             * @param {desmoj.core.report.ErrorMessage} message
             * desmoj.report.ErrorMessage : The reason for the aborted
             * simulation
             * @class
             * @extends desmoj.core.exception.DESMOJException
             * @author Tim Lechler
             */
            var SimAbortedException = (function (_super) {
                __extends(SimAbortedException, _super);
                function SimAbortedException(message) {
                    return _super.call(this, message) || this;
                }
                return SimAbortedException;
            }(desmoj.core.exception.DESMOJException));
            SimAbortedException.__desmoj_core_exception_SimAbortedException_serialVersionUID = 1;
            exception.SimAbortedException = SimAbortedException;
            SimAbortedException["__class"] = "desmoj.core.exception.SimAbortedException";
            SimAbortedException["__interfaces"] = ["java.io.Serializable"];
        })(exception = core.exception || (core.exception = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var exception;
        (function (exception) {
            /**
             * Constructs a SimFinishedException inserting the given position String and
             * the given simulation time in the ErrorMessage documenting this exception.
             *
             * @param {string} position
             * java.lang.String : contains the position, i.e. Object and
             * method that throws this exception
             * @param {desmoj.core.simulator.TimeInstant} time
             * TimeInstant : The point in simulation time that this exception is
             * thrown
             * @param {desmoj.core.simulator.Model} origin
             * @class
             * @extends desmoj.core.exception.DESMOJException
             * @author Tim Lechler
             */
            var SimFinishedException = (function (_super) {
                __extends(SimFinishedException, _super);
                function SimFinishedException(origin, position, time) {
                    return _super.call(this, new desmoj.core.report.ErrorMessage(origin, "SimFinishedException thrown!", "Position " + position, "Simulation has come to an end.", "No Error.", time)) || this;
                }
                return SimFinishedException;
            }(desmoj.core.exception.DESMOJException));
            SimFinishedException.__desmoj_core_exception_SimFinishedException_serialVersionUID = 1;
            exception.SimFinishedException = SimFinishedException;
            SimFinishedException["__class"] = "desmoj.core.exception.SimFinishedException";
            SimFinishedException["__interfaces"] = ["java.io.Serializable"];
        })(exception = core.exception || (core.exception = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            /**
             * A table formatter class for writing simulation output to HTML tables.
             * It also supports the visualisation of 2D-charts based on HTML5's canvas-element.
             * This class implements the HTML formatting functionality of the deprecated class
             * desmoj.report.HTMLFileOuptut
             *
             * @version DESMO-J, Ver. 2.5.1e copyright (c) 2017
             * @author Johanna Djimandjaja
             * @author based on HTMLTableFormatter by Nicolas Knaak
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License. You
             * may obtain a copy of the License at
             * http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS"
             * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
             * or implied. See the License for the specific language governing
             * permissions and limitations under the License.
             * @class
             * @extends desmoj.core.report.AbstractTableFormatter
             */
            var HTMLTableChartFormatter = (function (_super) {
                __extends(HTMLTableChartFormatter, _super);
                function HTMLTableChartFormatter() {
                    var _this = _super.call(this) || this;
                    /*private*/ _this._freeCanvasIDNumber = 0;
                    /*private*/ _this._scriptFormatter = new desmoj.core.report.JavaScriptFormatter();
                    return _this;
                }
                /**
                 * Returns the hexadecimal notation for the given color.<br>
                 * The notation combines the red, green, and blue color values (RGB) in hexadecimal form.
                 * The lowest value that can be given to one of the light sources is 0 (hex 00). The highest value is 255 (hex FF).<br>
                 * When the given color is <code>null</code> returns <code>#000000</code>.
                 * @param {def.Color} color
                 * The color to be coded.
                 * @return
                 * String : The hexadecimal notation for the given color.
                 * @return {string}
                 * @private
                 */
                /*private*/ HTMLTableChartFormatter.prototype.toHexString = function (color) {
                    var hex = "";
                    if (color == null)
                        hex = "#000000";
                    else {
                        var r = color.getRed();
                        var g = color.getGreen();
                        var b = color.getBlue();
                        hex = "#" + this.intToHexString(r) + this.intToHexString(g) + this.intToHexString(b);
                    }
                    return hex;
                };
                /**
                 * Changes a given number into a 2-digit hexadecimal string.<br>
                 * Numbers less then 0 will be changed to the String 00 and numbers higher then 255 will be changed to FF.
                 * @param {number} number
                 * The number, that should be changed into hexadecimal.
                 * @return
                 * String : The given number as a 2-digit hexadecimal string.
                 * @return {string}
                 * @private
                 */
                /*private*/ HTMLTableChartFormatter.prototype.intToHexString = function (number) {
                    if (number <= 0)
                        return "00";
                    if (number >= 255)
                        return "FF";
                    var hex;
                    if (number < 16) {
                        hex = "0" + def.Integer.toHexString(number);
                    }
                    else {
                        hex = def.Integer.toHexString(number);
                    }
                    return hex;
                };
                /**
                 * Inserts a canvas element.
                 * @param {string} canvasID
                 * @param {number} canvasWidth
                 * @param {number} canvasHeight
                 * @private
                 */
                /*private*/ HTMLTableChartFormatter.prototype.createCanvas = function (canvasID, canvasWidth, canvasHeight) {
                    this.out.writeln("<div align=\"center\">");
                    this.out.writeln("<canvas id=\"" + canvasID + "\" width=\"" + canvasWidth + "\" height=\"" + canvasHeight + "\">");
                    this.out.writeln("Your browser is not able to display this graphic.<br />");
                    this.out.writeln("This could be because it does not support the canvas-Element by html5<noscript> or because it does not support JavaScript</noscript>.");
                    this.out.writeln("</canvas>");
                    this.out.writeln("</div><p></p>");
                };
                /**
                 * Writes the closing tag for the script-Element.
                 * @private
                 */
                /*private*/ HTMLTableChartFormatter.prototype.closeScript = function () {
                    this.out.writeln("//-->");
                    this.out.writeln("</script>");
                };
                /**
                 * Writes the opening tag for the script-Element.
                 * @private
                 */
                /*private*/ HTMLTableChartFormatter.prototype.openScript = function () {
                    this.out.writeln("<script type=\"text/javascript\">");
                    this.out.writeln("<!--");
                };
                /**
                 * Inserts a reference to the top page and close the HTML file by writing the footing tags, flushing the buffer and
                 * closing the file.
                 */
                HTMLTableChartFormatter.prototype.close = function () {
                    if (this.rowOpen)
                        this.closeRow();
                    if (this.tableOpen)
                        this.closeTable();
                    this.out.writeln("<font size=\"-1\"><a href=\"#top\">top</a></font><p></p>");
                    this.out.writeln("<font size=\"-2\">created using <a href=\"http://www.desmoj.de\">" + "DESMO-J</A> Version " + desmoj.core.simulator.Experiment.getDesmoJVersion() + " at " + new Date() + " - DESMO-J is licensed under " + desmoj.core.simulator.Experiment.getDesmoJLicense(true) + "</font>");
                    this.out.write("</body></html>");
                };
                /**
                 * Writes the tag to close a row in a table to the file.
                 */
                HTMLTableChartFormatter.prototype.closeRow = function () {
                    if ((this.rowOpen) && (this.tableOpen)) {
                        this.out.writeln("</tr>");
                        this.rowOpen = false;
                        this._currentReporter = null;
                    }
                };
                /**
                 * Inserts the tags needed to close a HTML 3.2 table into the file.
                 */
                HTMLTableChartFormatter.prototype.closeTable = function () {
                    this.closeTableNoTopTag();
                };
                /**
                 * Inserts the tags needed to close a HTML 3.2 table into the file. Also
                 * inserts a paragraph tag to add some space below the table. But omits the
                 * top tag as used in method <code>closeTable()</code>. This is needed if
                 * one reportable is generating a report that consists of more than one
                 * table (see <code>StockReporter</code> or <code>HistogramReporter</code>)
                 */
                HTMLTableChartFormatter.prototype.closeTableNoTopTag = function () {
                    if (!this.tableOpen)
                        return;
                    if (this.rowOpen) {
                        this.closeRow();
                        this.rowOpen = false;
                    }
                    this.out.writeln("</table><p></p>");
                    this.tableOpen = false;
                };
                /**
                 * Opens a new file with the given fileName for writing a HTML table to. If
                 * no String is given, the default filename "unnamed_DESMOJ_file" is used.
                 *
                 * @param {string} name
                 * java.lang.String : The name of the file to be created
                 */
                HTMLTableChartFormatter.prototype.open = function (name) {
                    this.out.writeln("<!DOCTYPE html>");
                    var sb = { str: "", toString: function () { return this.str; } };
                    /* append */ (function (sb) { return sb.str = sb.str.concat("<html><head>" + desmoj.core.report.FileOutput.getEndOfLine()); })(sb);
                    /* append */ (function (sb) { return sb.str = sb.str.concat("<meta http-equiv=\"Content-Type\" content="); })(sb);
                    /* append */ (function (sb) { return sb.str = sb.str.concat("\"text/html; charset=iso-8859-1\">" + desmoj.core.report.FileOutput.getEndOfLine()); })(sb);
                    /* append */ (function (sb) { return sb.str = sb.str.concat("<meta name=\"Author\" content=\"Tim Lechler\">" + desmoj.core.report.FileOutput.getEndOfLine()); })(sb);
                    /* append */ (function (sb) { return sb.str = sb.str.concat("<meta name=\"GENERATOR\" content=\"DESMO-J " + desmoj.core.simulator.Experiment.getDesmoJVersion() + "\">" + desmoj.core.report.FileOutput.getEndOfLine()); })(sb);
                    /* append */ (function (sb) { return sb.str = sb.str.concat("<title>" + name + "</title></head>" + desmoj.core.report.FileOutput.getEndOfLine()); })(sb);
                    /* append */ (function (sb) { return sb.str = sb.str.concat("<body text=\"#000000\" bgcolor=\"#FFFFFF\" link=\"#0000EE\""); })(sb);
                    /* append */ (function (sb) { return sb.str = sb.str.concat(" vlink=\"#551A8B\" alink=\"#FF0000\">" + desmoj.core.report.FileOutput.getEndOfLine()); })(sb);
                    /* append */ (function (sb) { return sb.str = sb.str.concat("<a name=\"top\"></a><br />" + desmoj.core.report.FileOutput.getEndOfLine()); })(sb);
                    this.out.write(/* toString */ sb.str);
                };
                HTMLTableChartFormatter.prototype.openRow = function (rep) {
                    if (((rep != null && rep instanceof desmoj.core.report.Reporter) || rep === null)) {
                        _super.prototype.openRow.call(this, rep);
                    }
                    else if (rep === undefined) {
                        return this.openRow$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                HTMLTableChartFormatter.prototype.openRow$ = function () {
                    if (this.tableOpen) {
                        if (!this.rowOpen) {
                            this.out.write("<tr valign=\"top\">");
                            this.rowOpen = true;
                        }
                    }
                };
                /**
                 * Inserts the tags needed to build a HTML 3.2 table heading into the file.
                 * The table's heading text is given with the parameter.
                 *
                 * @param {string} s
                 * String : The heading for the table
                 */
                HTMLTableChartFormatter.prototype.openTable = function (s) {
                    if (this.tableOpen)
                        return;
                    var sb = { str: "", toString: function () { return this.str; } };
                    /* append */ (function (sb) { return sb.str = sb.str.concat("<div align=\"center\"><h3>" + s + "</h3></div>" + desmoj.core.report.FileOutput.getEndOfLine()); })(sb);
                    /* append */ (function (sb) { return sb.str = sb.str.concat("<table border=\"0\" cellspacing=\"0\" cellpadding=\"3\" "); })(sb);
                    /* append */ (function (sb) { return sb.str = sb.str.concat("width=\"100%\">" + desmoj.core.report.FileOutput.getEndOfLine()); })(sb);
                    this.out.write(/* toString */ sb.str);
                    this.tableOpen = true;
                    this.rowOpen = false;
                };
                /**
                 * Returns the status of the current table row that is written to.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if the method
                 * <code>openRow()</code> has been called last, <code>false</code>
                 * if the method <code>closeRow()</code> has been called last
                 */
                HTMLTableChartFormatter.prototype.rowIsOpen = function () {
                    return this.rowOpen;
                };
                /**
                 * Sets an output file to write the table to
                 *
                 * @param {desmoj.core.report.FileOutput} out
                 * desmoj.report.FileOutput
                 */
                HTMLTableChartFormatter.prototype.setOutput = function (out) {
                    _super.prototype.setOutput.call(this, out);
                    this._scriptFormatter.setOutput(this.out);
                };
                /**
                 * Returns the status of the current table that is written to.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if the method
                 * <code>openTable()</code> has been called last,
                 * <code>false</code> if the method <code>closeTable()</code>
                 * has been called last
                 */
                HTMLTableChartFormatter.prototype.tableIsOpen = function () {
                    return this.tableOpen;
                };
                /**
                 * Creates a new table cell and writes the given String into that cell. Note
                 * that there this is raw HTML code so there must not be any special
                 * language specific characters that might confuse any browser. A new cell
                 * can not be written, if neither a table nor a row have been opened yet.
                 * The method will simply return without action in that case.
                 *
                 * @param {string} s
                 * java.lang.String : The text to be printed into a cell
                 * @param {number} spanning
                 * number of cells to span
                 */
                HTMLTableChartFormatter.prototype.writeCell = function (s, spanning) {
                    if (s == null)
                        return;
                    if (!((this.rowOpen) && (this.tableOpen)))
                        return;
                    if (spanning === 1)
                        this.out.write("<td>" + s + "</td>");
                    else
                        this.out.write("<td colspan=\"" + spanning + "\"><i>&ensp;&ensp;&#151; " + s + "<i></td>");
                };
                /**
                 * Creates a new table cell with the specified color.
                 * @param {def.Color} cellColor
                 * java.awt.Color : The color of the cell, that should be created.
                 */
                HTMLTableChartFormatter.prototype.writeColoredCell = function (cellColor) {
                    if (!((this.rowOpen) && (this.tableOpen)))
                        return;
                    this.out.write("<td width=\"20\" bgcolor=\"" + this.toHexString(cellColor) + "\"></td>");
                };
                /**
                 * Creates a newcentered heading row to print a title in. Note that there
                 * this is raw HTML code so the string given must not contain any special
                 * language specific characters that might confuse any browser. been opened
                 * yet. The method will simply return without action in that case. The
                 * number for the HTML heading style must be inside the range [1,6]. If not,
                 * it will be trimmed to the nearest legal heading style number.
                 *
                 * @param {number} style
                 * int : The heading style format number for the text to be
                 * printed in
                 * @param {string} s
                 * java.lang.String : The text to be printed as heading
                 */
                HTMLTableChartFormatter.prototype.writeHeading = function (style, s) {
                    if (s == null)
                        return;
                    if (style > 6)
                        style = 6;
                    if (style < 1)
                        style = 1;
                    if (this.tableOpen)
                        return;
                    this.out.write("<p></p><h" + style + "><div align=\"center\">" + s + "</div></h" + style + "><p></p>");
                };
                /**
                 * Creates a new table cell and writes the given String into that cell as
                 * heading cells in bold letters and with centered text. Note that there
                 * this is raw HTML code so there must not be any special language specific
                 * characters that might confuse any browser. A new cell can not be written,
                 * if netiher a tbale nor a row have been opened yet. The method will simply
                 * return without action in that case.
                 *
                 * @param {string} s
                 * java.lang.String : The text to be printed into a cell
                 */
                HTMLTableChartFormatter.prototype.writeHeadingCell = function (s) {
                    if (s == null)
                        return;
                    if ((this.rowOpen) && (this.tableOpen))
                        this.out.write("<td><b><div align=\"left\">" + s + "</div></b></td>");
                };
                /**
                 * Inserts a reference to the top page and writes the HTML tag for inserting a horizontal ruler into the file. Note
                 * that horizontal rulers are not written into table cells, thus this method
                 * simply returns, if a table is still open.
                 */
                HTMLTableChartFormatter.prototype.writeHorizontalRuler = function () {
                    if (!this.tableOpen)
                        this.out.writeln("<font size=\"-1\"><a href=\"#top\">top</a></font><p></p>");
                    this.out.write("<hr>");
                };
                /**
                 * Creates a canvas area and draws a chart in this area.
                 * @param {*} canvas
                 * The canvas containing the chart data to be drawn.
                 */
                HTMLTableChartFormatter.prototype.drawChart = function (canvas) {
                    if (this.tableOpen)
                        return;
                    this.createCanvas(canvas.getCanvasID(), canvas.getCanvasWidth(), canvas.getCanvasHeight());
                    this.openScript();
                    this._scriptFormatter.writeDrawingScript(canvas);
                    this.closeScript();
                };
                /**
                 * Returns an ID number for a canvas-element
                 * and increases the free ID number.
                 * @return
                 * @return {number}
                 */
                HTMLTableChartFormatter.prototype.getFreeCanvasIDNum = function () {
                    this._freeCanvasIDNumber++;
                    return this._freeCanvasIDNumber - 1;
                };
                /**
                 * @return {string} The string <code>"html"</code>
                 */
                HTMLTableChartFormatter.prototype.getFileFormat = function () {
                    return "html";
                };
                return HTMLTableChartFormatter;
            }(desmoj.core.report.AbstractTableFormatter));
            report.HTMLTableChartFormatter = HTMLTableChartFormatter;
            HTMLTableChartFormatter["__class"] = "desmoj.core.report.HTMLTableChartFormatter";
            HTMLTableChartFormatter["__interfaces"] = ["desmoj.core.report.TableFormatter"];
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            /**
             * A table formatter class for writing simulation output to HTML tables. This
             * class implements the HTML formatting functionality of the deprecated class
             * desmoj.report.HTMLFileOuptut
             *
             * @version DESMO-J, Ver. 2.5.1e copyright (c) 2017
             * @author Nicolas Knaak
             * @author based on HTMLFileOutput by Tim Lechler
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License. You
             * may obtain a copy of the License at
             * http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS"
             * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
             * or implied. See the License for the specific language governing
             * permissions and limitations under the License.
             *
             * @class
             * @extends desmoj.core.report.AbstractTableFormatter
             */
            var HTMLTableFormatter = (function (_super) {
                __extends(HTMLTableFormatter, _super);
                function HTMLTableFormatter() {
                    return _super.call(this) || this;
                }
                /**
                 * Close the HTML file by writing the footing tags, flushing the buffer and
                 * closing the file.
                 */
                HTMLTableFormatter.prototype.close = function () {
                    if (this.rowOpen)
                        this.closeRow();
                    if (this.tableOpen)
                        this.closeTable();
                    this.out.writeln("<FONT SIZE=-2>created using <A HREF=http://www.desmoj.de>" + "DESMO-J</A> Version " + desmoj.core.simulator.Experiment.getDesmoJVersion() + " at " + new Date() + " - DESMO-J is licensed under " + desmoj.core.simulator.Experiment.getDesmoJLicense(true) + "</FONT>");
                    this.out.write("</BODY></HTML>");
                };
                /**
                 * Writes the tag to close a row in a table to the file.
                 */
                HTMLTableFormatter.prototype.closeRow = function () {
                    if ((this.rowOpen) && (this.tableOpen)) {
                        this.out.writeln("</TR>");
                        this.rowOpen = false;
                        this._currentReporter = null;
                    }
                };
                /**
                 * Inserts the tags needed to close a HTML 3.2 table into the file. Also
                 * inserts a paragraph tag to add some space below the table.
                 */
                HTMLTableFormatter.prototype.closeTable = function () {
                    if (!this.tableOpen)
                        return;
                    if (this.rowOpen) {
                        this.closeRow();
                        this.rowOpen = false;
                    }
                    this.out.writeln("</TABLE><P>");
                    this.out.writeln("<FONT SIZE=-1><A HREF=#top>top</A></FONT><P>");
                    this.tableOpen = false;
                };
                /**
                 * Inserts the tags needed to close a HTML 3.2 table into the file. Also
                 * inserts a paragraph tag to add some space below the table. But omits the
                 * top tag as used in method <code>closeTable()</code>. This is needed if
                 * one reportable is generating a report that consists of more than one
                 * table (see <code>StockReporter</code> or <code>HistogramReporter</code>)
                 */
                HTMLTableFormatter.prototype.closeTableNoTopTag = function () {
                    if (!this.tableOpen)
                        return;
                    if (this.rowOpen) {
                        this.closeRow();
                        this.rowOpen = false;
                    }
                    this.out.writeln("</TABLE><P>");
                    this.tableOpen = false;
                };
                /**
                 * Opens a new file with the given fileName for writing a HTML table to. If
                 * no String is given, the default filename "unnamed_DESMOJ_file" is used.
                 *
                 * @param {string} name
                 * java.lang.String : The name of the file to be created
                 */
                HTMLTableFormatter.prototype.open = function (name) {
                    var sb = { str: "", toString: function () { return this.str; } };
                    /* append */ (function (sb) { return sb.str = sb.str.concat("<HTML><HEAD>" + desmoj.core.report.FileOutput.getEndOfLine()); })(sb);
                    /* append */ (function (sb) { return sb.str = sb.str.concat("<META HTTP-EQUIV=\"Content-Type\" CONTENT="); })(sb);
                    /* append */ (function (sb) { return sb.str = sb.str.concat("\"text/html; charset=iso-8859-1\">" + desmoj.core.report.FileOutput.getEndOfLine()); })(sb);
                    /* append */ (function (sb) { return sb.str = sb.str.concat("<META NAME=\"Author\" CONTENT=\"Tim Lechler\">" + desmoj.core.report.FileOutput.getEndOfLine()); })(sb);
                    /* append */ (function (sb) { return sb.str = sb.str.concat("<META NAME=\"GENERATOR\" CONTENT=\"DESMO-J " + desmoj.core.simulator.Experiment.getDesmoJVersion() + "\">" + desmoj.core.report.FileOutput.getEndOfLine()); })(sb);
                    /* append */ (function (sb) { return sb.str = sb.str.concat("<TITLE>" + name + "</TITLE></HEAD>" + desmoj.core.report.FileOutput.getEndOfLine()); })(sb);
                    /* append */ (function (sb) { return sb.str = sb.str.concat("<BODY TEXT=\"#000000\" BGCOLOR=\"#FFFFFF\" LINK=\"#0000EE\""); })(sb);
                    /* append */ (function (sb) { return sb.str = sb.str.concat(" VLINK=\"#551A8B\" ALINK=\"#FF0000\">" + desmoj.core.report.FileOutput.getEndOfLine()); })(sb);
                    /* append */ (function (sb) { return sb.str = sb.str.concat("<A NAME=\"top\"></A><br>" + desmoj.core.report.FileOutput.getEndOfLine()); })(sb);
                    this.out.write(/* toString */ sb.str);
                };
                HTMLTableFormatter.prototype.openRow = function (rep) {
                    if (((rep != null && rep instanceof desmoj.core.report.Reporter) || rep === null)) {
                        _super.prototype.openRow.call(this, rep);
                    }
                    else if (rep === undefined) {
                        return this.openRow$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                HTMLTableFormatter.prototype.openRow$ = function () {
                    if (this.tableOpen) {
                        if (!this.rowOpen) {
                            this.out.write("<TR VALIGN=TOP>");
                            this.rowOpen = true;
                        }
                    }
                };
                /**
                 * Inserts the tags needed to build a HTML 3.2 table heading into the file.
                 * The table's heading text is given with the parameter.
                 *
                 * @param {string} s
                 * String : The heading for the table
                 */
                HTMLTableFormatter.prototype.openTable = function (s) {
                    if (this.tableOpen)
                        return;
                    var sb = { str: "", toString: function () { return this.str; } };
                    /* append */ (function (sb) { return sb.str = sb.str.concat("<DIV align=center><H3>" + s + "</H3></DIV>" + desmoj.core.report.FileOutput.getEndOfLine()); })(sb);
                    /* append */ (function (sb) { return sb.str = sb.str.concat("<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=3 "); })(sb);
                    /* append */ (function (sb) { return sb.str = sb.str.concat("WIDTH=\"100%\" >" + desmoj.core.report.FileOutput.getEndOfLine()); })(sb);
                    this.out.write(/* toString */ sb.str);
                    this.tableOpen = true;
                    this.rowOpen = false;
                };
                /**
                 * Returns the status of the current table row that is written to.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if the method
                 * <code>openRow()</code> has been called last, <code>false</code>
                 * if the method <code>closeRow()</code> has been called last
                 */
                HTMLTableFormatter.prototype.rowIsOpen = function () {
                    return this.rowOpen;
                };
                /**
                 * Returns the status of the current table that is written to.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if the method
                 * <code>openTable()</code> has been called last,
                 * <code>false</code> if the method <code>closeTable()</code>
                 * has been called last
                 */
                HTMLTableFormatter.prototype.tableIsOpen = function () {
                    return this.tableOpen;
                };
                /**
                 * Creates a new table cell and writes the given String into that cell. Note
                 * that there this is raw HTML code so there must not be any special
                 * language specific characters that might confuse any browser. A new cell
                 * can not be written, if neither a table nor a row have been opened yet.
                 * The method will simply return without action in that case.
                 *
                 * @param {string} s
                 * java.lang.String : The text to be printed into a cell
                 * @param {number} spanning
                 * number of cells to span
                 */
                HTMLTableFormatter.prototype.writeCell = function (s, spanning) {
                    if (s == null)
                        return;
                    if (!((this.rowOpen) && (this.tableOpen)))
                        return;
                    if (spanning === 1)
                        this.out.write("<TD>" + s + "</TD>");
                    else
                        this.out.write("<TD colspan=\"" + spanning + "\"><i>&ensp;&ensp;&#151; " + s + "<i></TD>");
                };
                /**
                 * Creates a newcentered heading row to print a title in. Note that there
                 * this is raw HTML code so the string given must not contain any special
                 * language specific characters that might confuse any browser. been opened
                 * yet. The method will simply return without action in that case. The
                 * number for the HTML heading style must be inside the range [1,6]. If not,
                 * it will be trimmed to the nearest legal heading style number.
                 *
                 * @param {number} style
                 * int : The heading style format number for the text to be
                 * printed in
                 * @param {string} s
                 * java.lang.String : The text to be printed as heading
                 */
                HTMLTableFormatter.prototype.writeHeading = function (style, s) {
                    if (s == null)
                        return;
                    if (style > 6)
                        style = 6;
                    if (style < 1)
                        style = 1;
                    if (this.tableOpen)
                        return;
                    this.out.write("<P><H" + style + "><DIV align=center>" + s + "</DIV></H" + style + "><P>");
                };
                /**
                 * Creates a new table cell and writes the given String into that cell as
                 * heading cells in bold letters and with centered text. Note that there
                 * this is raw HTML code so there must not be any special language specific
                 * characters that might confuse any browser. A new cell can not be written,
                 * if netiher a tbale nor a row have been opened yet. The method will simply
                 * return without action in that case.
                 *
                 * @param {string} s
                 * java.lang.String : The text to be printed into a cell
                 */
                HTMLTableFormatter.prototype.writeHeadingCell = function (s) {
                    if (s == null)
                        return;
                    if ((this.rowOpen) && (this.tableOpen))
                        this.out.write("<TD><B><DIV align=left>" + s + "</DIV></B></TD>");
                };
                /**
                 * Writes the HTML tag for inserting a horizontal ruler into the file. Note
                 * that horizontal rulers are not written into table cells, thus this method
                 * simply returns, if a table is still open.
                 */
                HTMLTableFormatter.prototype.writeHorizontalRuler = function () {
                    if (!this.tableOpen)
                        this.out.write("<HR>");
                };
                /**
                 * @return {string} The string <code>"html"</code>
                 */
                HTMLTableFormatter.prototype.getFileFormat = function () {
                    return "html";
                };
                return HTMLTableFormatter;
            }(desmoj.core.report.AbstractTableFormatter));
            report.HTMLTableFormatter = HTMLTableFormatter;
            HTMLTableFormatter["__class"] = "desmoj.core.report.HTMLTableFormatter";
            HTMLTableFormatter["__interfaces"] = ["desmoj.core.report.TableFormatter"];
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            /**
             * Constructs a FileOutput object. A FileOuput object is capable of opening
             * a file using method <code>open(String fileName)</code>. Note that if
             * the output stream used cannot be opened, the whole error handling is
             * printed to the system's standard output stream. The 'endOfLine' String is
             * set to the underlying system's String used to separate lines as given by
             * the system property <code>line.separator</code>.
             * @class
             * @author Tim Lechler
             */
            var FileOutput = (function () {
                function FileOutput() {
                    this.fileName = null;
                    this.file = null;
                    this.fileOpen = false;
                    this.empty = false;
                    this.fileOpen = false;
                    this.empty = true;
                    this.fileName = null;
                }
                FileOutput.NORMAL_FILE_ACCESS_$LI$ = function () { if (FileOutput.NORMAL_FILE_ACCESS == null)
                    FileOutput.NORMAL_FILE_ACCESS = new FileOutput.FileOutput$0(); return FileOutput.NORMAL_FILE_ACCESS; };
                ;
                FileOutput.fileSystem_$LI$ = function () { if (FileOutput.fileSystem == null)
                    FileOutput.fileSystem = FileOutput.NORMAL_FILE_ACCESS_$LI$(); return FileOutput.fileSystem; };
                ;
                FileOutput.eol_$LI$ = function () { if (FileOutput.eol == null)
                    FileOutput.eol = def.System.getProperty("line.separator"); return FileOutput.eol; };
                ;
                /**
                 * Flushes the buffer and closes the file. note that if another file with
                 * the same name is opened and written to, it will overwrite the previous
                 * file on the disc without notice. All users of Output objects have to call
                 * <code>close()</code> to properly shut down the ouput stream after the
                 * last call to the printing methods. Classes overriding this method should
                 * put all necessary actions to properly close their file into the
                 * <code>close()</code> method and make a call to
                 * <code>super.close()</code> as their last command to finally close
                 * buffers and files.
                 */
                FileOutput.prototype.close = function () {
                    if (!this.fileOpen)
                        return;
                    try {
                        this.file.flush();
                        this.file.close();
                        this.fileOpen = false;
                        this.empty = true;
                    }
                    catch (ioEx) {
                        console.info("IOException thrown : " + ioEx);
                        console.info("description: Can\'t flush and close " + this.fileName);
                        console.info("origin     : Experiment auxiliaries");
                        console.info("location   : FileOutput.close()");
                        console.info("hint       : Check access to the file and that it is not in use by some other application.");
                        console.info("The System will not be shut down. But the file " + this.fileName + " can not be closed and may contain no data!");
                    }
                    ;
                };
                /**
                 * Returns the currently valid String for separating lines of output. This
                 * is a platform dependent String and is set to the underlying system's
                 * String by default.
                 *
                 * @return {string} String : The String used to separate lines
                 */
                FileOutput.getEndOfLine = function () {
                    return FileOutput.eol_$LI$();
                };
                /**
                 * Returns the current fileName of this FileOutput or <code>null</code> if
                 * it has not been opened and named yet.
                 *
                 * @return {string} java.lang.String : The name of the file or <code>null</code> if
                 * file has not been opened and named yet
                 */
                FileOutput.prototype.getFileName = function () {
                    return this.fileName;
                };
                /**
                 * Returns the currently active String for separating individual entries in
                 * a line of output. This comes in handy, when trying to write files in a
                 * certain format i.e. dbf format. Data from files complying to that format
                 * can easily be read and imported to a variety of standard statistics
                 * packages for further manipulation and analysis.
                 *
                 * @return {string} String : The String used to separate entries within a line
                 */
                FileOutput.getSeparator = function () {
                    return FileOutput.sep;
                };
                /**
                 * Returns a boolean value showing if relevant data has been written to the
                 * file. If only file headings have been written, this method will return
                 * <code>true</code> to indicate that it does not contain information and
                 * thus might just as well be deleted. If data has been written to it, this
                 * method will return <code>false</code> instead.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if no relevant data but the
                 * heading has been written to this file, <code>false</code>
                 * otherwise
                 */
                FileOutput.prototype.isEmpty = function () {
                    return this.empty;
                };
                /**
                 * Returns the current state of the FileOutput. <code>True</code> is
                 * returned, if the file has been opened successfully and can be written to.
                 * If the file has been closed or has not been opened yet,
                 * <code>false</code> is returned.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if the file is currently open,
                 * <code>false</code> if not
                 */
                FileOutput.prototype.isOpen = function () {
                    return this.fileOpen;
                };
                FileOutput.prototype.open = function (pathname, name) {
                    if (((typeof pathname === 'string') || pathname === null) && name === undefined) {
                        return this.open$java_lang_String(pathname);
                    }
                    else
                        throw new Error('invalid overload');
                };
                FileOutput.prototype.open$java_lang_String = function (name) {
                    if (this.fileOpen)
                        return;
                    if (name != null)
                        this.fileName = name;
                    else
                        this.fileName = "unnamed_DESMOJ_File";
                    try {
                        this.file = FileOutput.fileSystem_$LI$().createWriter(this.fileName);
                        this.fileOpen = true;
                        this.empty = true;
                    }
                    catch (ioEx) {
                        console.info("IOException thrown : " + ioEx);
                        console.info("description: Can\'t create file " + this.fileName);
                        console.info("origin     : While creating the Experiment auxiliaries.");
                        console.info("location   : method open() in class FileOutput.");
                        console.info("hint       : Check access to the default path and that no file of thesame name exists");
                        console.info("The System will not be shut down. But the file " + this.fileName + " can not be opened and may not exist as " + "expected!");
                    }
                    ;
                };
                /**
                 * Sets the end-of-line separator String to the given parameter value. The
                 * default value is the end-of-line String of the underlying platform. Use
                 * this method to create files of specific formats. Data from files
                 * complying to that format can easily be read and imported to a variety of
                 * standard statistics packages for further manipulation and analysis.
                 *
                 * @param {string} eolString
                 * String : The String for separating lines
                 */
                FileOutput.setEndOfLine = function (eolString) {
                    FileOutput.eol = eolString;
                };
                /**
                 * Sets the entry separator String to the given parameter value. The default
                 * value is ';'. This is useful, when trying to write files in a certain
                 * format i.e. dbf format. Data from files complying to that format can
                 * easily be read and imported to a variety of standard statistics packages
                 * for further manipulation and analysis.
                 *
                 * @param {string} sepString
                 * String : The String for separating entries within a line
                 */
                FileOutput.setSeparator = function (sepString) {
                    FileOutput.sep = sepString;
                };
                /**
                 * Writes the given String to the open file. If the given String is empty,
                 * the method will simply return without action. Override this method if you
                 * want your data to be written with specific tags as used in the
                 * <code>HTMLFileOutput</code> class.
                 *
                 * @param {string} s
                 * java.lang.String : The String to write to the file
                 * @see HTMLFileOutput
                 */
                FileOutput.prototype.write = function (s) {
                    if (s == null)
                        return;
                    if (!this.fileOpen)
                        return;
                    this.empty = false;
                    try {
                        this.file.write(s);
                    }
                    catch (ioEx) {
                        console.info("IOException thrown : " + ioEx);
                        console.info("description: Can\'t write to file " + this.fileName);
                        console.info("origin     : Experiment auxiliaries");
                        console.info("location   : class FileOutput, method write()");
                        console.info("hint       : Check access to the file and that it is not in use by some other application.");
                        console.info("The System will not be shut down. But it can not be " + "written to the file " + this.fileName + ".  The file may " + "not contain all the important data!");
                    }
                    ;
                };
                /**
                 * Writes the given String to the open file, adding a line separator to the
                 * end of the String written. If the string given is null or "" just a new
                 * line character will be written to the file. This method simply adds the
                 * end-of-line String to the String given and calls the
                 * <code>void write(String s)</code> method.
                 *
                 * @param {string} s
                 * java.lang.String : The String to write to the file
                 */
                FileOutput.prototype.writeln = function (s) {
                    if ((s == null) || (s.length === 0)) {
                        this.write(FileOutput.eol_$LI$());
                        return;
                    }
                    this.write(s + FileOutput.eol_$LI$());
                };
                /**
                 * Writes the given String to the open file, adding a separator to the end
                 * of the String written. If the string given is null or "" just a new line
                 * character will be written to the file. This method simply adds the
                 * end-of-line String to the String given and calls the
                 * <code>void write(String s)</code> method.
                 *
                 * @param {string} s
                 * java.lang.String : The String to write to the file
                 */
                FileOutput.prototype.writeSep = function (s) {
                    if ((s == null) || (s.length === 0)) {
                        this.write(FileOutput.sep);
                        return;
                    }
                    this.write(s + FileOutput.sep);
                };
                /**
                 * Enables the user to globally change the way files are created/opened.
                 * The standard is to create them on disk, but using this method other options, like
                 * creating them in-memory, are available for the standard formatters.
                 * @param {*} fileSystemAccess
                 */
                FileOutput.setFileSystemAccess = function (fileSystemAccess) {
                    FileOutput.fileSystem = fileSystemAccess;
                };
                return FileOutput;
            }());
            /**
             * The character used to separate individual entries within a line.
             */
            FileOutput.sep = ";";
            report.FileOutput = FileOutput;
            FileOutput["__class"] = "desmoj.core.report.FileOutput";
            (function (FileOutput) {
                var FileOutput$0 = (function () {
                    function FileOutput$0() {
                    }
                    /**
                     *
                     * @param {string} filename
                     * @return {*}
                     */
                    FileOutput$0.prototype.createWriter = function (filename) {
                        return new def.ConsoleOutputWriter(filename);
                    };
                    return FileOutput$0;
                }());
                FileOutput.FileOutput$0 = FileOutput$0;
                FileOutput$0["__interfaces"] = ["desmoj.core.report.FileSystemAccess"];
            })(FileOutput = report.FileOutput || (report.FileOutput = {}));
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            /**
             * Constructs a debugnote with the given parameters.
             *
             * @param {desmoj.core.simulator.Model} origin
             * Model : The model that produced this debugnote
             * @param {string} description
             * java.lang.String : The actual debug information
             * @param {desmoj.core.simulator.TimeInstant} time
             * TimeInstant : The point of simulation time this debugnote was
             * created
             * @param {string} componentName
             * java.lang.String : The name of the modelcomponent the
             * debugnote evolved from
             * @class
             * @extends desmoj.core.report.Message
             * @author Tim Lechler
             */
            var DebugNote = (function (_super) {
                __extends(DebugNote, _super);
                function DebugNote(origin, time, componentName, description) {
                    var _this = _super.call(this, origin, description, time) || this;
                    _this._dbgComponent = null;
                    _this._dbgComponent = componentName;
                    return _this;
                }
                /**
                 * Returns the name of the modelcomponent that produced this debugnote.
                 *
                 * @return {string} java.lang.String : The model that produced this debugnote
                 */
                DebugNote.prototype.getOrigin = function () {
                    return this._dbgComponent;
                };
                return DebugNote;
            }(desmoj.core.report.Message));
            report.DebugNote = DebugNote;
            DebugNote["__class"] = "desmoj.core.report.DebugNote";
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            /**
             * Creates an errormessage setting its parameters with the given values.
             *
             * @param {desmoj.core.simulator.Model} origin
             * Model : The model this errormessage evolved from
             * @param {string} errorDescription
             * java.lang.String : Description of the error
             * @param {string} errorLocation
             * java.lang.String : Class and method the error occured in
             * @param {string} errorReason
             * java.lang.String : The probable reason for the error
             * @param {string} errorPrevention
             * java.lang.String : A hint how to prevent the error
             * @param {desmoj.core.simulator.TimeInstant} errorTime
             * @class
             * @extends desmoj.core.report.Message
             * @author Tim Lechler
             */
            var ErrorMessage = (function (_super) {
                __extends(ErrorMessage, _super);
                function ErrorMessage(origin, errorDescription, errorLocation, errorReason, errorPrevention, errorTime) {
                    var _this = _super.call(this, origin, errorDescription, errorTime) || this;
                    _this._errReason = null;
                    _this._errPrevention = null;
                    _this._errLocation = null;
                    _this._errLocation = errorLocation;
                    _this._errReason = errorReason;
                    _this._errPrevention = errorPrevention;
                    return _this;
                }
                /**
                 * Returns a String describing class and method that this message was sent
                 * from.
                 *
                 * @return {string} java.lang.String : The location this message was sent from.
                 */
                ErrorMessage.prototype.getLocation = function () {
                    return this._errLocation;
                };
                /**
                 * Returns a String giving a hint on how to prevent this error to happen.
                 * Note that the hint given is based on the probable reason described but
                 * must not always have that reason.
                 *
                 * @return {string} java.lang.String : The probable reason for this error
                 */
                ErrorMessage.prototype.getPrevention = function () {
                    return this._errPrevention;
                };
                /**
                 * Returns the String describing the probable reason for the error to occur.
                 * Note that the reason given here is the most probable reason for the
                 * effect to occur here. It might have its origin in other classes, so bear
                 * in mind that the casue for the error might have been created in a class
                 * not obviously related to the location this error occured.
                 *
                 * @return {string} java.lang.String : The probable reason for this error
                 */
                ErrorMessage.prototype.getReason = function () {
                    return this._errReason;
                };
                return ErrorMessage;
            }(desmoj.core.report.Message));
            report.ErrorMessage = ErrorMessage;
            ErrorMessage["__class"] = "desmoj.core.report.ErrorMessage";
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            /**
             * Creates a new tracenote with the given parameters as initial values. If
             * <code>null</code> references are given, they are displayed as "----" in
             * the trace output.
             *
             * @param {desmoj.core.simulator.Model} origin
             * Model : The model that produced this tracenote
             * @param {string} message
             * java.lang.String : The actual trace message
             * @param {desmoj.core.simulator.TimeInstant} time
             * TimeInstant : The point in simulation time this tracenote was
             * produced
             * @param {desmoj.core.simulator.Entity} entityInvolved
             * Entity : The entity involved in this change of state
             * @param {desmoj.core.simulator.EventAbstract} eventInvolved
             * Event : The event involved in this change of state
             * @class
             * @extends desmoj.core.report.Message
             * @author Tim Lechler
             */
            var TraceNote = (function (_super) {
                __extends(TraceNote, _super);
                function TraceNote(origin, message, time, entityInvolved, eventInvolved) {
                    var _this = this;
                    if (((origin != null && origin instanceof desmoj.core.simulator.Model) || origin === null) && ((typeof message === 'string') || message === null) && ((time != null && time instanceof desmoj.core.simulator.TimeInstant) || time === null) && ((entityInvolved != null && entityInvolved instanceof desmoj.core.simulator.Entity) || entityInvolved === null) && ((eventInvolved != null && eventInvolved instanceof desmoj.core.simulator.EventAbstract) || eventInvolved === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        _this = _super.call(this, origin, message, time) || this;
                        _this._who = null;
                        _this._what = null;
                        _this._who = null;
                        _this._what = null;
                        (function () {
                            if (entityInvolved == null)
                                _this._who = "----";
                            else
                                _this._who = entityInvolved.getName();
                            if (eventInvolved == null)
                                _this._what = "----";
                            else
                                _this._what = eventInvolved.getName();
                        })();
                    }
                    else if (((origin != null && origin instanceof desmoj.core.simulator.Model) || origin === null) && ((typeof message === 'string') || message === null) && ((time != null && time instanceof desmoj.core.simulator.TimeInstant) || time === null) && ((entityInvolved != null && (entityInvolved instanceof Array)) || entityInvolved === null) && ((eventInvolved != null && eventInvolved instanceof desmoj.core.simulator.EventAbstract) || eventInvolved === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        var entitiesInvolved_1 = __args[3];
                        _this = _super.call(this, origin, message, time) || this;
                        _this._who = null;
                        _this._what = null;
                        _this._who = null;
                        _this._what = null;
                        (function () {
                            if (entitiesInvolved_1 == null || (entitiesInvolved_1.length == 0))
                                _this._who = "----";
                            else {
                                _this._who = entitiesInvolved_1[0].getQuotedName();
                                if (entitiesInvolved_1.length > 1) {
                                    _this._who += entitiesInvolved_1.length > 2 ? ", " + entitiesInvolved_1[1].getQuotedName() : " and " + entitiesInvolved_1[1].getQuotedName();
                                    if (entitiesInvolved_1.length > 2) {
                                        _this._who += " and " + entitiesInvolved_1[2].getQuotedName();
                                    }
                                }
                            }
                            if (eventInvolved == null)
                                _this._what = "----";
                            else
                                _this._what = eventInvolved.getQuotedName();
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                    return _this;
                }
                /**
                 * Returns the name of the entity this tracenote evolved from.
                 *
                 * @return {string} java.lang.String : The name of the entity that produced this
                 * tracenote
                 */
                TraceNote.prototype.getEntity = function () {
                    return this._who;
                };
                /**
                 * Returns the name of the event described in this tracenote from.
                 *
                 * @return {string} java.lang.String : The name of the event that produced this
                 * tracenote
                 */
                TraceNote.prototype.getEvent = function () {
                    return this._what;
                };
                return TraceNote;
            }(desmoj.core.report.Message));
            report.TraceNote = TraceNote;
            TraceNote["__class"] = "desmoj.core.report.TraceNote";
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            /**
             * DistributionReporter - Konstruktorkommentar.
             *
             * @param {desmoj.core.simulator.Reportable} informationSource
             * desmoj.core.simulator.Reportable
             * @class
             * @extends desmoj.core.report.Reporter
             * @author Tim Lechler
             */
            var DistributionReporter = (function (_super) {
                __extends(DistributionReporter, _super);
                function DistributionReporter(informationSource) {
                    var _this = _super.call(this, informationSource) || this;
                    _this.__numColumns = 8;
                    _this.columns = new Array(_this.__numColumns);
                    _this.entries = new Array(_this.__numColumns);
                    _this.groupID = 100;
                    _this.columns[0] = "Title";
                    _this.columns[1] = "(Re)set";
                    _this.columns[2] = "Obs";
                    _this.columns[3] = "Type";
                    _this.columns[4] = "Parameter 1";
                    _this.columns[5] = "Parameter 2";
                    _this.columns[6] = "Parameter 3";
                    _this.columns[7] = "Seed";
                    _this.groupHeading = "Distributions";
                    return _this;
                }
                /**
                 * Returns the array of strings containing all information about the
                 * distribution.
                 *
                 * @return {Array} java.lang.String[] : The array of Strings containing all
                 * information about the distribution
                 */
                DistributionReporter.prototype.getEntries = function () {
                    if (this.source != null && this.source instanceof desmoj.core.dist.Distribution) {
                        this.entries[0] = this.source.getName();
                        this.entries[1] = this.source.resetAt().toString();
                        this.entries[2] = ('' + (this.source.getObservations()));
                        this.entries[3] = "unnamed distribution";
                        this.entries[4] = " ";
                        this.entries[5] = " ";
                        this.entries[6] = " ";
                        this.entries[7] = ('' + (this.source.getInitialSeed()));
                    }
                    else {
                        for (var i = 0; i < this.__numColumns; i++) {
                            this.entries[i] = "Invalid source!";
                        }
                        ;
                    }
                    return this.entries;
                };
                return DistributionReporter;
            }(desmoj.core.report.Reporter));
            report.DistributionReporter = DistributionReporter;
            DistributionReporter["__class"] = "desmoj.core.report.DistributionReporter";
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            /**
             * Creates a reporter for the given model. This special reporter retrieves
             * all other reporters associated to the reportable objects registered at
             * the model. These are collected in a vector, ordered by group-ID to be
             * sent to the report output when a report is required.
             *
             * @param {desmoj.core.simulator.Model} model
             * Model : The model to report about.
             * @class
             * @extends desmoj.core.report.Reporter
             * @author Tim Lechler
             */
            var ModelReporter = (function (_super) {
                __extends(ModelReporter, _super);
                function ModelReporter(model) {
                    var _this = _super.call(this, model) || this;
                    _this._reporters = null;
                    var reportables = model.getReportables();
                    _this._reporters = ([]);
                    _this.groupID = 2147483647;
                    _this.groupHeading = "Model " + _this.source.getName();
                    _this.__numColumns = 1;
                    _this.columns = new Array(_this.__numColumns);
                    _this.columns[0] = "Description";
                    _this.entries = new Array(_this.__numColumns);
                    if (reportables == null)
                        return _this;
                    if ((reportables.length == 0))
                        return _this;
                    var repoBuff;
                    for (var index762 = 0; index762 < reportables.length; index762++) {
                        var r = reportables[index762];
                        {
                            if (r != null) {
                                repoBuff = r.getReporter();
                                if (repoBuff != null) {
                                    if ((_this._reporters.length == 0)) {
                                        /* add */ (_this._reporters.push(repoBuff) > 0);
                                    }
                                    else {
                                        for (var k = 0; k < _this._reporters.length; k++) {
                                            if (desmoj.core.report.Reporter.isLarger(/* get */ _this._reporters[k], repoBuff)) {
                                                /* add */ _this._reporters.splice(k + 1, 0, repoBuff);
                                                break;
                                            }
                                        }
                                        ;
                                    }
                                }
                            }
                        }
                    }
                    return _this;
                }
                /**
                 * The ModelReporter returns the description of the model.
                 *
                 * @return {Array} java.lang.String[] : Array containing the data for reporting
                 */
                ModelReporter.prototype.getEntries = function () {
                    var m = this.source;
                    this.entries[0] = m.modelDescription();
                    return this.entries;
                };
                /**
                 * Returns a list of view of all reportable's reporters ordered by
                 * group-ID.
                 *
                 * @return {desmoj.core.report.Reporter[]} java.util.List<Reporter> : The vector containing the reporters associated
                 * to the modelreporter
                 */
                ModelReporter.prototype.getReporters = function () {
                    return (this._reporters.slice(0));
                };
                return ModelReporter;
            }(desmoj.core.report.Reporter));
            report.ModelReporter = ModelReporter;
            ModelReporter["__class"] = "desmoj.core.report.ModelReporter";
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            /**
             * Creates a QueueReporter. Note that although any Reportable is accepted
             * you should make sure that only subtypes of Queue are passed to this
             * constructor. Otherwise the number of column titles and their individual
             * headings will differ from the actual content collected by this reporter.
             *
             * @param {desmoj.core.simulator.Reportable} informationSource
             * desmoj.core.simulator.Reportable : The Queue to report about
             * @class
             * @extends desmoj.core.report.Reporter
             * @author Tim Lechler
             */
            var QueueReporter = (function (_super) {
                __extends(QueueReporter, _super);
                function QueueReporter(informationSource) {
                    var _this = _super.call(this, informationSource) || this;
                    _this.__numColumns = 12;
                    _this.columns = new Array(_this.__numColumns);
                    _this.columns[0] = "Title";
                    _this.columns[1] = "Qorder";
                    _this.columns[2] = "(Re)set";
                    _this.columns[3] = "Obs";
                    _this.columns[4] = "QLimit";
                    _this.columns[5] = "Qmax";
                    _this.columns[6] = "Qnow";
                    _this.columns[7] = "Qavg.";
                    _this.columns[8] = "Zeros";
                    _this.columns[9] = "max.Wait";
                    _this.columns[10] = "avg.Wait";
                    _this.columns[11] = "refus.";
                    _this.groupHeading = "Queues";
                    _this.groupID = 201;
                    _this.entries = new Array(_this.__numColumns);
                    return _this;
                }
                /**
                 * Returns an array of Strings each containing the data for the
                 * corresponding column in array <code>columns[]</code>. Implement this
                 * method tha an array of the same langth as the columntitles is produced
                 * containing the data at the point of time this method is called by someone
                 * else to produce up-to-date information.
                 *
                 * @return {Array} java.lang.String[] : Array containing the data for reporting
                 */
                QueueReporter.prototype.getEntries = function () {
                    if (this.source != null && this.source instanceof desmoj.core.simulator.Queue) {
                        var q = this.source;
                        this.entries[0] = this.source.getName();
                        this.entries[1] = q.getQueueStrategy();
                        this.entries[2] = this.source.resetAt().toString();
                        this.entries[3] = ('' + (this.source.getObservations()));
                        this.entries[4] = ('' + (q.getQueueLimit()));
                        if (q.getQueueLimit() === Number.MAX_VALUE) {
                            this.entries[4] = "unlimit.";
                        }
                        this.entries[5] = ('' + (q.maxLength()));
                        this.entries[6] = ('' + (q.length()));
                        this.entries[7] = ('' + (q.averageLength()));
                        this.entries[8] = ('' + (q.zeroWaits()));
                        this.entries[9] = q.maxWaitTime().toString();
                        this.entries[10] = q.averageWaitTime().toString();
                        this.entries[11] = ('' + (q.getRefused()));
                    }
                    else {
                        for (var i = 0; i < this.__numColumns; i++) {
                            this.entries[i] = "Invalid source!";
                        }
                        ;
                    }
                    return this.entries;
                };
                return QueueReporter;
            }(desmoj.core.report.Reporter));
            report.QueueReporter = QueueReporter;
            QueueReporter["__class"] = "desmoj.core.report.QueueReporter";
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            /**
             * Constructs a standrad reporter to report about the given reportable.
             * Reports produced by this standard reporter are always listed last on a
             * report output.
             *
             * @param {desmoj.core.simulator.Reportable} informationSource
             * desmoj.core.simulator.Reportable : The reportable to produce a report about
             * @class
             * @extends desmoj.core.report.Reporter
             * @author Tim Lechler
             */
            var StandardReporter = (function (_super) {
                __extends(StandardReporter, _super);
                function StandardReporter(informationSource) {
                    var _this = _super.call(this, informationSource) || this;
                    _this.groupID = -2147483648;
                    _this.groupHeading = "StandardReporter";
                    _this.__numColumns = 3;
                    _this.columns = new Array(_this.__numColumns);
                    _this.entries = new Array(_this.__numColumns);
                    _this.columns[0] = "Title";
                    _this.columns[1] = "(Re)set";
                    _this.columns[2] = "Obs";
                    return _this;
                }
                /**
                 * Returns the array of strings containing the basic information any
                 * reportable can offer.
                 *
                 * @return {Array} java.lang.String[] : The array of Strings containing all
                 * information about the reportable information source
                 */
                StandardReporter.prototype.getEntries = function () {
                    if (this.source != null) {
                        this.entries[0] = this.source.getName();
                        this.entries[1] = this.source.resetAt().toString();
                        this.entries[2] = ('' + (this.source.getObservations()));
                    }
                    else {
                        for (var i = 0; i < this.__numColumns; i++) {
                            this.entries[i] = "Invalid source!";
                        }
                        ;
                    }
                    return this.entries;
                };
                return StandardReporter;
            }(desmoj.core.report.Reporter));
            report.StandardReporter = StandardReporter;
            StandardReporter["__class"] = "desmoj.core.report.StandardReporter";
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            /**
             * Creates a new TableReporter for the given Reportable with the given title
             *
             * @param {desmoj.core.simulator.Reportable} is
             * the source of information to be displayed in the table
             * @param {string} title
             * title of the table reporter
             * @class
             * @extends desmoj.core.report.Reporter
             * @author Nicolas Knaak
             */
            var TableReporter = (function (_super) {
                __extends(TableReporter, _super);
                function TableReporter(is, title) {
                    var _this = _super.call(this, is) || this;
                    /**
                     * Header table printed before the data table stored in <tt>entryTable</tt>.
                     * This should contain additional information like e.g. the number of
                     * observations.
                     */
                    _this.header = null;
                    _this.__numRows = 0;
                    _this.entryTable = null;
                    _this._title = null;
                    _this._title = title;
                    _this.groupHeading = "Data Tables";
                    return _this;
                }
                /**
                 * Returns the header table (or null if no header should be printed in
                 * report).
                 *
                 * @return {Array} header field of the table
                 */
                TableReporter.prototype.getHeader = function () {
                    if (this.header == null)
                        return null;
                    else
                        return this.header.slice(0);
                };
                /**
                 * Returns a one-dimensional array of entries (Computed from getEntryTable()
                 * by entries[numColumns * i + j] = entryTable[i][j]).
                 *
                 * @return {Array} field of table entries
                 */
                TableReporter.prototype.getEntries = function () {
                    this.getEntryTable();
                    this.entries = new Array(this.__numRows * this.__numColumns);
                    for (var i = 0; i < this.__numRows; i++) {
                        for (var j = 0; j < this.__numColumns; j++) {
                            this.entries[this.__numColumns * i + j] = this.entryTable[i][j];
                        }
                        ;
                    }
                    ;
                    return this.entries;
                };
                /**
                 * Returns the number of rows of this table reporter.
                 *
                 * @return {number} integer number of rows
                 */
                TableReporter.prototype.numRows = function () {
                    return this.__numRows;
                };
                /**
                 * Returns the table reporter's title.
                 *
                 * @return {string} the titel as a string
                 */
                TableReporter.prototype.getTitle = function () {
                    return this._title;
                };
                return TableReporter;
            }(desmoj.core.report.Reporter));
            report.TableReporter = TableReporter;
            TableReporter["__class"] = "desmoj.core.report.TableReporter";
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            var html5chart;
            (function (html5chart) {
                /**
                 * Create an Object to represent the chart data with
                 * data values from type long and data classes from type String.
                 * @param {desmoj.core.simulator.Model} ownerModel
                 * Model : The owner model this chart data is associated to.
                 * @param {Array} strings
                 * String[] : The Strings representing the cells.
                 * @param {Array} entries
                 * Long[] : The data value of each cell.
                 * @class
                 * @extends desmoj.core.report.html5chart.AbstractChartDataTable
                 * @author Johanna Djimandjaja
                 */
                var ChartDataHistogramDouble = (function (_super) {
                    __extends(ChartDataHistogramDouble, _super);
                    function ChartDataHistogramDouble(ownerModel, strings, entries) {
                        var _this = _super.call(this) || this;
                        _this._observedStrings = null;
                        _this.ownerModel = ownerModel;
                        var numOfObs = entries.length;
                        if (numOfObs === strings.length) {
                            _this._observedStrings = strings;
                            _this.table = entries;
                        }
                        else {
                            if (numOfObs < strings.length) {
                                _this.table = entries;
                                _this._observedStrings = new Array(numOfObs);
                                for (var i = 0; i < numOfObs; i++) {
                                    _this._observedStrings[i] = strings[i];
                                }
                                ;
                            }
                            else {
                                _this._observedStrings = strings;
                                numOfObs = strings.length;
                                _this.table = new Array(numOfObs);
                                for (var i = 0; i < numOfObs; i++) {
                                    _this.table[i] = entries[i];
                                }
                                ;
                            }
                        }
                        return _this;
                    }
                    /**
                     * Returns the String at the given index.
                     * @param {number} index
                     * @return
                     * String: the String at the given index
                     * @return {string}
                     */
                    ChartDataHistogramDouble.prototype.getObservedString = function (index) {
                        if (index < 0 || index >= this._observedStrings.length)
                            return "";
                        return this._observedStrings[index];
                    };
                    return ChartDataHistogramDouble;
                }(desmoj.core.report.html5chart.AbstractChartDataTable));
                html5chart.ChartDataHistogramDouble = ChartDataHistogramDouble;
                ChartDataHistogramDouble["__class"] = "desmoj.core.report.html5chart.ChartDataHistogramDouble";
                ChartDataHistogramDouble["__interfaces"] = ["desmoj.core.report.html5chart.AbstractChartData"];
            })(html5chart = report.html5chart || (report.html5chart = {}));
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            var html5chart;
            (function (html5chart) {
                /**
                 * Create an Object to represent the chart data with
                 * data values from type long and data classes from type String.
                 * @param {desmoj.core.simulator.Model} ownerModel
                 * Model : The owner model this chart data is associated to.
                 * @param {Array} strings
                 * String[] : The Strings representing the cells.
                 * @param {Array} entries
                 * Long[] : The data value of each cell.
                 * @class
                 * @extends desmoj.core.report.html5chart.AbstractChartDataTable
                 * @author Johanna Djimandjaja
                 */
                var ChartDataHistogramLong = (function (_super) {
                    __extends(ChartDataHistogramLong, _super);
                    function ChartDataHistogramLong(ownerModel, strings, entries) {
                        var _this = _super.call(this) || this;
                        _this._observedStrings = null;
                        _this.ownerModel = ownerModel;
                        var numOfObs = entries.length;
                        if (numOfObs === strings.length) {
                            _this._observedStrings = strings;
                            _this.table = entries;
                        }
                        else {
                            if (numOfObs < strings.length) {
                                _this.table = entries;
                                _this._observedStrings = new Array(numOfObs);
                                for (var i = 0; i < numOfObs; i++) {
                                    _this._observedStrings[i] = strings[i];
                                }
                                ;
                            }
                            else {
                                _this._observedStrings = strings;
                                numOfObs = strings.length;
                                _this.table = new Array(numOfObs);
                                for (var i = 0; i < numOfObs; i++) {
                                    _this.table[i] = entries[i];
                                }
                                ;
                            }
                        }
                        return _this;
                    }
                    /**
                     * Returns the String at the given index.
                     * @param {number} index
                     * @return
                     * String: the String at the given index
                     * @return {string}
                     */
                    ChartDataHistogramLong.prototype.getObservedString = function (index) {
                        if (index < 0 || index >= this._observedStrings.length)
                            return "";
                        return this._observedStrings[index];
                    };
                    return ChartDataHistogramLong;
                }(desmoj.core.report.html5chart.AbstractChartDataTable));
                html5chart.ChartDataHistogramLong = ChartDataHistogramLong;
                ChartDataHistogramLong["__class"] = "desmoj.core.report.html5chart.ChartDataHistogramLong";
                ChartDataHistogramLong["__interfaces"] = ["desmoj.core.report.html5chart.AbstractChartData"];
            })(html5chart = report.html5chart || (report.html5chart = {}));
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            var html5chart;
            (function (html5chart) {
                /**
                 * Create an Object to represent the data for a TimeSeries.
                 *
                 * @param {desmoj.core.simulator.Model} ownerModel
                 * Model : The owner model this chart data is associated to.
                 * @param {number[]} timeValues
                 * java.util.List : List for saving the time values in the memory.
                 * @param {number[]} dataValues
                 * java.util.List : List for saving the data values in the memory.
                 * @param {number} validFrom
                 * Double : Start of the interval of the time series.
                 * @param {number} validTo
                 * Double : End of the interval of the time series.
                 * @param {string} group
                 * String : An ID to separate different plots into different diagrams, if desired.
                 * @class
                 * @extends desmoj.core.report.html5chart.AbstractChartDataTable
                 * @author Johanna Djimandjaja
                 */
                var ChartDataTimeSeries = (function (_super) {
                    __extends(ChartDataTimeSeries, _super);
                    function ChartDataTimeSeries(ownerModel, timeValues, dataValues, validFrom, validTo, group) {
                        var _this = _super.call(this) || this;
                        _this._timeValues = null;
                        _this.validFrom = null;
                        _this.validTo = null;
                        _this.group = null;
                        _this.ownerModel = ownerModel;
                        if (dataValues == null || timeValues == null) {
                            _this.table = new Array(0);
                            _this._timeValues = new Array(0);
                        }
                        else {
                            var numOfData = dataValues.length;
                            if (numOfData > timeValues.length) {
                                numOfData = timeValues.length;
                            }
                            _this.table = new Array(numOfData);
                            _this._timeValues = new Array(numOfData);
                            for (var i = 0; i < _this.table.length; i++) {
                                _this.table[i] = dataValues[i];
                                _this._timeValues[i] = timeValues[i];
                            }
                            ;
                        }
                        _this.validFrom = validFrom;
                        _this.validTo = validTo;
                        _this.group = group;
                        return _this;
                    }
                    /**
                     * Return an array of data values.
                     * @return {Array} an array of data values
                     */
                    ChartDataTimeSeries.prototype.getDataValues = function () {
                        return this.table;
                    };
                    /**
                     * Returns an array of time values.
                     * @return {Array} an array of time values
                     */
                    ChartDataTimeSeries.prototype.getTimeValues = function () {
                        return this._timeValues;
                    };
                    /**
                     * Returns the highest possible time value.
                     * @return {number} the highest possible time value
                     */
                    ChartDataTimeSeries.prototype.getValidTo = function () {
                        return this.validTo;
                    };
                    /**
                     * Returns the lowest possible time value.
                     * @return {number} the lowest possible time value
                     */
                    ChartDataTimeSeries.prototype.getValidFrom = function () {
                        return this.validFrom;
                    };
                    /**
                     * Returns the group ID value.
                     * @return {string} the group ID value
                     */
                    ChartDataTimeSeries.prototype.getGroup = function () {
                        return this.group;
                    };
                    return ChartDataTimeSeries;
                }(desmoj.core.report.html5chart.AbstractChartDataTable));
                html5chart.ChartDataTimeSeries = ChartDataTimeSeries;
                ChartDataTimeSeries["__class"] = "desmoj.core.report.html5chart.ChartDataTimeSeries";
                ChartDataTimeSeries["__interfaces"] = ["desmoj.core.report.html5chart.AbstractChartData"];
            })(html5chart = report.html5chart || (report.html5chart = {}));
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Alternative Implementation of the interface <code>EventList</code> using a
             * tree-based list as a container for the event-notes, yielding both access and
             * removal of event-list entries in O(log n) time.
             *
             * Disadvantages compared to <code>EventVector</code> include
             * non-thread-safeness (however, discrete Event simulation should never attempt
             * concurrent modifications of the event-list) and the slightly higher memory
             * requirement.
             *
             * The internal tree-based list is provided by the class
             * <code>org.apache.commons.collections.list.TreeList</code> from the Commons
             * Collections package from the Apache Jakarta Commons Project (see
             * http://jakarta.apache.org/commons/index.html). Thus, his product includes
             * software developed by The Apache Software Foundation
             * (http://www.apache.org/). For License see
             * http://www.apache.org/licenses/LICENSE-2.0 (of which a copy can be found in
             * the root directory of this distribtuon).
             *
             * @see org.apache.commons.collections.list.TreeList
             * @see EventVectorList
             * @see EventNote
             *
             * @version DESMO-J, Ver. 2.5.1e copyright (c) 2017
             * @author Tim Lechler, Ruth Meyer, modified by Johannes Gbel
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License. You
             * may obtain a copy of the License at
             * http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS"
             * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
             * or implied. See the License for the specific language governing
             * permissions and limitations under the License.
             * @extends desmoj.core.simulator.EventList
             * @class
             */
            var EventTreeList = (function (_super) {
                __extends(EventTreeList, _super);
                function EventTreeList() {
                    var _this = _super.call(this) || this;
                    _this.eTreeList = null;
                    _this.eTreeList = ([]);
                    return _this;
                }
                /**
                 * Returns the first event-note in the event-list. It is the event-note with
                 * the lowest (nearest) associated point of simulation time of all
                 * Event notes contained in the evnet-list. Note that the event-note is not
                 * removed from the event-list.
                 *
                 * @return {desmoj.core.simulator.EventNote} EventNote : the event-note to be processed next in the order of
                 * time. Returns <code>null</code> if the event-list is empty.
                 */
                EventTreeList.prototype.firstNote = function () {
                    if (this.isEmpty())
                        return null;
                    else
                        return this.eTreeList[0];
                };
                /**
                 * Inserts the new event-note preserving the temporal order of the event-notes
                 * contained in the event-list. It uses binary search to determine the
                 * position where to insert the new event-note to increase performance.
                 *
                 * @param {desmoj.core.simulator.EventNote} newNote
                 * EventNote : the new note to be inserted in the event-list
                 * keeping the temporal order
                 */
                EventTreeList.prototype.insert = function (newNote) {
                    var who1 = newNote.getEntity1();
                    if (who1 != null) {
                        who1.addEventNote(newNote);
                    }
                    var who2 = newNote.getEntity2();
                    if (who2 != null) {
                        who2.addEventNote(newNote);
                    }
                    var who3 = newNote.getEntity3();
                    if (who3 != null) {
                        who3.addEventNote(newNote);
                    }
                    var Event = newNote.getEvent();
                    if (Event != null) {
                        Event.addEventNote(newNote);
                    }
                    if (this.isEmpty()) {
                        /* add */ (this.eTreeList.push(newNote) > 0);
                        return;
                    }
                    else {
                        var left = 0;
                        var right = this.eTreeList.length - 1;
                        var index = 0;
                        var refTime = newNote.getTime();
                        var refPrio = newNote.getPriority();
                        do {
                            index = ((left + right) / 2 | 0);
                            if (desmoj.core.simulator.TimeInstant.isBefore(this.eTreeList[index].getTime(), refTime) || (desmoj.core.simulator.TimeInstant.isEqual(this.eTreeList[index].getTime(), refTime) && this.eTreeList[index].getPriority() >= refPrio)) {
                                if (index < (this.eTreeList.length - 1)) {
                                    if (desmoj.core.simulator.TimeInstant.isAfter(this.eTreeList[index + 1].getTime(), refTime) || (desmoj.core.simulator.TimeInstant.isEqual(this.eTreeList[index + 1].getTime(), refTime) && this.eTreeList[index].getPriority() < refPrio)) {
                                        /* add */ this.eTreeList.splice(index + 1, 0, newNote);
                                        return;
                                    }
                                    else {
                                        left = index + 1;
                                    }
                                }
                                else {
                                    /* add */ (this.eTreeList.push(newNote) > 0);
                                    return;
                                }
                            }
                            else {
                                if (index > 0) {
                                    if (desmoj.core.simulator.TimeInstant.isBefore(this.eTreeList[index - 1].getTime(), refTime) || (desmoj.core.simulator.TimeInstant.isEqual(this.eTreeList[index - 1].getTime(), refTime) && this.eTreeList[index - 1].getPriority() >= refPrio)) {
                                        /* add */ this.eTreeList.splice(index, 0, newNote);
                                        return;
                                    }
                                    else {
                                        right = index - 1;
                                    }
                                }
                                else {
                                    /* add */ this.eTreeList.splice(0, 0, newNote);
                                    return;
                                }
                            }
                        } while (((left <= right)));
                        /* add */ (this.eTreeList.push(newNote) > 0);
                    }
                };
                /**
                 * Inserts a new event-note after another EventNote specified. Note that to
                 * keep the temporal order of the event-list, the scheduled time will be set
                 * to the same time as the referred "afterNote". Note also, that afterNote
                 * must be contained in the event-list. If the referred "where" is not
                 * contained in the event-list, there is no chance to determine the time
                 * that the new note is intended to be scheduled at. Thus the new event-note
                 * will not be inserted and a <code>EventNotScheduledException</code> will
                 * be thrown, stopping the simulation.
                 *
                 * @param {desmoj.core.simulator.EventNote} where
                 * EventNote : The event-note containing the event after which the
                 * new note is supposed to be inserted into the event-list.
                 * @param {desmoj.core.simulator.EventNote} newNote
                 * EventNote : The new event-note to be inserted after the
                 * specified EventNote in the event-list.
                 * @throws SimAbortedException
                 * : if referred EventNote is not contained in the event-list
                 */
                EventTreeList.prototype.insertAfter = function (where, newNote) {
                    var who1 = newNote.getEntity1();
                    if (who1 != null) {
                        who1.addEventNote(newNote);
                    }
                    var who2 = newNote.getEntity2();
                    if (who2 != null) {
                        who2.addEventNote(newNote);
                    }
                    var who3 = newNote.getEntity3();
                    if (who3 != null) {
                        who3.addEventNote(newNote);
                    }
                    var Event = newNote.getEvent();
                    if (Event != null) {
                        Event.addEventNote(newNote);
                    }
                    var i = this.eTreeList.indexOf(where);
                    if (i < 0) {
                        var mBuffer = null;
                        if (newNote.getEntity1() != null) {
                            mBuffer = newNote.getEntity1().getModel();
                        }
                        if (newNote.getEvent() != null) {
                            mBuffer = newNote.getEvent().getModel();
                        }
                        throw new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(mBuffer, "Can not insert new event-note after given EventNote! Simulation aborted", "Internal DESMO-J class : EventTreeList Method : insertAfter(EventNote where, EventNote newNote)", "The event-note to insert the new note after is not contained in the event tree list.", "This is a fatal error. Contact DESMOJ support", newNote.getTime()));
                    }
                    else {
                        newNote.setTime(where.getTime());
                        /* add */ this.eTreeList.splice(i + 1, 0, newNote);
                    }
                };
                /**
                 * Inserts the given EventNote at the first position in the event-list. The
                 * Event encapsulated in that EventNote will probably be the next event to
                 * be processed by the scheduler (unless some other calls to this method are
                 * made before). Note that for consistency the time of the new event-note
                 * is set to the time of the next entry, if the time of the next entry is earlier.
                 *
                 * @param {desmoj.core.simulator.EventNote} newNote
                 * EventNote : The event-note to be inserted at the first position
                 * in the event-list.
                 */
                EventTreeList.prototype.insertAsFirst = function (newNote) {
                    if (!this.isEmpty()) {
                        var next = this.eTreeList[0].getTime();
                        if (desmoj.core.simulator.TimeInstant.isBefore(next, newNote.getTime())) {
                            newNote.setTime(next);
                        }
                    }
                    /* add */ this.eTreeList.splice(0, 0, newNote);
                    var who1 = newNote.getEntity1();
                    if (who1 != null) {
                        who1.addEventNote(newNote);
                    }
                    var who2 = newNote.getEntity2();
                    if (who2 != null) {
                        who2.addEventNote(newNote);
                    }
                    var who3 = newNote.getEntity3();
                    if (who3 != null) {
                        who3.addEventNote(newNote);
                    }
                    var Event = newNote.getEvent();
                    if (Event != null) {
                        Event.addEventNote(newNote);
                    }
                };
                /**
                 * Inserts a new event-note before another EventNote specified. Note that
                 * this could disturb the temporal order of the event-list. So this method
                 * should only be used carefully. Note also, that EventNote 'where' must be
                 * contained in the event-list or otherwise an exception will be thrown.
                 *
                 * @param {desmoj.core.simulator.EventNote} where
                 * EventNote : The event-note containing the event before which
                 * the newNote is supposed to be inserted into the event-list.
                 * @param {desmoj.core.simulator.EventNote} newNote
                 * EventNote : The new event-note to be inserted before the
                 * specified EventNote in the event-list
                 * @throws SimAbortedException
                 * : if referred EventNote is not contained in the event-list
                 */
                EventTreeList.prototype.insertBefore = function (where, newNote) {
                    var who1 = newNote.getEntity1();
                    if (who1 != null) {
                        who1.addEventNote(newNote);
                    }
                    var who2 = newNote.getEntity2();
                    if (who2 != null) {
                        who2.addEventNote(newNote);
                    }
                    var who3 = newNote.getEntity3();
                    if (who3 != null) {
                        who3.addEventNote(newNote);
                    }
                    var Event = newNote.getEvent();
                    if (Event != null) {
                        Event.addEventNote(newNote);
                    }
                    var i = this.eTreeList.indexOf(where);
                    if (i < 0) {
                        var mBuffer = null;
                        if (newNote.getEntity1() != null) {
                            mBuffer = newNote.getEntity1().getModel();
                        }
                        if (newNote.getEvent() != null) {
                            mBuffer = newNote.getEvent().getModel();
                        }
                        throw new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(mBuffer, "Can not insert new event-note before given EventNote! Simulation aborted", "Internal DESMO-J class : EventTreeList Method : insertBefore(EventNote where, EventNote newNote)", "The event-note to insert the new note before is not contained in the event tree list.", "This is a fatal error. Contact DESMOJ support", newNote.getTime()));
                    }
                    else {
                        newNote.setTime(where.getTime());
                        /* add */ this.eTreeList.splice(i, 0, newNote);
                    }
                };
                /**
                 * Tests if there are any scheduled events contained in the event-list. If
                 * the event-list happens to be empty during the run of a simulation, this
                 * is a criterium to stop the simulation, since no further action is
                 * scheduled.
                 *
                 * @return {boolean} boolean : True if there are no Event notes contained in the
                 * event-list, false otherwise.
                 */
                EventTreeList.prototype.isEmpty = function () {
                    return (this.eTreeList.length == 0);
                };
                /**
                 * Returns the last EventNote in the event-list. If the event-list is empty,
                 * <code>null</code> will be returned.
                 *
                 * @return {desmoj.core.simulator.EventNote} EventNote : the last EventNote in the event-list, null if the
                 * event-list is empty
                 */
                EventTreeList.prototype.lastNote = function () {
                    if (this.isEmpty())
                        return null;
                    else
                        return this.eTreeList[this.eTreeList.length - 1];
                };
                /**
                 * Returns the next event-note in the event-list relative to the given
                 * EventNote. If the given EventNote is not contained in the event-list or
                 * happens to be the last EventNote in the event-list, null will be
                 * returned.
                 *
                 * @return {desmoj.core.simulator.EventNote} EventNote : The event-note following the given EventNote or
                 * <ocde>null</code> if the given EventNote was last or not found
                 * @param {desmoj.core.simulator.EventNote} origin
                 * EventNote : The event-note whose successor is wanted
                 */
                EventTreeList.prototype.nextNote = function (origin) {
                    if ((this.eTreeList.indexOf((origin)) >= 0)) {
                        if (origin === this.eTreeList[this.eTreeList.length - 1]) {
                            return null;
                        }
                        else
                            return this.eTreeList[this.eTreeList.indexOf(origin) + 1];
                    }
                    return null;
                };
                /**
                 * Returns the previous EventNote in the event-list relative to the given
                 * EventNote. If the given EventNote is not contained in the event-list or
                 * happens to be the first event-note in the event-list, null will be
                 * returned.
                 *
                 * @return {desmoj.core.simulator.EventNote} EventNote : The event-note following the given EventNote or
                 * <ocde>null</code> if the given EventNote was first or not found
                 * @param {desmoj.core.simulator.EventNote} origin
                 * EventNote : The event-note whose predecessor is wanted
                 */
                EventTreeList.prototype.prevNote = function (origin) {
                    if ((this.eTreeList.indexOf((origin)) >= 0)) {
                        if (origin === this.eTreeList[0]) {
                            return null;
                        }
                        return this.eTreeList[this.eTreeList.indexOf(origin) - 1];
                    }
                    return null;
                };
                /**
                 * Removes the given EventNote from the event-list.
                 *
                 * Warning: Make sure to tell the entity of the event-note to delete
                 * the Note from its List as well.
                 *
                 * Warning: Make sure to tell the entity of the event-note to delete
                 * the Note from its List as well.
                 *
                 * @param {desmoj.core.simulator.EventNote} note
                 * EventNote : The event-note to be removed from the event-list
                 */
                EventTreeList.prototype.remove = function (note) {
                    var pos = this.eTreeList.indexOf(note);
                    if (pos === -1)
                        return;
                    else {
                        /* remove */ this.eTreeList.splice(pos, 1);
                        if (note.getEntity1() != null) {
                            note.getEntity1().removeEventNote(note);
                        }
                        if (note.getEntity2() != null) {
                            note.getEntity2().removeEventNote(note);
                        }
                        if (note.getEntity3() != null) {
                            note.getEntity3().removeEventNote(note);
                        }
                        if (note.getEvent() != null) {
                            note.getEvent().removeEventNote(note);
                        }
                    }
                };
                /**
                 * Removes the first event-note from the event-list. Does nothing if the
                 * event-list is already empty.
                 * @return {desmoj.core.simulator.EventNote}
                 */
                EventTreeList.prototype.removeFirst = function () {
                    if (!(this.eTreeList.length == 0)) {
                        var noteObject = this.eTreeList.splice(0, 1);
                        var note = noteObject;
                        if (note.getEntity1() != null) {
                            note.getEntity1().removeEventNote(note);
                        }
                        if (note.getEntity2() != null) {
                            note.getEntity2().removeEventNote(note);
                        }
                        if (note.getEntity3() != null) {
                            note.getEntity3().removeEventNote(note);
                        }
                        if (note.getEvent() != null) {
                            note.getEvent().removeEventNote(note);
                        }
                        return note;
                    }
                    return null;
                };
                /**
                 * Returns a string representing the entries of this tree list in a row. The
                 * resulting string includes all Event notes in ascending order as they are
                 * placed inside the event tree list.
                 * @return {string}
                 */
                EventTreeList.prototype.toString = function () {
                    var textBuffer = { str: "", toString: function () { return this.str; } };
                    var notes = (function (a) { var i = 0; return { next: function () { return i < a.length ? a[i++] : null; }, hasNext: function () { return i < a.length; } }; })(this.eTreeList);
                    while ((notes.hasNext())) {
                        /* append */ (function (sb) { return sb.str = sb.str.concat("["); })(textBuffer);
                        /* append */ (function (sb) { return sb.str = sb.str.concat(notes.next()); })(textBuffer);
                        /* append */ (function (sb) { return sb.str = sb.str.concat("]"); })(textBuffer);
                    }
                    ;
                    return textBuffer.str;
                };
                /**
                 * Returns if the event-list processes concurrent Events in random order or
                 * not.
                 *
                 * @return {boolean} boolean: <code>false</code> since no randomization
                 */
                EventTreeList.prototype.isRandomizingConcurrentEvents = function () {
                    return false;
                };
                return EventTreeList;
            }(desmoj.core.simulator.EventList));
            simulator.EventTreeList = EventTreeList;
            EventTreeList["__class"] = "desmoj.core.simulator.EventTreeList";
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var dist;
        (function (dist_1) {
            /**
             * Creates a new distributionManager with the given name and the given
             * initial seed for the seed-generator.
             *
             * @param {string} name
             * java.lang.String : The distributionmanager's name
             * @param {number} seed
             * long : The initial seed for the seedgenerator
             * @class
             * @extends desmoj.core.simulator.NamedObject
             * @author Tim Lechler
             */
            var DistributionManager = (function (_super) {
                __extends(DistributionManager, _super);
                function DistributionManager(name, seed) {
                    var _this = _super.call(this, name + "_DistributionManager") || this;
                    _this._currentDefaultGenerator = null;
                    _this._antitheticMode = false;
                    _this._distributions = null;
                    _this._seedGenerator = null;
                    _this._seed = 0;
                    _this._antitheticMode = false;
                    _this._seedGenerator = new def.MersenneTwisterRandomGeneratorJS(seed);
                    _this._currentDefaultGenerator = def.MersenneTwisterRandomGeneratorJS;
                    _this._distributions = ([]);
                    _this._seed = seed;
                    return _this;
                }
                /**
                 * De-registers a distribution from the experiment.
                 *
                 * @param {desmoj.core.dist.Distribution} dist
                 * desmoj.dist.Distribution : The distribution to be deregistered
                 */
                DistributionManager.prototype.deRegister = function (dist) {
                    /* remove */ (function (a) { return a.splice(a.indexOf(dist), 1); })(this._distributions);
                };
                /**
                 * Provides all registered distributions with new seed values, thus
                 * resetting all distribution statistics at the same time.
                 */
                DistributionManager.prototype.newSeedAll = function () {
                    for (var index763 = 0; index763 < this._distributions.length; index763++) {
                        var d = this._distributions[index763];
                        {
                            d.setSeed(this.nextSeed());
                        }
                    }
                };
                /**
                 * Returns a new seed value to be used as an initial seed for registered
                 * distributions.
                 *
                 * @return {number} long : A new seed value for a registered distribution
                 */
                DistributionManager.prototype.nextSeed = function () {
                    return Math.floor((this._seedGenerator.nextDouble() * 100000000));
                };
                /**
                 * Registers a new distribution at the experiment to control antithetic mode
                 * and set random seed values.
                 *
                 * @param {desmoj.core.dist.Distribution} dist
                 * desmoj.dist.Distribution : The distribution to be registered
                 */
                DistributionManager.prototype.register = function (dist) {
                    dist.setAntithetic(this._antitheticMode);
                    dist.setSeed(this.nextSeed());
                    /* add */ (this._distributions.push(dist) > 0);
                };
                /**
                 * Resets all registered distributions. Just calls all distribution's
                 * individual reset method.
                 */
                DistributionManager.prototype.resetAll = function () {
                    for (var index764 = 0; index764 < this._distributions.length; index764++) {
                        var d = this._distributions[index764];
                        {
                            d.reset();
                        }
                    }
                };
                /**
                 * Sets antithetic mode to true on all registered distributions regardless
                 * of their previous status. No reset of statistical counters.
                 *
                 * @param {boolean} antitheticMode
                 * boolean : The new status of antithetic mode
                 */
                DistributionManager.prototype.setAntitheticAll = function (antitheticMode) {
                    for (var index765 = 0; index765 < this._distributions.length; index765++) {
                        var d = this._distributions[index765];
                        {
                            d.setAntithetic(antitheticMode);
                        }
                    }
                };
                /**
                 * Sets the seed of the SeedGenerator to the given value. If the seed is not
                 * set here, its default is zero, unless specified in the experimentoptions.
                 *
                 * @param {number} newSeed
                 * long : The new seed for the seedgenerator
                 */
                DistributionManager.prototype.setSeed = function (newSeed) {
                    this._seed = newSeed;
                    this._seedGenerator.setSeed(newSeed);
                };
                /**
                 * Returns the initial seed.
                 *
                 * @return {number} long : the initial seed
                 */
                DistributionManager.prototype.getSeed = function () {
                    return this._seed;
                };
                /**
                 * Sets the underlying pseudo random number generator to be used by all
                 * distributions created from now on. The default generator is
                 * LinearCongruentialRandomGenerator; any other generator to be used must
                 * implement the interface UniformRandomGenerator.
                 *
                 * @see desmoj.core.dist.LinearCongruentialRandomGenerator
                 * @see desmoj.core.dist.UniformRandomGenerator
                 *
                 * @param {*} randomNumberGenerator
                 * Class : The random number generator class to be used
                 */
                DistributionManager.prototype.setRandomNumberGenerator = function (randomNumberGenerator) {
                    this._currentDefaultGenerator = randomNumberGenerator;
                };
                /**
                 * Returns the underlying pseudo random number generator to be used by all
                 * distributions. This method is intended for internal use (i.e. called by
                 * Distribution) only.
                 *
                 * @see desmoj.core.dist.LinearCongruentialRandomGenerator
                 * @see desmoj.core.dist.MersenneTwisterRandomGenerator
                 * @see desmoj.core.dist.UniformRandomGenerator
                 *
                 * @return {*}
                 */
                DistributionManager.prototype.getRandomNumberGenerator = function () {
                    return this._currentDefaultGenerator;
                };
                /**
                 * Returns a list containing all distributions.
                 * @return {desmoj.core.dist.Distribution[]}
                 */
                DistributionManager.prototype.getDistributions = function () {
                    return (this._distributions.slice(0));
                };
                return DistributionManager;
            }(desmoj.core.simulator.NamedObject));
            dist_1.DistributionManager = DistributionManager;
            DistributionManager["__class"] = "desmoj.core.dist.DistributionManager";
        })(dist = core.dist || (core.dist = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            /**
             * Creates a new reportmanager with the given name.
             *
             * @param {string} name
             * java.lang.String : the reportmanager's name
             * @class
             * @extends desmoj.core.simulator.NamedObject
             * @author Tim Lechler
             */
            var ReportManager = (function (_super) {
                __extends(ReportManager, _super);
                function ReportManager(name) {
                    var _this = _super.call(this, name + "_ReportManager") || this;
                    _this._reporters = null;
                    _this._reporters = ([]);
                    return _this;
                }
                /**
                 * Adds a report to the very end of the vector hanlded by this
                 * reportmanager. This is needed to place submodel reporters behind existing
                 * model reporters to prevent multiple models to be mixed.
                 *
                 * @param {desmoj.core.report.Reporter} r
                 * desmoj.report.Reporter
                 */
                ReportManager.prototype.addLast = function (r) {
                    if (r == null)
                        return;
                    else
                        (this._reporters.push(r) > 0);
                };
                /**
                 * De-registers the given reporter from the experiment's reportmanager. The
                 * reporter will be removed from the list of current available reporters and
                 * thus will not produce output whenever a report has to be produced. When
                 * de-registering, the order according to group-ID is preserved. If an
                 * invalid parameter is given (i.e. a <code>null</code> reference) this
                 * method simply returns
                 *
                 * @param {desmoj.core.report.Reporter} rep
                 * desmoj.report.Reporter : The reporter to be de-registered
                 */
                ReportManager.prototype.deRegister = function (rep) {
                    if (rep == null)
                        return;
                    /* remove */ (function (a) { return a.splice(a.indexOf(rep), 1); })(this._reporters);
                };
                /**
                 * Returns a list view of all registered reporters in the appropriate
                 * order.
                 *
                 * @return {desmoj.core.report.Reporter[]} java.util.List : The list of reporters
                 * registered at the reportmanager
                 */
                ReportManager.prototype.elements = function () {
                    return (this._reporters.slice(0));
                };
                /**
                 * Returns a boolean value indicating whether this reportmanager contains
                 * reporters to be sent to the reportoutput or not.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if the reportmanager conatains
                 * reporters, <code>false</code> otherwise
                 */
                ReportManager.prototype.isEmpty = function () {
                    return (this._reporters.length == 0);
                };
                /**
                 * Registers the given reporter at the experiment's reportmanager. All
                 * reporters registered will be sent to the reportout whenever a report has
                 * to be produced. When registering, the order according to group-ID is
                 * preserved.
                 *
                 * @param {desmoj.core.report.Reporter} rep
                 * desmoj.report.Reporter : The reporter to be registered
                 */
                ReportManager.prototype.register = function (rep) {
                    if (rep == null)
                        return;
                    if ((this._reporters.indexOf((rep)) >= 0))
                        return;
                    if ((this._reporters.length == 0))
                        (this._reporters.push(rep) > 0);
                    else {
                        for (var i = 0; i < this._reporters.length; i++) {
                            if (desmoj.core.report.Reporter.isLarger(rep, /* get */ this._reporters[i])) {
                                /* add */ this._reporters.splice(i, 0, rep);
                                return;
                            }
                        }
                        ;
                        /* add */ (this._reporters.push(rep) > 0);
                    }
                };
                return ReportManager;
            }(desmoj.core.simulator.NamedObject));
            report.ReportManager = ReportManager;
            ReportManager["__class"] = "desmoj.core.report.ReportManager";
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            var html5chart;
            (function (html5chart) {
                /**
                 * Create a canvas.
                 *
                 * @param {string} canvasID
                 * The ID of this canvas.
                 * @param {number} canvasHeight
                 * The height of this canvas.<br>
                 * Should be larger then <code>this.getTopGap() + this.getBottomGap() + 100</code>.
                 * @param {number} canvasWidth
                 * The width of this canvas.<br>
                 * Should be larger then <code>this.getLeftGap() + this.getRightGap() + 100</code>.
                 *
                 * @class
                 * @extends desmoj.core.simulator.NamedObject
                 * @author Johanna Djimandjaja
                 */
                var AbstractNumericalChartCanvas = (function (_super) {
                    __extends(AbstractNumericalChartCanvas, _super);
                    function AbstractNumericalChartCanvas(canvasID, canvasHeight, canvasWidth) {
                        var _this = _super.call(this, canvasID) || this;
                        /**
                         * An array containing the gaps between the canvas border and the actual chart.
                         * [top gap, right gap, bottom gap, left gap]
                         */
                        /*private*/ _this._borderGap = [20, 20, 50, 60];
                        /**
                         * Color used for drawing the scales.
                         */
                        /*private*/ _this._lightGrey = new def.Color(190, 190, 190);
                        /**
                         * Color used for drawing the borders and the axis.
                         */
                        /*private*/ _this._black = new def.Color(0, 0, 0);
                        _this._canvasHeight = 0;
                        _this._canvasWidth = 0;
                        if (canvasHeight > 270)
                            _this._canvasHeight = canvasHeight;
                        else
                            _this._canvasHeight = 270;
                        if (canvasWidth > 400)
                            _this._canvasWidth = canvasWidth;
                        else
                            _this._canvasWidth = 400;
                        return _this;
                    }
                    /**
                     * Gets the height of the canvas.
                     *
                     * @return
                     * int : The height of the canvas.
                     * @return {number}
                     */
                    AbstractNumericalChartCanvas.prototype.getCanvasHeight = function () {
                        return this._canvasHeight;
                    };
                    /**
                     * Gets the width of the canvas.
                     * @return
                     * int : The width of the canvas.
                     * @return {number}
                     */
                    AbstractNumericalChartCanvas.prototype.getCanvasWidth = function () {
                        return this._canvasWidth;
                    };
                    /**
                     *
                     * @return {string}
                     */
                    AbstractNumericalChartCanvas.prototype.getCanvasID = function () {
                        return _super.prototype.getName.call(this);
                    };
                    /**
                     *
                     * @return {number}
                     */
                    AbstractNumericalChartCanvas.prototype.getChartHeight = function () {
                        return this._canvasHeight - this.getTopGap() - this.getBottomGap();
                    };
                    /**
                     *
                     * @return {number}
                     */
                    AbstractNumericalChartCanvas.prototype.getChartWidth = function () {
                        return this._canvasWidth - this.getLeftGap() - this.getRightGap();
                    };
                    /**
                     * Returns the color for the canvas border and the axis.
                     *
                     * @return
                     * @return {def.Color}
                     */
                    AbstractNumericalChartCanvas.prototype.getDefaultColor = function () {
                        return this._black;
                    };
                    /**
                     * Returns the color for the scales in the y-axis.
                     *
                     * @return {def.Color} java.awt.Color : The color for the scales in the y-axis.
                     */
                    AbstractNumericalChartCanvas.prototype.getScaleLineColor = function () {
                        return this._lightGrey;
                    };
                    /**
                     * Returns the gap between the top border of the canvas and the chart.
                     *
                     * @return {number}
                     * int : Gap between the top border of the canvas and the chart.
                     */
                    AbstractNumericalChartCanvas.prototype.getTopGap = function () {
                        return this._borderGap[0];
                    };
                    /**
                     * Returns the gap between the right border of the canvas and the chart.
                     *
                     * @return {number}
                     * int : Gap between the right border of the canvas and the chart.
                     */
                    AbstractNumericalChartCanvas.prototype.getRightGap = function () {
                        return this._borderGap[1];
                    };
                    /**
                     * Returns the gap between the bottom border of the canvas and the chart.
                     *
                     * @return {number}
                     * int : Gap between the bottom border of the canvas and the chart.
                     */
                    AbstractNumericalChartCanvas.prototype.getBottomGap = function () {
                        return this._borderGap[2];
                    };
                    /**
                     * Returns the gap between the left border of the canvas and the chart.
                     *
                     * @return {number}
                     * int : Gap between the left border of the canvas and the chart.
                     */
                    AbstractNumericalChartCanvas.prototype.getLeftGap = function () {
                        return this._borderGap[3];
                    };
                    return AbstractNumericalChartCanvas;
                }(desmoj.core.simulator.NamedObject));
                html5chart.AbstractNumericalChartCanvas = AbstractNumericalChartCanvas;
                AbstractNumericalChartCanvas["__class"] = "desmoj.core.report.html5chart.AbstractNumericalChartCanvas";
                AbstractNumericalChartCanvas["__interfaces"] = ["desmoj.core.report.html5chart.Canvas", "desmoj.core.report.html5chart.CanvasCoordinateChart"];
            })(html5chart = report.html5chart || (report.html5chart = {}));
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Constructs a new Experiment with the given parameters. Experiment name, output path, time format,
             * can be specified. Same holds for file output channels, though this constructor assumes a single file type per output channel.
             *
             * @param {string} name
             * String : The name of the experiment determining the
             * outputfile's names, too. So please avoid characters that your
             * local filesystem does not support in filenames.
             * @param {string} pathName
             * java.lang.String : The output path for report files
             * @param {*} formatter
             * desmoj.core.simulator.TimeFormatter: Defines how time values
             * will be formatted in the output files.
             * @param {string} reportOutputType
             * @param {string} traceOutputType
             * @param {string} errorOutputType
             * @param {string} debugOutputType
             * @class
             * @extends desmoj.core.simulator.NamedObject
             * @author Tim Lechler
             */
            var Experiment = (function (_super) {
                __extends(Experiment, _super);
                function Experiment(name, pathName, formatter, reportOutputType, traceOutputType, errorOutputType, debugOutputType) {
                    var _this = this;
                    if (((typeof name === 'string') || name === null) && ((typeof pathName === 'string') || pathName === null) && ((formatter != null && (formatter["__interfaces"] != null && formatter["__interfaces"].indexOf("desmoj.core.simulator.TimeFormatter") >= 0 || formatter.constructor != null && formatter.constructor["__interfaces"] != null && formatter.constructor["__interfaces"].indexOf("desmoj.core.simulator.TimeFormatter") >= 0)) || formatter === null) && ((typeof reportOutputType === 'string') || reportOutputType === null) && ((typeof traceOutputType === 'string') || traceOutputType === null) && ((typeof errorOutputType === 'string') || errorOutputType === null) && ((typeof debugOutputType === 'string') || debugOutputType === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        _this = _super.call(this, name) || this;
                        _this._error = false;
                        _this._silent = false;
                        _this._status = 0;
                        _this._client = null;
                        _this.clientScheduler = null;
                        _this._distMan = null;
                        _this._messMan = null;
                        _this._registryOutputType = null;
                        _this._registryFileOutput = null;
                        _this._stopConditions = null;
                        _this._showProgressBar = false;
                        _this._showProgressBarAutoclose = false;
                        _this._pathName = null;
                        _this._realTimeStartTime = 0;
                        _this._debugOutput = null;
                        _this._reportOutput = null;
                        _this._errorOutput = null;
                        _this._traceOutput = null;
                        _this._interruptingException = null;
                        _this._nameCatalog = new desmoj.core.simulator.NameCatalog();
                        _this._description = null;
                        _this._stopTime = null;
                        _this._stopTimeEvent = null;
                        _this._delayInMillis = 0;
                        _this._error = false;
                        _this._silent = false;
                        _this._status = 0;
                        _this._client = null;
                        _this.clientScheduler = null;
                        _this._distMan = null;
                        _this._messMan = null;
                        _this._registryOutputType = null;
                        _this._registryFileOutput = null;
                        _this._stopConditions = null;
                        _this._showProgressBar = false;
                        _this._showProgressBarAutoclose = false;
                        _this._pathName = null;
                        _this._realTimeStartTime = 0;
                        _this._debugOutput = null;
                        _this._reportOutput = null;
                        _this._errorOutput = null;
                        _this._traceOutput = null;
                        _this._interruptingException = null;
                        (function () {
                            var reportOutputs = ([]);
                            if (reportOutputType != null)
                                (reportOutputs.push(reportOutputType) > 0);
                            var traceOutputs = ([]);
                            if (traceOutputType != null)
                                (traceOutputs.push(traceOutputType) > 0);
                            var errorOutputs = ([]);
                            if (errorOutputType != null)
                                (errorOutputs.push(errorOutputType) > 0);
                            var debugOutputs = ([]);
                            if (debugOutputType != null)
                                (debugOutputs.push(debugOutputType) > 0);
                            _this.setupExperiment(name, pathName, formatter, reportOutputs, traceOutputs, errorOutputs, debugOutputs);
                        })();
                    }
                    else if (((typeof name === 'string') || name === null) && ((typeof pathName === 'string') || pathName === null) && ((formatter != null && (formatter["__interfaces"] != null && formatter["__interfaces"].indexOf("desmoj.core.simulator.TimeFormatter") >= 0 || formatter.constructor != null && formatter.constructor["__interfaces"] != null && formatter.constructor["__interfaces"].indexOf("desmoj.core.simulator.TimeFormatter") >= 0)) || formatter === null) && ((reportOutputType != null && (reportOutputType instanceof Array)) || reportOutputType === null) && ((traceOutputType != null && (traceOutputType instanceof Array)) || traceOutputType === null) && ((errorOutputType != null && (errorOutputType instanceof Array)) || errorOutputType === null) && ((debugOutputType != null && (debugOutputType instanceof Array)) || debugOutputType === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        var outputPath_1 = __args[1];
                        var reportOutputs_1 = __args[3];
                        var traceOutputs_1 = __args[4];
                        var errorOutputs_1 = __args[5];
                        var debugOutputs_1 = __args[6];
                        _this = _super.call(this, name) || this;
                        _this._error = false;
                        _this._silent = false;
                        _this._status = 0;
                        _this._client = null;
                        _this.clientScheduler = null;
                        _this._distMan = null;
                        _this._messMan = null;
                        _this._registryOutputType = null;
                        _this._registryFileOutput = null;
                        _this._stopConditions = null;
                        _this._showProgressBar = false;
                        _this._showProgressBarAutoclose = false;
                        _this._pathName = null;
                        _this._realTimeStartTime = 0;
                        _this._debugOutput = null;
                        _this._reportOutput = null;
                        _this._errorOutput = null;
                        _this._traceOutput = null;
                        _this._interruptingException = null;
                        _this._nameCatalog = new desmoj.core.simulator.NameCatalog();
                        _this._description = null;
                        _this._stopTime = null;
                        _this._stopTimeEvent = null;
                        _this._delayInMillis = 0;
                        _this._error = false;
                        _this._silent = false;
                        _this._status = 0;
                        _this._client = null;
                        _this.clientScheduler = null;
                        _this._distMan = null;
                        _this._messMan = null;
                        _this._registryOutputType = null;
                        _this._registryFileOutput = null;
                        _this._stopConditions = null;
                        _this._showProgressBar = false;
                        _this._showProgressBarAutoclose = false;
                        _this._pathName = null;
                        _this._realTimeStartTime = 0;
                        _this._debugOutput = null;
                        _this._reportOutput = null;
                        _this._errorOutput = null;
                        _this._traceOutput = null;
                        _this._interruptingException = null;
                        (function () {
                            _this.setupExperiment(name, outputPath_1, formatter, reportOutputs_1, traceOutputs_1, errorOutputs_1, debugOutputs_1);
                        })();
                    }
                    else if (((typeof name === 'string') || name === null) && ((typeof pathName === 'string') || pathName === null) && ((typeof formatter === 'string') || formatter === null) && ((typeof reportOutputType === 'string') || reportOutputType === null) && ((typeof traceOutputType === 'string') || traceOutputType === null) && ((typeof errorOutputType === 'string') || errorOutputType === null) && debugOutputType === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        var reportOutputType_1 = __args[2];
                        var traceOutputType_1 = __args[3];
                        var errorOutputType_1 = __args[4];
                        var debugOutputType_1 = __args[5];
                        {
                            var __args_10 = Array.prototype.slice.call(arguments);
                            var formatter_1 = null;
                            _this = _super.call(this, name) || this;
                            _this._error = false;
                            _this._silent = false;
                            _this._status = 0;
                            _this._client = null;
                            _this.clientScheduler = null;
                            _this._distMan = null;
                            _this._messMan = null;
                            _this._registryOutputType = null;
                            _this._registryFileOutput = null;
                            _this._stopConditions = null;
                            _this._showProgressBar = false;
                            _this._showProgressBarAutoclose = false;
                            _this._pathName = null;
                            _this._realTimeStartTime = 0;
                            _this._debugOutput = null;
                            _this._reportOutput = null;
                            _this._errorOutput = null;
                            _this._traceOutput = null;
                            _this._interruptingException = null;
                            _this._nameCatalog = new desmoj.core.simulator.NameCatalog();
                            _this._description = null;
                            _this._stopTime = null;
                            _this._stopTimeEvent = null;
                            _this._delayInMillis = 0;
                            _this._error = false;
                            _this._silent = false;
                            _this._status = 0;
                            _this._client = null;
                            _this.clientScheduler = null;
                            _this._distMan = null;
                            _this._messMan = null;
                            _this._registryOutputType = null;
                            _this._registryFileOutput = null;
                            _this._stopConditions = null;
                            _this._showProgressBar = false;
                            _this._showProgressBarAutoclose = false;
                            _this._pathName = null;
                            _this._realTimeStartTime = 0;
                            _this._debugOutput = null;
                            _this._reportOutput = null;
                            _this._errorOutput = null;
                            _this._traceOutput = null;
                            _this._interruptingException = null;
                            (function () {
                                var reportOutputs = ([]);
                                if (reportOutputType_1 != null)
                                    (reportOutputs.push(reportOutputType_1) > 0);
                                var traceOutputs = ([]);
                                if (traceOutputType_1 != null)
                                    (traceOutputs.push(traceOutputType_1) > 0);
                                var errorOutputs = ([]);
                                if (errorOutputType_1 != null)
                                    (errorOutputs.push(errorOutputType_1) > 0);
                                var debugOutputs = ([]);
                                if (debugOutputType_1 != null)
                                    (debugOutputs.push(debugOutputType_1) > 0);
                                _this.setupExperiment(name, pathName, formatter_1, reportOutputs, traceOutputs, errorOutputs, debugOutputs);
                            })();
                        }
                    }
                    else if (((typeof name === 'string') || name === null) && ((typeof pathName === 'string') || pathName === null) && ((formatter != null && (formatter instanceof Array)) || formatter === null) && ((reportOutputType != null && (reportOutputType instanceof Array)) || reportOutputType === null) && ((traceOutputType != null && (traceOutputType instanceof Array)) || traceOutputType === null) && ((errorOutputType != null && (errorOutputType instanceof Array)) || errorOutputType === null) && debugOutputType === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        var outputPath_2 = __args[1];
                        var reportOutputs_2 = __args[2];
                        var traceOutputs_2 = __args[3];
                        var errorOutputs_2 = __args[4];
                        var debugOutputs_2 = __args[5];
                        {
                            var __args_11 = Array.prototype.slice.call(arguments);
                            var formatter_2 = null;
                            _this = _super.call(this, name) || this;
                            _this._error = false;
                            _this._silent = false;
                            _this._status = 0;
                            _this._client = null;
                            _this.clientScheduler = null;
                            _this._distMan = null;
                            _this._messMan = null;
                            _this._registryOutputType = null;
                            _this._registryFileOutput = null;
                            _this._stopConditions = null;
                            _this._showProgressBar = false;
                            _this._showProgressBarAutoclose = false;
                            _this._pathName = null;
                            _this._realTimeStartTime = 0;
                            _this._debugOutput = null;
                            _this._reportOutput = null;
                            _this._errorOutput = null;
                            _this._traceOutput = null;
                            _this._interruptingException = null;
                            _this._nameCatalog = new desmoj.core.simulator.NameCatalog();
                            _this._description = null;
                            _this._stopTime = null;
                            _this._stopTimeEvent = null;
                            _this._delayInMillis = 0;
                            _this._error = false;
                            _this._silent = false;
                            _this._status = 0;
                            _this._client = null;
                            _this.clientScheduler = null;
                            _this._distMan = null;
                            _this._messMan = null;
                            _this._registryOutputType = null;
                            _this._registryFileOutput = null;
                            _this._stopConditions = null;
                            _this._showProgressBar = false;
                            _this._showProgressBarAutoclose = false;
                            _this._pathName = null;
                            _this._realTimeStartTime = 0;
                            _this._debugOutput = null;
                            _this._reportOutput = null;
                            _this._errorOutput = null;
                            _this._traceOutput = null;
                            _this._interruptingException = null;
                            (function () {
                                _this.setupExperiment(name, outputPath_2, formatter_2, reportOutputs_2, traceOutputs_2, errorOutputs_2, debugOutputs_2);
                            })();
                        }
                    }
                    else if (((typeof name === 'string') || name === null) && ((typeof pathName === 'number') || pathName === null) && ((typeof formatter === 'number') || formatter === null) && ((reportOutputType != null && (reportOutputType["__interfaces"] != null && reportOutputType["__interfaces"].indexOf("desmoj.core.simulator.TimeFormatter") >= 0 || reportOutputType.constructor != null && reportOutputType.constructor["__interfaces"] != null && reportOutputType.constructor["__interfaces"].indexOf("desmoj.core.simulator.TimeFormatter") >= 0)) || reportOutputType === null) && traceOutputType === undefined && errorOutputType === undefined && debugOutputType === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        var epsilon = __args[1];
                        var referenceUnit = __args[2];
                        var formatter_3 = __args[3];
                        {
                            var __args_12 = Array.prototype.slice.call(arguments);
                            {
                                var __args_13 = Array.prototype.slice.call(arguments);
                                var pathName_1 = ".";
                                var reportOutputType_2 = Experiment.DEFAULT_REPORT_OUTPUT_TYPE;
                                var traceOutputType_2 = Experiment.DEFAULT_TRACE_OUTPUT_TYPE;
                                var errorOutputType_2 = Experiment.DEFAULT_ERROR_OUTPUT_TYPE;
                                var debugOutputType_2 = Experiment.DEFAULT_DEBUG_OUTPUT_TYPE;
                                _this = _super.call(this, name) || this;
                                _this._error = false;
                                _this._silent = false;
                                _this._status = 0;
                                _this._client = null;
                                _this.clientScheduler = null;
                                _this._distMan = null;
                                _this._messMan = null;
                                _this._registryOutputType = null;
                                _this._registryFileOutput = null;
                                _this._stopConditions = null;
                                _this._showProgressBar = false;
                                _this._showProgressBarAutoclose = false;
                                _this._pathName = null;
                                _this._realTimeStartTime = 0;
                                _this._debugOutput = null;
                                _this._reportOutput = null;
                                _this._errorOutput = null;
                                _this._traceOutput = null;
                                _this._interruptingException = null;
                                _this._nameCatalog = new desmoj.core.simulator.NameCatalog();
                                _this._description = null;
                                _this._stopTime = null;
                                _this._stopTimeEvent = null;
                                _this._delayInMillis = 0;
                                _this._error = false;
                                _this._silent = false;
                                _this._status = 0;
                                _this._client = null;
                                _this.clientScheduler = null;
                                _this._distMan = null;
                                _this._messMan = null;
                                _this._registryOutputType = null;
                                _this._registryFileOutput = null;
                                _this._stopConditions = null;
                                _this._showProgressBar = false;
                                _this._showProgressBarAutoclose = false;
                                _this._pathName = null;
                                _this._realTimeStartTime = 0;
                                _this._debugOutput = null;
                                _this._reportOutput = null;
                                _this._errorOutput = null;
                                _this._traceOutput = null;
                                _this._interruptingException = null;
                                (function () {
                                    var reportOutputs = ([]);
                                    if (reportOutputType_2 != null)
                                        (reportOutputs.push(reportOutputType_2) > 0);
                                    var traceOutputs = ([]);
                                    if (traceOutputType_2 != null)
                                        (traceOutputs.push(traceOutputType_2) > 0);
                                    var errorOutputs = ([]);
                                    if (errorOutputType_2 != null)
                                        (errorOutputs.push(errorOutputType_2) > 0);
                                    var debugOutputs = ([]);
                                    if (debugOutputType_2 != null)
                                        (debugOutputs.push(debugOutputType_2) > 0);
                                    _this.setupExperiment(name, pathName_1, formatter_3, reportOutputs, traceOutputs, errorOutputs, debugOutputs);
                                })();
                            }
                        }
                        (function () {
                            console.error("Created experiment, but ignored TimeUnits epsilon/referenceUnit");
                            console.error("passed to deprecated constructor.");
                            console.error("\"Experiment(String name, TimeUnit epsilon, TimeUnit referenceUnit, TimeFormatter formatter)\"");
                            console.error("Please use");
                            console.error(" - setEpsilon(java.util.concurrent.TimeUnit epsilon)");
                            console.error(" - setReferenceUnit(java.util.concurrent.TimeUnit referenceUnit)");
                            console.error("to set your epsilon/reference time units as desried before creating");
                            console.error("experiment objects.");
                        })();
                    }
                    else if (((typeof name === 'string') || name === null) && ((typeof pathName === 'string') || pathName === null) && formatter === undefined && reportOutputType === undefined && traceOutputType === undefined && errorOutputType === undefined && debugOutputType === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        {
                            var __args_14 = Array.prototype.slice.call(arguments);
                            var reportOutputType_3 = Experiment.DEFAULT_REPORT_OUTPUT_TYPE;
                            var traceOutputType_3 = Experiment.DEFAULT_TRACE_OUTPUT_TYPE;
                            var errorOutputType_3 = Experiment.DEFAULT_ERROR_OUTPUT_TYPE;
                            var debugOutputType_3 = Experiment.DEFAULT_DEBUG_OUTPUT_TYPE;
                            {
                                var __args_15 = Array.prototype.slice.call(arguments);
                                var formatter_4 = null;
                                _this = _super.call(this, name) || this;
                                _this._error = false;
                                _this._silent = false;
                                _this._status = 0;
                                _this._client = null;
                                _this.clientScheduler = null;
                                _this._distMan = null;
                                _this._messMan = null;
                                _this._registryOutputType = null;
                                _this._registryFileOutput = null;
                                _this._stopConditions = null;
                                _this._showProgressBar = false;
                                _this._showProgressBarAutoclose = false;
                                _this._pathName = null;
                                _this._realTimeStartTime = 0;
                                _this._debugOutput = null;
                                _this._reportOutput = null;
                                _this._errorOutput = null;
                                _this._traceOutput = null;
                                _this._interruptingException = null;
                                _this._nameCatalog = new desmoj.core.simulator.NameCatalog();
                                _this._description = null;
                                _this._stopTime = null;
                                _this._stopTimeEvent = null;
                                _this._delayInMillis = 0;
                                _this._error = false;
                                _this._silent = false;
                                _this._status = 0;
                                _this._client = null;
                                _this.clientScheduler = null;
                                _this._distMan = null;
                                _this._messMan = null;
                                _this._registryOutputType = null;
                                _this._registryFileOutput = null;
                                _this._stopConditions = null;
                                _this._showProgressBar = false;
                                _this._showProgressBarAutoclose = false;
                                _this._pathName = null;
                                _this._realTimeStartTime = 0;
                                _this._debugOutput = null;
                                _this._reportOutput = null;
                                _this._errorOutput = null;
                                _this._traceOutput = null;
                                _this._interruptingException = null;
                                (function () {
                                    var reportOutputs = ([]);
                                    if (reportOutputType_3 != null)
                                        (reportOutputs.push(reportOutputType_3) > 0);
                                    var traceOutputs = ([]);
                                    if (traceOutputType_3 != null)
                                        (traceOutputs.push(traceOutputType_3) > 0);
                                    var errorOutputs = ([]);
                                    if (errorOutputType_3 != null)
                                        (errorOutputs.push(errorOutputType_3) > 0);
                                    var debugOutputs = ([]);
                                    if (debugOutputType_3 != null)
                                        (debugOutputs.push(debugOutputType_3) > 0);
                                    _this.setupExperiment(name, pathName, formatter_4, reportOutputs, traceOutputs, errorOutputs, debugOutputs);
                                })();
                            }
                        }
                    }
                    else if (((typeof name === 'string') || name === null) && ((pathName != null && (pathName["__interfaces"] != null && pathName["__interfaces"].indexOf("desmoj.core.simulator.TimeFormatter") >= 0 || pathName.constructor != null && pathName.constructor["__interfaces"] != null && pathName.constructor["__interfaces"].indexOf("desmoj.core.simulator.TimeFormatter") >= 0)) || pathName === null) && formatter === undefined && reportOutputType === undefined && traceOutputType === undefined && errorOutputType === undefined && debugOutputType === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        var formatter_5 = __args[1];
                        {
                            var __args_16 = Array.prototype.slice.call(arguments);
                            var pathName_2 = ".";
                            var reportOutputType_4 = Experiment.DEFAULT_REPORT_OUTPUT_TYPE;
                            var traceOutputType_4 = Experiment.DEFAULT_TRACE_OUTPUT_TYPE;
                            var errorOutputType_4 = Experiment.DEFAULT_ERROR_OUTPUT_TYPE;
                            var debugOutputType_4 = Experiment.DEFAULT_DEBUG_OUTPUT_TYPE;
                            _this = _super.call(this, name) || this;
                            _this._error = false;
                            _this._silent = false;
                            _this._status = 0;
                            _this._client = null;
                            _this.clientScheduler = null;
                            _this._distMan = null;
                            _this._messMan = null;
                            _this._registryOutputType = null;
                            _this._registryFileOutput = null;
                            _this._stopConditions = null;
                            _this._showProgressBar = false;
                            _this._showProgressBarAutoclose = false;
                            _this._pathName = null;
                            _this._realTimeStartTime = 0;
                            _this._debugOutput = null;
                            _this._reportOutput = null;
                            _this._errorOutput = null;
                            _this._traceOutput = null;
                            _this._interruptingException = null;
                            _this._nameCatalog = new desmoj.core.simulator.NameCatalog();
                            _this._description = null;
                            _this._stopTime = null;
                            _this._stopTimeEvent = null;
                            _this._delayInMillis = 0;
                            _this._error = false;
                            _this._silent = false;
                            _this._status = 0;
                            _this._client = null;
                            _this.clientScheduler = null;
                            _this._distMan = null;
                            _this._messMan = null;
                            _this._registryOutputType = null;
                            _this._registryFileOutput = null;
                            _this._stopConditions = null;
                            _this._showProgressBar = false;
                            _this._showProgressBarAutoclose = false;
                            _this._pathName = null;
                            _this._realTimeStartTime = 0;
                            _this._debugOutput = null;
                            _this._reportOutput = null;
                            _this._errorOutput = null;
                            _this._traceOutput = null;
                            _this._interruptingException = null;
                            (function () {
                                var reportOutputs = ([]);
                                if (reportOutputType_4 != null)
                                    (reportOutputs.push(reportOutputType_4) > 0);
                                var traceOutputs = ([]);
                                if (traceOutputType_4 != null)
                                    (traceOutputs.push(traceOutputType_4) > 0);
                                var errorOutputs = ([]);
                                if (errorOutputType_4 != null)
                                    (errorOutputs.push(errorOutputType_4) > 0);
                                var debugOutputs = ([]);
                                if (debugOutputType_4 != null)
                                    (debugOutputs.push(debugOutputType_4) > 0);
                                _this.setupExperiment(name, pathName_2, formatter_5, reportOutputs, traceOutputs, errorOutputs, debugOutputs);
                            })();
                        }
                    }
                    else if (((typeof name === 'string') || name === null) && ((typeof pathName === 'boolean') || pathName === null) && formatter === undefined && reportOutputType === undefined && traceOutputType === undefined && errorOutputType === undefined && debugOutputType === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        var output = __args[1];
                        {
                            var __args_17 = Array.prototype.slice.call(arguments);
                            var pathName_3 = ".";
                            var formatter_6 = null;
                            var reportOutputType_5 = output ? Experiment.DEFAULT_REPORT_OUTPUT_TYPE : null;
                            var traceOutputType_5 = output ? Experiment.DEFAULT_TRACE_OUTPUT_TYPE : null;
                            var errorOutputType_5 = output ? Experiment.DEFAULT_ERROR_OUTPUT_TYPE : null;
                            var debugOutputType_5 = output ? Experiment.DEFAULT_DEBUG_OUTPUT_TYPE : null;
                            _this = _super.call(this, name) || this;
                            _this._error = false;
                            _this._silent = false;
                            _this._status = 0;
                            _this._client = null;
                            _this.clientScheduler = null;
                            _this._distMan = null;
                            _this._messMan = null;
                            _this._registryOutputType = null;
                            _this._registryFileOutput = null;
                            _this._stopConditions = null;
                            _this._showProgressBar = false;
                            _this._showProgressBarAutoclose = false;
                            _this._pathName = null;
                            _this._realTimeStartTime = 0;
                            _this._debugOutput = null;
                            _this._reportOutput = null;
                            _this._errorOutput = null;
                            _this._traceOutput = null;
                            _this._interruptingException = null;
                            _this._nameCatalog = new desmoj.core.simulator.NameCatalog();
                            _this._description = null;
                            _this._stopTime = null;
                            _this._stopTimeEvent = null;
                            _this._delayInMillis = 0;
                            _this._error = false;
                            _this._silent = false;
                            _this._status = 0;
                            _this._client = null;
                            _this.clientScheduler = null;
                            _this._distMan = null;
                            _this._messMan = null;
                            _this._registryOutputType = null;
                            _this._registryFileOutput = null;
                            _this._stopConditions = null;
                            _this._showProgressBar = false;
                            _this._showProgressBarAutoclose = false;
                            _this._pathName = null;
                            _this._realTimeStartTime = 0;
                            _this._debugOutput = null;
                            _this._reportOutput = null;
                            _this._errorOutput = null;
                            _this._traceOutput = null;
                            _this._interruptingException = null;
                            (function () {
                                var reportOutputs = ([]);
                                if (reportOutputType_5 != null)
                                    (reportOutputs.push(reportOutputType_5) > 0);
                                var traceOutputs = ([]);
                                if (traceOutputType_5 != null)
                                    (traceOutputs.push(traceOutputType_5) > 0);
                                var errorOutputs = ([]);
                                if (errorOutputType_5 != null)
                                    (errorOutputs.push(errorOutputType_5) > 0);
                                var debugOutputs = ([]);
                                if (debugOutputType_5 != null)
                                    (debugOutputs.push(debugOutputType_5) > 0);
                                _this.setupExperiment(name, pathName_3, formatter_6, reportOutputs, traceOutputs, errorOutputs, debugOutputs);
                            })();
                        }
                    }
                    else if (((typeof name === 'string') || name === null) && pathName === undefined && formatter === undefined && reportOutputType === undefined && traceOutputType === undefined && errorOutputType === undefined && debugOutputType === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        {
                            var __args_18 = Array.prototype.slice.call(arguments);
                            var output = true;
                            {
                                var __args_19 = Array.prototype.slice.call(arguments);
                                var pathName_4 = ".";
                                var formatter_7 = null;
                                var reportOutputType_6 = output ? Experiment.DEFAULT_REPORT_OUTPUT_TYPE : null;
                                var traceOutputType_6 = output ? Experiment.DEFAULT_TRACE_OUTPUT_TYPE : null;
                                var errorOutputType_6 = output ? Experiment.DEFAULT_ERROR_OUTPUT_TYPE : null;
                                var debugOutputType_6 = output ? Experiment.DEFAULT_DEBUG_OUTPUT_TYPE : null;
                                _this = _super.call(this, name) || this;
                                _this._error = false;
                                _this._silent = false;
                                _this._status = 0;
                                _this._client = null;
                                _this.clientScheduler = null;
                                _this._distMan = null;
                                _this._messMan = null;
                                _this._registryOutputType = null;
                                _this._registryFileOutput = null;
                                _this._stopConditions = null;
                                _this._showProgressBar = false;
                                _this._showProgressBarAutoclose = false;
                                _this._pathName = null;
                                _this._realTimeStartTime = 0;
                                _this._debugOutput = null;
                                _this._reportOutput = null;
                                _this._errorOutput = null;
                                _this._traceOutput = null;
                                _this._interruptingException = null;
                                _this._nameCatalog = new desmoj.core.simulator.NameCatalog();
                                _this._description = null;
                                _this._stopTime = null;
                                _this._stopTimeEvent = null;
                                _this._delayInMillis = 0;
                                _this._error = false;
                                _this._silent = false;
                                _this._status = 0;
                                _this._client = null;
                                _this.clientScheduler = null;
                                _this._distMan = null;
                                _this._messMan = null;
                                _this._registryOutputType = null;
                                _this._registryFileOutput = null;
                                _this._stopConditions = null;
                                _this._showProgressBar = false;
                                _this._showProgressBarAutoclose = false;
                                _this._pathName = null;
                                _this._realTimeStartTime = 0;
                                _this._debugOutput = null;
                                _this._reportOutput = null;
                                _this._errorOutput = null;
                                _this._traceOutput = null;
                                _this._interruptingException = null;
                                (function () {
                                    var reportOutputs = ([]);
                                    if (reportOutputType_6 != null)
                                        (reportOutputs.push(reportOutputType_6) > 0);
                                    var traceOutputs = ([]);
                                    if (traceOutputType_6 != null)
                                        (traceOutputs.push(traceOutputType_6) > 0);
                                    var errorOutputs = ([]);
                                    if (errorOutputType_6 != null)
                                        (errorOutputs.push(errorOutputType_6) > 0);
                                    var debugOutputs = ([]);
                                    if (debugOutputType_6 != null)
                                        (debugOutputs.push(debugOutputType_6) > 0);
                                    _this.setupExperiment(name, pathName_4, formatter_7, reportOutputs, traceOutputs, errorOutputs, debugOutputs);
                                })();
                            }
                        }
                    }
                    else
                        throw new Error('invalid overload');
                    return _this;
                }
                /**
                 * Private helper method to initialize the experiment; should be called
                 * from all constructors.
                 *
                 * @param {string} name
                 * String : The name of the experiment determining the
                 * outputfile's names, too. So please avoid characters that your
                 * local filesystem does not support in filenames.
                 * @param {string} outputPath
                 * java.lang.String : The output path for report files
                 * @param {*} formatter
                 * desmoj.core.simulator.TimeFormatter: Defines how time values
                 * will be formatted in the output files.
                 *
                 * @see java.util.concurrent.TimeUnit
                 * @param {string[]} reportOutputs
                 * @param {string[]} traceOutputs
                 * @param {string[]} errorOutputs
                 * @param {string[]} debugOutputs
                 * @private
                 */
                /*private*/ Experiment.prototype.setupExperiment = function (name, outputPath, formatter, reportOutputs, traceOutputs, errorOutputs, debugOutputs) {
                    this._traceOutput = ([]);
                    this._debugOutput = ([]);
                    this._errorOutput = ([]);
                    this._reportOutput = ([]);
                    this._status = Experiment.NOT_INITIALIZED;
                    this._stopConditions = ([]);
                    this._registryFileOutput = ([]);
                    this._registryOutputType = ([]);
                    Experiment.lastSuffix = 0;
                    this._showProgressBar = true;
                    this._showProgressBarAutoclose = false;
                    this._error = false;
                    this._silent = false;
                    this._interruptingException = null;
                    this._pathName = outputPath;
                    try {
                        Experiment.tracenote = eval("desmoj.core.report.TraceNote");
                        Experiment.debugnote = eval("desmoj.core.report.DebugNote");
                        Experiment.errormessage = eval("desmoj.core.report.ErrorMessage");
                        Experiment.reporter = eval("desmoj.core.report.Reporter");
                    }
                    catch (cnfEx) {
                        console.error("Can not create Experiment!");
                        console.error("Constructor of desmoj.core.Experiment.");
                        console.error("Classes are probably not installed correctly.");
                        console.error("Check your CLASSPATH setting.");
                        console.error("Exception caught : " + cnfEx);
                    }
                    ;
                    this._messMan = new desmoj.core.report.MessageDistributor();
                    for (var index766 = 0; index766 < debugOutputs.length; index766++) {
                        var debugOutputType = debugOutputs[index766];
                        {
                            try {
                                var debugOType = eval((debugOutputType != null) ? debugOutputType : Experiment.DEFAULT_DEBUG_OUTPUT_TYPE);
                                var dbg = new debugOType();
                                /* add */ (this._debugOutput.push(dbg) > 0);
                                if (debugOutputType != null)
                                    dbg.open(this._pathName, name);
                                this._messMan.register$desmoj_core_report_MessageReceiver$java_lang_Class(dbg, Experiment.debugnote);
                                this._messMan.switchOff(Experiment.debugnote);
                                this.register(dbg);
                            }
                            catch (e) {
                                console.error(e.toString());
                            }
                            ;
                        }
                    }
                    for (var index767 = 0; index767 < reportOutputs.length; index767++) {
                        var reportOutputType = reportOutputs[index767];
                        {
                            try {
                                var reportOType = eval((reportOutputType != null) ? reportOutputType : Experiment.DEFAULT_REPORT_OUTPUT_TYPE);
                                var rpt = new reportOType();
                                /* add */ (this._reportOutput.push(rpt) > 0);
                                if (reportOutputType != null)
                                    rpt.open(this._pathName, name);
                                this._messMan.register$desmoj_core_report_MessageReceiver$java_lang_Class(rpt, Experiment.reporter);
                                this.register(rpt);
                            }
                            catch (e) {
                                console.error(e.toString());
                            }
                            ;
                        }
                    }
                    for (var index768 = 0; index768 < errorOutputs.length; index768++) {
                        var errorOutputType = errorOutputs[index768];
                        {
                            try {
                                var errorOType = eval((errorOutputType != null) ? errorOutputType : Experiment.DEFAULT_ERROR_OUTPUT_TYPE);
                                var err = new errorOType();
                                /* add */ (this._errorOutput.push(err) > 0);
                                if (errorOutputType != null)
                                    err.open(this._pathName, name);
                                this._messMan.register$desmoj_core_report_MessageReceiver$java_lang_Class(err, Experiment.errormessage);
                                this.register(err);
                            }
                            catch (e) {
                                console.error(e.toString());
                            }
                            ;
                        }
                    }
                    for (var index769 = 0; index769 < traceOutputs.length; index769++) {
                        var traceOutputType = traceOutputs[index769];
                        {
                            try {
                                var traceOType = eval((traceOutputType != null) ? traceOutputType : Experiment.DEFAULT_TRACE_OUTPUT_TYPE);
                                var trc = new traceOType();
                                /* add */ (this._traceOutput.push(trc) > 0);
                                if (traceOutputType != null)
                                    trc.open(this._pathName, name);
                                this._messMan.register$desmoj_core_report_MessageReceiver$java_lang_Class(trc, Experiment.tracenote);
                                this._messMan.switchOff(Experiment.tracenote);
                                this.register(trc);
                            }
                            catch (e) {
                                console.error(e.toString());
                            }
                            ;
                        }
                    }
                    this._distMan = new desmoj.core.dist.DistributionManager(name, 979);
                    this._client = null;
                    if (formatter == null)
                        desmoj.core.simulator.TimeOperations.setTimeFormatter(desmoj.core.simulator.TimeOperations.getDefaultTimeFormatter(), false);
                    else
                        desmoj.core.simulator.TimeOperations.setTimeFormatter(formatter, true);
                    var eventList = new desmoj.core.simulator.EventTreeList();
                    this.clientScheduler = new desmoj.core.simulator.Scheduler(this, name, eventList);
                    this._status = Experiment.INITIALIZED;
                };
                /**
                 * Adds a messagereceiver for debugnotes to the experiment. Whenever a model
                 * produces a message of that type, it will also be sent to the given
                 * messagereceiver for further processing. Note that the given receiver must
                 * be capable of handling debugnotes.
                 *
                 * @param {*} trcRec
                 * desmoj.report.MessageReceiver : The new messagereceiver for
                 * the given type of messages
                 */
                Experiment.prototype.addDebugReceiver = function (trcRec) {
                    if (trcRec == null) {
                        this.sendWarning("Can not add receiver to experiment! Command ignored.", "Experiment \'" + this.getName() + "\', method \'void addDebugReceiver(" + "MessageReceiver trcRec)\'", "The parameter \'trc\' passed was a null reference.", "Make sure to construct a valid MessageReciever before adding it to the experiment\'s messaging system.");
                        return;
                    }
                    this._messMan.register$desmoj_core_report_MessageReceiver$java_lang_Class(trcRec, Experiment.debugnote);
                };
                /**
                 * Adds a messagereceiver for error messages to the experiment. Whenever a
                 * model produces a message of that type, it will also be sent to the given
                 * messagereceiver for further processing. Note that the given receiver must
                 * be capable of handling messagereceiver.
                 *
                 * @param {*} trcRec
                 * desmoj.report.MessageReceiver : The new messagereceiver for
                 * the given type of messages
                 */
                Experiment.prototype.addErrorReceiver = function (trcRec) {
                    if (trcRec == null) {
                        this.sendWarning("Can not add receiver to experiment! Command ignored.", "Experiment \'" + this.getName() + "\', method \'void addErrorReceiver(" + "MessageReceiver trcRec)\'", "The parameter \'trc\' passed was a null reference.", "Make sure to construct a valid MessageReciever before adding it to the experiment\'s messaging system.");
                        return;
                    }
                    this._messMan.register$desmoj_core_report_MessageReceiver$java_lang_Class(trcRec, Experiment.errormessage);
                };
                /**
                 * Returns the experiments name catalog for ensuring unique names of
                 * simulation objects within a single experiment.
                 * @return {desmoj.core.simulator.NameCatalog}
                 */
                Experiment.prototype.getNameCatalog = function () {
                    return this._nameCatalog;
                };
                /**
                 * Adds a messagereceiver for the given subtype of message to the
                 * experiment. Whenever a model produces a message of that type, it will
                 * also be sent to the given messagereceiver for further processing.
                 *
                 * @param {*} trcRec
                 * desmoj.report.MessageReceiver : The new messagereceiver for
                 * the given type of messages
                 * @param {*} messageType
                 * Class : The type of message to be sent to the given
                 * messagereceiver
                 */
                Experiment.prototype.addReceiver = function (trcRec, messageType) {
                    if (trcRec == null) {
                        this.sendWarning("Can not add receiver to experiment! Command ignored.", "Experiment \'" + this.getName() + "\', method \'void addReceiver(MessageReceiver " + "trcRec, Class messageType)\'", "The parameter \'trc\' passed was a null reference.", "Make sure to construct a valid MessageReciever before adding it to the experiment\'s messaging system.");
                        return;
                    }
                    if (messageType == null) {
                        this.sendWarning("Can not add receiver to experiment! Command ignored.", "Experiment \'" + this.getName() + "\', method \'void addReceiver(MessageReceiver " + "trcRec, Class messageType)\'", "The parameter \'messageType\' passed was a null reference.", "Make sure to construct a valid Class object before adding it to the experiment\'s messaging system.");
                        return;
                    }
                    this._messMan.register$desmoj_core_report_MessageReceiver$java_lang_Class(trcRec, messageType);
                };
                /**
                 * Adds a messagereceiver for tracenotes to the experiment. Whenever a model
                 * produces a message of that type, it will also be sent to the given
                 * messagereceiver for further processing. Note that the given Receiver must
                 * be capable of handling tracenotes.
                 *
                 * @param {*} trcRec
                 * desmoj.report.MessageReceiver : The new messagereceiver for
                 * the given type of messages
                 */
                Experiment.prototype.addTraceReceiver = function (trcRec) {
                    if (trcRec == null) {
                        this.sendWarning("Can not add receiver to experiment! Command ignored.", "Experiment \'" + this.getName() + "\', method \'void addTraceReceiver(" + "MessageReceiver trcRec)\'", "The parameter \'trc\' passed was a null reference.", "Make sure to construct a valid MessageReciever before adding it to the experiment\'s messaging system.");
                        return;
                    }
                    this._messMan.register$desmoj_core_report_MessageReceiver$java_lang_Class(trcRec, Experiment.tracenote);
                };
                /**
                 * Returns a boolean indicating whether debug notes are forwarded to the
                 * debug ouput or not. Debug ouput can be switched on and off using the
                 * methods <code>debugOn(TimeInstant startTime)</code> or
                 * <code>debugOff(TimeInstant stopTime)</code>
                 *
                 * @return {boolean} boolean
                 */
                Experiment.prototype.debugIsOn = function () {
                    return this._messMan.isOn(Experiment.debugnote);
                };
                /**
                 * Switches the debug output off at the given point of simulation time.
                 *
                 * @param {desmoj.core.simulator.TimeInstant} stopTime
                 * TimeInstant : The point in simulation time to switch off debug
                 */
                Experiment.prototype.debugOff = function (stopTime) {
                    if (stopTime == null) {
                        this.sendWarning("Invalid start time parameter for debug output given! StopTime is set to current time.", "Experiment \'" + this.getName() + "\', method \'void debugOn(TimeInstant startTime)\'", "A null value or a not initialized TimeInstant reference has been passed.", "Make sure to have a valid TimeInstant object, otherwise use method start() without TimeInstant parameter.");
                        stopTime = this.clientScheduler.presentTime();
                    }
                    if (desmoj.core.simulator.TimeInstant.isAfter(this.clientScheduler.presentTime(), stopTime)) {
                        this.sendWarning("Invalid start time parameter for debug output given! StopTime is set to current time.", "Experiment \'" + this.getName() + "\', method \'void debugOn(TimeInstant stopTime)\'", "The stopTime given is in the past.", "Make sure to give a TimeInstant parameter larger than the current time.");
                        stopTime = this.clientScheduler.presentTime();
                    }
                    var debugOff = new desmoj.core.simulator.ExternalEventDebugOff(this._client, true);
                    debugOff.schedule$desmoj_core_simulator_TimeInstant(stopTime);
                };
                /**
                 * Switches the debug output on at the given point of simulation time.
                 *
                 * @param {desmoj.core.simulator.TimeInstant} startTime
                 * TimeInstant : The point in simulation time to switch on debug
                 */
                Experiment.prototype.debugOn = function (startTime) {
                    if (startTime == null) {
                        this.sendWarning("Invalid start time parameter for debug output given! StartTime is set to current time.", "Experiment \'" + this.getName() + "\', method \'void debugOn(TimeInstant startTime)\'", "A null value or a not initialized TimeInstant reference has been passed.", "Make sure to have a valid TimeInstant object, otherwise use method start() without TimeInstant parameter.");
                        startTime = this.clientScheduler.presentTime();
                    }
                    if (desmoj.core.simulator.TimeInstant.isAfter(this.clientScheduler.presentTime(), startTime)) {
                        this.sendWarning("Invalid start time parameter for debug output given! StartTime is set to current time.", "Experiment \'" + this.getName() + "\', method \'void debugOn(TimeInstant startTime)\'", "The startTime given is in the past.", "Make sure to give a TimeInstant parameter larger than the current time.");
                        startTime = this.clientScheduler.presentTime();
                    }
                    if (desmoj.core.simulator.TimeInstant.isEqual(this.clientScheduler.presentTime(), startTime)) {
                        this.getMessageManager().switchOn(Experiment.debugnote);
                        this._client.sendTraceNote("Debug switched on");
                    }
                    else {
                        var debugOn = new desmoj.core.simulator.ExternalEventDebugOn(this._client, true);
                        debugOn.schedule$desmoj_core_simulator_TimeInstant(startTime);
                    }
                };
                /**
                 * Switches the debug output on for the given period of simulation time. If
                 * the second parameter (off) is "sooner" then the first parameter (on),
                 * they will be swapped automatically. Same parameters will result in no
                 * debug output at all!
                 *
                 * @param {desmoj.core.simulator.TimeInstant} startTime
                 * TimeInstant : The point in simulation time to switch debug on
                 * @param {desmoj.core.simulator.TimeInstant} stopTime
                 * TimeInstant : The point in simulation time to switch debug off
                 */
                Experiment.prototype.debugPeriod = function (startTime, stopTime) {
                    if (startTime == null) {
                        this.sendWarning("Invalid start time parameter for debug output given! Command ignored", "Experiment \'" + this.getName() + "\', Method \'debugPeriod(TimeInstant startTime, " + "TimeInstant stopTime)\'", "A null value or a not initialized TimeInstant reference has been passed.", "Make sure to have a valid TimeInstant object.");
                        return;
                    }
                    if (stopTime == null) {
                        this.sendWarning("Invalid stop time parameter for debug output given! Command ignored.", "Experiment \'" + this.getName() + "\', Method \'debugPeriod(TimeInstant startTime, " + "TimeInstant stopTime)\'", "A null value or a not initialized TimeInstant reference has been passed.", "Make sure to have a valid TimeInstant object.");
                        return;
                    }
                    if (desmoj.core.simulator.TimeInstant.isAfter(startTime, stopTime)) {
                        var buffer = stopTime;
                        stopTime = startTime;
                        startTime = buffer;
                    }
                    if (desmoj.core.simulator.TimeInstant.isAfter(this.clientScheduler.presentTime(), stopTime)) {
                        this.sendWarning("Invalid stop time parameter for debug output given! Command ignored.", "Experiment \'" + this.getName() + "\', Method \'debugPeriod(TimeInstant startTime, " + "TimeInstant stopTime)\'", "The stopTime given is in the past.", "Make sure to give a TimeInstant parameter larger than the current time.");
                        return;
                    }
                    if (desmoj.core.simulator.TimeInstant.isAfter(this.clientScheduler.presentTime(), startTime)) {
                        this.sendWarning("Invalid start time parameter for debug output given! Debug output has been set to start immediately.", "Experiment \'" + this.getName() + "\', Method \'debugPeriod(TimeInstant startTime, " + "TimeInstant stopTime)\'", "The startTime given is in the past.", "Make sure to give a TimeInstant parameter larger than the current time.");
                        startTime = this.clientScheduler.presentTime();
                    }
                    this.debugOn(startTime);
                    this.debugOff(stopTime);
                };
                /**
                 * De-registers a file at the experiment. Registered files will be flushed
                 * and closed after the experiment has finished. If the file is manually
                 * closed by the user and has been registered at the Experiment, deRegister
                 * it
                 *
                 * @param {desmoj.core.report.FileOutput} file
                 * desmoj.report.FileOutput : The file to be closed with the end
                 * of an Experiment
                 */
                Experiment.prototype.deRegister = function (file) {
                    if (file == null) {
                        this.sendWarning("Can not de-register FileOutput! Command ignored.", "Experiment \'" + this.getName() + "\' method \'void deRegister(FileOutput file).\'", "The parameter given was a null reference.", "Make sure to only connect valid FileOutputs at the Experiment.");
                        return;
                    }
                    /* remove */ (function (a) { return a.splice(a.indexOf(file), 1); })(this._registryFileOutput);
                };
                /**
                 * Stopps all running simprocesses that might still be scheduled and closes
                 * the output files.
                 */
                Experiment.prototype.finish = function () {
                    if (this._status >= Experiment.ABORTED) {
                        return;
                    }
                    if (this._traceOutput != null) {
                        for (var index770 = 0; index770 < this._traceOutput.length; index770++) {
                            var trc = this._traceOutput[index770];
                            {
                                if (trc != null && (trc["__interfaces"] != null && trc["__interfaces"].indexOf("desmoj.core.report.OutputTypeEndToExport") >= 0 || trc.constructor != null && trc.constructor["__interfaces"] != null && trc.constructor["__interfaces"].indexOf("desmoj.core.report.OutputTypeEndToExport") >= 0)) {
                                    trc["export"](this._pathName, this.getName());
                                }
                            }
                        }
                    }
                    if (this._debugOutput != null) {
                        for (var index771 = 0; index771 < this._debugOutput.length; index771++) {
                            var dbg = this._debugOutput[index771];
                            {
                                if (dbg != null && (dbg["__interfaces"] != null && dbg["__interfaces"].indexOf("desmoj.core.report.OutputTypeEndToExport") >= 0 || dbg.constructor != null && dbg.constructor["__interfaces"] != null && dbg.constructor["__interfaces"].indexOf("desmoj.core.report.OutputTypeEndToExport") >= 0)) {
                                    dbg["export"](this._pathName, this.getName());
                                }
                            }
                        }
                    }
                    if (this._errorOutput != null) {
                        for (var index772 = 0; index772 < this._errorOutput.length; index772++) {
                            var err = this._errorOutput[index772];
                            {
                                if (err != null && (err["__interfaces"] != null && err["__interfaces"].indexOf("desmoj.core.report.OutputTypeEndToExport") >= 0 || err.constructor != null && err.constructor["__interfaces"] != null && err.constructor["__interfaces"].indexOf("desmoj.core.report.OutputTypeEndToExport") >= 0)) {
                                    err["export"](this._pathName, this.getName());
                                }
                            }
                        }
                    }
                    if (this._reportOutput != null) {
                        for (var index773 = 0; index773 < this._reportOutput.length; index773++) {
                            var rpt = this._reportOutput[index773];
                            {
                                if (rpt != null && (rpt["__interfaces"] != null && rpt["__interfaces"].indexOf("desmoj.core.report.OutputTypeEndToExport") >= 0 || rpt.constructor != null && rpt.constructor["__interfaces"] != null && rpt.constructor["__interfaces"].indexOf("desmoj.core.report.OutputTypeEndToExport") >= 0)) {
                                    rpt["export"](this._pathName, this.getName());
                                }
                            }
                        }
                    }
                    this._status = Experiment.ABORTED;
                    for (var index774 = 0; index774 < this._registryOutputType.length; index774++) {
                        var o = this._registryOutputType[index774];
                        o.close();
                    }
                    for (var index775 = 0; index775 < this._registryFileOutput.length; index775++) {
                        var f = this._registryFileOutput[index775];
                        f.close();
                    }
                };
                /**
                 * Returns the distributionmanager for this experiment. Distributions need
                 * access to the distributionmanager for handling antithetic modes,
                 * resetting and their initial seeds.
                 *
                 * @return {desmoj.core.dist.DistributionManager} desmoj.dist.DistributionManager : The distributionmanager for
                 * this experiment
                 */
                Experiment.prototype.getDistributionManager = function () {
                    return this._distMan;
                };
                /**
                 * Returns the epsilon value representing the granularity
                 * of simulation time for this experiment. So far, Hour, Minute,
                 * Second and Millisecond are supported.
                 * Default (unless set explicitly) is TimeUnit.MICROSECONDS.
                 *
                 * @return {def.TimeUnit} TimeUnit : The Granularity of the simulation time
                 */
                Experiment.prototype.getEpsilonUnit = function () {
                    return desmoj.core.simulator.TimeOperations.getEpsilon();
                };
                /**
                 * Returns the current execution Speed Rate.
                 *
                 * @return {number} double : The current execution speed rate.
                 */
                Experiment.prototype.getExecutionSpeedRate = function () {
                    return this.clientScheduler.getExecutionSpeedRate();
                };
                /**
                 * Returns the messagemanager for this experiment. Messages need access to
                 * the MessageManager for distributing the messages to one or more specified
                 * output streams.
                 *
                 * @return {desmoj.core.report.MessageDistributor} desmoj.dist.MessageManager : The messagemanager for this
                 * experiment
                 */
                Experiment.prototype.getMessageManager = function () {
                    return this._messMan;
                };
                /**
                 * Returns the model that is connected to this experiment or
                 * <code>null</code> if no model is connected so far.
                 *
                 * @return {desmoj.core.simulator.Model} Model : The model that this experiment is connected to or
                 * <code>null</code> if no connection is established.
                 */
                Experiment.prototype.getModel = function () {
                    return this._client;
                };
                /**
                 * Returns the name of the path the experiment's report-, trace-, debug- and
                 * error-files are written to.
                 *
                 * @return {string} String the experiment's output path
                 */
                Experiment.prototype.getOutputPath = function () {
                    return this._pathName;
                };
                Experiment.prototype.getOutputAppendixes = function () {
                    var appendixes = ([]);
                    var debugAppendixes = ([]);
                    for (var index776 = 0; index776 < this._debugOutput.length; index776++) {
                        var o = this._debugOutput[index776];
                        {
                            /* add */ (debugAppendixes.push(o.getAppendix()) > 0);
                        }
                    }
                    /* add */ (appendixes.push(debugAppendixes) > 0);
                    var traceAppendixes = ([]);
                    for (var index777 = 0; index777 < this._debugOutput.length; index777++) {
                        var o = this._debugOutput[index777];
                        {
                            /* add */ (traceAppendixes.push(o.getAppendix()) > 0);
                        }
                    }
                    /* add */ (appendixes.push(traceAppendixes) > 0);
                    var errorAppendixes = ([]);
                    for (var index778 = 0; index778 < this._debugOutput.length; index778++) {
                        var o = this._debugOutput[index778];
                        {
                            /* add */ (errorAppendixes.push(o.getAppendix()) > 0);
                        }
                    }
                    /* add */ (appendixes.push(errorAppendixes) > 0);
                    var reportAppendixes = ([]);
                    for (var index779 = 0; index779 < this._debugOutput.length; index779++) {
                        var o = this._debugOutput[index779];
                        {
                            /* add */ (reportAppendixes.push(o.getAppendix()) > 0);
                        }
                    }
                    /* add */ (appendixes.push(reportAppendixes) > 0);
                    return appendixes;
                };
                Experiment.prototype.getRealTimeStartTime = function () {
                    return this._realTimeStartTime;
                };
                /**
                 * Returns the reference unit for this experiment. This is the time unit
                 * mapped to a time step of 1.0 in simulation time. So far, Hour, Minute,
                 * Second and Millisecond are supported.
                 * Default (unless set explicitly) is TimeUnit.SECONDS.
                 *
                 * @return {def.TimeUnit} TimeUnit : The reference unit.
                 */
                Experiment.prototype.getReferenceUnit = function () {
                    return desmoj.core.simulator.TimeOperations.getReferenceUnit();
                };
                /**
                 * Returns the scheduler for this experiment. ModelComponents need access to
                 * the scheduler for identifying the current active entity or process and to
                 * schedule themselves or other schedulables to activate at a given time in
                 * the future.
                 *
                 * @return {desmoj.core.simulator.Scheduler} Scheduler : The scheduler for this experiment
                 */
                Experiment.prototype.getScheduler = function () {
                    return this.clientScheduler;
                };
                /**
                 * Returns the simclock for this experiment. ModelComponents need access to
                 * the simclock for retrieveing the current simulation time.
                 *
                 * @return {desmoj.core.simulator.SimClock} SimCLock : The simclock for this experiment
                 */
                Experiment.prototype.getSimClock = function () {
                    return this.clientScheduler.getSimClock();
                };
                /**
                 * Returns the TimeInstant when the experiment is expected to stop running.
                 *
                 * @return {desmoj.core.simulator.TimeInstant} TimeInstant : The time at which the experiment is expected to stop running.
                 */
                Experiment.prototype.getStopTime = function () {
                    return this._stopTime;
                };
                /**
                 * Returns the Conditions which can cause an experiment to stop.
                 * May be empty if there are no such Conditions.
                 *
                 * @return {desmoj.core.simulator.ModelCondition[]} Condition
                 * @author Tim Janz
                 */
                Experiment.prototype.getStopConditions = function () {
                    return (this._stopConditions.slice(0));
                };
                /**
                 * Removes all conditions set to stop the experiment.
                 */
                Experiment.prototype.removeStopConditions = function () {
                    /* clear */ (this._stopConditions.length = 0);
                };
                /**
                 * Displays the current state of the simulation run. If an experiment is
                 * aborted, it can not be proceeded. All SimThreads still active are
                 * stopped, the main routine can finish.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if the simulation is aborted,
                 * <code>false</code> if it has not started yet or is still running
                 */
                Experiment.prototype.isAborted = function () {
                    return (this._status >= Experiment.ABORTED);
                };
                /**
                 * Shows if this experiment has already been connected to a model.
                 *
                 * @return {boolean} boolean : Is <code>true</code>, if experiment is connected to a
                 * model, <code>false</code> otherwise
                 */
                Experiment.prototype.isConnected = function () {
                    return (this._status >= Experiment.CONNECTED);
                };
                /**
                 * Shows if this experiment has not run yet.
                 *
                 * @return {boolean} boolean : Is <code>true</code>, if experiment is not running yet,
                 * <code>false</code> otherwise
                 */
                Experiment.prototype.isPreparing = function () {
                    return (this._status < Experiment.RUNNING);
                };
                /**
                 * Returns if the event-list processes concurrent Events in random order or
                 * not. Default is not.
                 *
                 * @return {boolean} boolean: <code>true</code> if concurrent Events are randomized,
                 * <code>false</code> otherwise
                 * @author Ruth Meyer
                 */
                Experiment.prototype.isRandomizingConcurrentEvents = function () {
                    return this.clientScheduler.isRandomizingConcurrentEvents();
                };
                /**
                 * Displays the current state of the simulation run.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if the simulation is running,
                 * <code>false</code> if it has not started yet or has already
                 * finished
                 */
                Experiment.prototype.isRunning = function () {
                    return (this._status === Experiment.RUNNING);
                };
                /**
                 * Returns if a progress bar should be displayed for this experiment or not.
                 *
                 * @return {boolean} boolean :<code>true</code> if a progress bar should be displayed
                 * for this experiment, <code>false</code> otherwise.
                 */
                Experiment.prototype.isShowProgressBar = function () {
                    return this._showProgressBar;
                };
                /**
                 * Displays the current state of the simulation run. If an experient is
                 * stopped, it can be proceeded by calling proceed().
                 *
                 * @return {boolean} boolean : Is <code>true</code>, if experiment is stopped,
                 * <code>false</code> otherwise
                 */
                Experiment.prototype.isStopped = function () {
                    return (this._status === Experiment.STOPPED);
                };
                /**
                 * Determines whether or not an error or warning has yet occurred during
                 * this experiment.
                 *
                 * @return {boolean} boolean : <code>True</code> if at least one error has occurred
                 * in the model connected to this experiment or one of its submodels,
                 * <code>false</code> otherwise
                 */
                Experiment.prototype.hasError = function () {
                    return this._error;
                };
                /**
                 * Interrupts experiment execution in case a fatal problem prevents
                 * the experiment from being continued.
                 *
                 * @param {desmoj.core.exception.DESMOJException} e
                 * DESMOJException : The exception that caused the interrupt
                 */
                Experiment.prototype.interrupt = function (e) {
                    if (this._status !== Experiment.RUNNING) {
                        this.sendWarning("Can not interrupt Experiment! Command ignored.", "Experiment: " + this.getName() + " Method: void interrupt(Exception e).", "The Experiment is not running.", "Only Experiments that are running can be interruped.");
                        return;
                    }
                    if (e == null) {
                        this.sendWarning("Can not interrupt Experiment! Command ignored.", "Experiment: " + this.getName() + " Method: void interrupt(Exception e).", "No exception (i.e. <code>null</code>) has been passed.", "Submit a <code>DESMOJException</code> object describing why the experiment has to be terminated immediately.");
                        return;
                    }
                    this._interruptingException = e;
                };
                /**
                 * Proceeds with a stopped experiment. An experiment can be stopped, if
                 * either its status is changed from <code>RUNNING</code> to some other
                 * state, the scheduler runs out of scheduled events or if the
                 * <code>check()</code> method of the given stop <code>Condition</code>
                 * returns <code>true</code> after an event has been processed.
                 */
                Experiment.prototype.proceed = function () {
                    if (this._status < Experiment.STARTED) {
                        this.sendWarning("Can not proceed with Experiment! Command ignored.", "Experiment: " + this.getName() + " Method: void proceed().", "The Experiment has not been started yet.", "Only Experiments that have been stopped after method \'start()\' has been called can use method \'proceed()\' to continue.");
                        return;
                    }
                    if (this._status > Experiment.STOPPED) {
                        this.sendWarning("Can not proceed with Experiment! Command ignored.", "Experiment " + this.getName() + " Method: void proceed().", "The Experiment has already been aborted.", "Use method \'proceed()\' only on stopped experiments.");
                        return;
                    }
                    if (this._status === Experiment.STARTED) {
                        if (!this._silent)
                            console.info("***** DESMO-J version " + Experiment.getDesmoJVersion() + " ***** \n" + this.getName() + " starts at simulation time " + this.getScheduler().presentTime() + ".\n ...please wait...");
                    }
                    else {
                        if (!this._silent)
                            console.info(this.getName() + " resumes at simulation time " + this.getScheduler().presentTime() + ".\n ...please wait...");
                    }
                    if (this._stopTime != null && this._showProgressBar) {
                        this.showProgressBar();
                    }
                    this._status = Experiment.RUNNING;
                    if (!this._silent) {
                        console.info(this.getName() + " stopped at simulation time " + this.getScheduler().presentTime() + ".");
                        if (this.hasError()) {
                            console.info("At least one error or warning has occurred.");
                            if ((this._errorOutput.length == 0)) {
                                console.info("Please re-run the siumulation with error output enabled.");
                            }
                            else {
                                console.info("Please refer to the error output for details.");
                            }
                        }
                    }
                };
                /**
                 * Extracted progress bar code from proceed(), transpiled to not yet implemented comment in JS
                 * @private
                 */
                /*private*/ Experiment.prototype.showProgressBar = function () {
                    //Not yet implemented
                };
                /*private*/ Experiment.prototype.disasterRecovery = function (e) {
                    console.error("disaster recovery");
                    this.report();
                    this.finish();
                    this._status = Experiment.ABORTED;
                    console.error(e.message, e);
                };
                /**
                 * Sets the delay between each step of the scheduler.
                 *
                 * @param {number} delay
                 * : Delay time in milliseconds as a long value
                 * @author Nicolas Knaak
                 */
                Experiment.prototype.setDelayInMillis = function (delay) {
                    this._delayInMillis = delay;
                };
                /**
                 * Returns the delay between each step of the scheduler
                 *
                 * @return {number} A long value representing the delay time in milliseconds
                 * @author Nicolas Knaak
                 *
                 */
                Experiment.prototype.getDelayInMillis = function () {
                    return this._delayInMillis;
                };
                /**
                 * Registers a file output (Report, Trace, Error, Debug) in specific formats
                 * (e.g. HTML, ASCII, XML) at the experiment. Registered files will be
                 * flushed and closed after the experiment has finished. This is handy for
                 * modellers producing their own output who want their files to be closed at
                 * the end of the experiment.
                 *
                 * @param {*} file
                 * desmoj.report.FileOutput : The file to be closed with the end
                 * of an experiment
                 */
                Experiment.prototype.register = function (file) {
                    if (file == null) {
                        this.sendWarning("Can not register OutputType! Command ignored.", "Experiment \'" + this.getName() + "\' method void register(OutputType file).", "The parameter given was a null reference.", "Make sure to only connect valid OutputType at the Experiment.");
                        return;
                    }
                    if ((this._registryOutputType.indexOf((file)) >= 0))
                        return;
                    /* add */ (this._registryOutputType.push(file) > 0);
                };
                /**
                 * Registers a custom file output at the experiment, e.g. TimeSeries
                 * plotting data to a file. Registered files will be flushed and closed
                 * after the experiment has finished. This is handy for modellers producing
                 * their own output who want their files to be closed at the end of the
                 * experiment.
                 *
                 * @param {desmoj.core.report.FileOutput} file
                 * desmoj.report.FileOutput : The file to be closed with the end
                 * of an experiment
                 */
                Experiment.prototype.registerFileOutput = function (file) {
                    if (file == null) {
                        this.sendWarning("Can not register FileOutput! Command ignored.", "Experiment \'" + this.getName() + "\' method void register(OutputType file).", "The parameter given was a null reference.", "Make sure to only connect valid FileOutput at the Experiment.");
                        return;
                    }
                    if ((this._registryFileOutput.indexOf((file)) >= 0))
                        return;
                    /* add */ (this._registryFileOutput.push(file) > 0);
                };
                /**
                 * Connects a model to this experiment. The given model must not be submodel
                 * of other models and not already be connected to some other experiment.
                 * Otherwise an errormessage will be given and the experiment will be
                 * stopped.
                 * @param {desmoj.core.simulator.Model} mainModel
                 */
                Experiment.prototype.registerModel = function (mainModel) {
                    if (mainModel == null) {
                        this.sendWarning("Can not register model at experiment! Command ignored.", "Experiment \'" + this.getName() + "\', Method \'void registerModel(Model mainModel)\'", "The parameter passed was a null reference.", "Make sure to connect a valid main model to this experiment.");
                        return;
                    }
                    if (mainModel.getModel() != null) {
                        this.sendWarning("Can not register model at experiment! Command ignored.", "Experiment \'" + this.getName() + "\', Method \'void registerModel(Model mainModel)\'", "The model references another model as its owner, thus can not be the main model.", "Make sure to connect a valid main model to this experiment.");
                        return;
                    }
                    if (this.isConnected()) {
                        this.sendWarning("Can not register model at experiment! Command ignored.", "Experiment \'" + this.getName() + "\', Method \'void registerModel(Model mainModel)\'", "This experiment is already connected to model : " + this._client.getName(), "An experiment may only be connected to one main model at a time.");
                        return;
                    }
                    this._status = Experiment.CONNECTED;
                    this._client = mainModel;
                    this._client.setMain();
                };
                /**
                 * Removes a messagereceiver for debugnotes from the experiment's
                 * messagedistributor. Whenever a model produces a message of that type, it
                 * will not be sent to the given messagereceiver anymore. Note that if the
                 * messagereceiver is also registered for other types of messages, these
                 * will not be affected. Use method
                 * <code>removeReceiverAll(MessageReceiver msgRec)</code> to remove a
                 * messagereceiver from all types of messages.
                 *
                 * @param {*} msgRec
                 * desmoj.report.MessageReceiver : The new messagereceiver to be
                 * removed from the messagedistributor's list for the given
                 * messagetype
                 */
                Experiment.prototype.removeDebugReceiver = function (msgRec) {
                    if (msgRec == null) {
                        this.sendWarning("Can not remove receiver to experiment! Command ignored.", "Experiment \'" + this.getName() + "\', Method \'void removeDebugReceiver" + "(MessageReceiver msgRec)\'", "The parameter \'msgRec\' passed was a null reference.", "Make sure to give a valid MessageReciever reference before removing it from the experiment\'s messaging system.");
                        return;
                    }
                    this._messMan.deRegister$desmoj_core_report_MessageReceiver$java_lang_Class(msgRec, Experiment.debugnote);
                };
                /**
                 * Removes a messagereceiver for errormessages from the experiment's
                 * messagedistributor. Whenever a model produces a message of that type, it
                 * will not be sent to the given messagereceiver anymore. Note that if the
                 * messagereceiver is also registered for other types of messages, these
                 * will not be affected. Use method
                 * <code>removeReceiverAll(MessageReceiver msgRec)</code> to remove a
                 * messagereceiver from all types of messages.
                 *
                 * @param {*} msgRec
                 * desmoj.report.MessageReceiver : The new messagereceiver to be
                 * removed from the vessagedistributor's list for the given
                 * messagetype
                 */
                Experiment.prototype.removeErrorReceiver = function (msgRec) {
                    if (msgRec == null) {
                        this.sendWarning("Can not remove receiver to experiment! Command ignored.", "Experiment \'" + this.getName() + "\', Method \'void removeErrorReceiver" + "(MessageReceiver msgRec)\'", "The parameter \'msgRec\' passed was a null reference.", "Make sure to give a valid MessageReciever reference before removing it from the experiment\'s messaging system.");
                        return;
                    }
                    this._messMan.deRegister$desmoj_core_report_MessageReceiver$java_lang_Class(msgRec, Experiment.errormessage);
                };
                Experiment.prototype.removeReceiver$desmoj_core_report_MessageReceiver = function (msgRec) {
                    if (msgRec == null) {
                        this.sendWarning("Can not remove receiver to experiment! Command ignored.", "Experiment \'" + this.getName() + "\', Method \'void removeReceiver(MessageReceiver " + "msgRec)\'", "The parameter \'msgRec\' passed was a null reference.", "Make sure to give a valid MessageReciever reference before removing it from the experiment\'s messaging system.");
                        return;
                    }
                    this._messMan.deRegister$desmoj_core_report_MessageReceiver(msgRec);
                };
                Experiment.prototype.removeReceiver$desmoj_core_report_MessageReceiver$java_lang_Class = function (msgRec, messageType) {
                    if (msgRec == null) {
                        this.sendWarning("Can not remove receiver to experiment! Command ignored.", "Experiment \'" + this.getName() + "\', Method \'void removeReceiver(MessageReceiver " + "msgRec, Class messageType)\'", "The parameter \'msgRec\' passed was a null reference.", "Make sure to give a valid MessageReciever reference before removing it from the experiment\'s messaging system.");
                        return;
                    }
                    if (messageType == null) {
                        this.sendWarning("Can not remove receiver to experiment! Command ignored.", "Experiment \'" + this.getName() + "\', Method \'void removeReceiver(MessageReceiver " + "msgRec, Class messageType)\'", "The parameter \'msgRec\' passed was a null reference.", "Make sure to give a valid MessageReciever reference before removing it from the experiment\'s messaging system.");
                        return;
                    }
                    this._messMan.deRegister$desmoj_core_report_MessageReceiver$java_lang_Class(msgRec, messageType);
                };
                /**
                 * Removes a messagereceiver for the given subtype of message from the
                 * Experiment's messagedistributor. Whenever a model produces a message of
                 * that type, it will not be sent to the given messagereceiver anymore. Note
                 * that if the messagereceiver is also registered for other types of
                 * messages, these will not be affected. Use method
                 * <code>removeReceiverAll(MessageReceiver msgRec)</code> to remove a
                 * messagereceiver from all types of messages.
                 *
                 * @param {*} msgRec
                 * desmoj.report.MessageReceiver : The new messagereceiver to be
                 * removed from the messagedistributor's list for the given
                 * messagetype
                 * @param {*} messageType
                 * Class : The type of message not to be sent to the given
                 * messagereceiver
                 */
                Experiment.prototype.removeReceiver = function (msgRec, messageType) {
                    if (((msgRec != null && (msgRec["__interfaces"] != null && msgRec["__interfaces"].indexOf("desmoj.core.report.MessageReceiver") >= 0 || msgRec.constructor != null && msgRec.constructor["__interfaces"] != null && msgRec.constructor["__interfaces"].indexOf("desmoj.core.report.MessageReceiver") >= 0)) || msgRec === null) && ((messageType != null) || messageType === null)) {
                        return this.removeReceiver$desmoj_core_report_MessageReceiver$java_lang_Class(msgRec, messageType);
                    }
                    else if (((msgRec != null && (msgRec["__interfaces"] != null && msgRec["__interfaces"].indexOf("desmoj.core.report.MessageReceiver") >= 0 || msgRec.constructor != null && msgRec.constructor["__interfaces"] != null && msgRec.constructor["__interfaces"].indexOf("desmoj.core.report.MessageReceiver") >= 0)) || msgRec === null) && messageType === undefined) {
                        return this.removeReceiver$desmoj_core_report_MessageReceiver(msgRec);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Removes a messagereceiver for tracenotes from the experiment's
                 * messagedistributor. Whenever a model produces a message of that type, it
                 * will not be sent to the given messagereceiver anymore. Note that if the
                 * messagereceiver is also registered for other types of messages, these
                 * will not be affected. Use method
                 * <code>removeReceiverAll(MessageReceiver msgRec)</code> to remove a
                 * messagereceiver from all types of messages.
                 *
                 * @param {*} msgRec
                 * desmoj.report.MessageReceiver : The new messagereceiver to be
                 * removed from the messagedistributor's list for the given
                 * messagetype
                 */
                Experiment.prototype.removeTraceReceiver = function (msgRec) {
                    if (msgRec == null) {
                        this.sendWarning("Can not remove receiver to experiment! Command ignored.", "Experiment \'" + this.getName() + "\', Method \'void removeTraceReceiver" + "(MessageReceiver msgRec)\'", "The parameter \'msgRec\' passed was a null reference.", "Make sure to give a valid MessageReciever reference before removing it from the experiment\'s messaging system.");
                        return;
                    }
                    this._messMan.deRegister$desmoj_core_report_MessageReceiver$java_lang_Class(msgRec, Experiment.tracenote);
                };
                /**
                 * Overrides inherited <code>NamedObjectImp.rename(String newName)</code>
                 * method to prevent the user from changing the experiment's name during an
                 * experiment. Renaming is not allowed with experiments, since it would not
                 * allow the user to identify the reports produced by an experiment. The
                 * method simply returns without changing the experiment's name, ignoring
                 * the given parameter.
                 *
                 * @param {string} newName
                 * java.lang.String : The parameter given is not taken as the new
                 * name, method simply returns
                 */
                Experiment.prototype.rename = function (newName) {
                };
                Experiment.prototype.report$ = function () {
                    this.report$desmoj_core_simulator_Model(this._client);
                };
                Experiment.prototype.report$desmoj_core_simulator_Model = function (m) {
                    var reporters;
                    if (this._status < Experiment.CONNECTED) {
                        this.sendWarning("Can not produce report! Command ignored.", "Experiment: " + this.getName() + " Method: void report(Model m).", "The Experiment has not been connected to a model to report about yet.", "Connect a model to the experiment first using the model\'s method connectToExperiment(Experiment exp).");
                        return;
                    }
                    if (this._status >= Experiment.ABORTED) {
                        return;
                    }
                    if (m == null) {
                        this.sendWarning("Can not produce report! Command ignored.", "Experiment: " + this.getName() + " Method: void report(Model m).", "The model parameter given is a null reference.", "Always make sure to use valid references.");
                        return;
                    }
                    if (m.getExperiment() !== this) {
                        this.sendWarning("Can not produce report! Command ignored.", "Experiment: " + this.getName() + " Method: void report(Model m).", "The model parameter given is connected to a different experiment.", "Only experiments connected to theat model can produce reports about that model.");
                        return;
                    }
                    reporters = m.report();
                    for (var index780 = 0; index780 < reporters.length; index780++) {
                        var r = reporters[index780];
                        {
                            this._messMan.receive$desmoj_core_report_Reporter(r);
                        }
                    }
                };
                /**
                 * Writes a report about the given model which has to be connected to this
                 * experiment as main model or as a submodel. Note that this will report
                 * about a branch of the tree of submodels constructed. A report will only
                 * be produced, if the model given is connected to this experiment. All
                 * reportable components of this model and all related submodels will be
                 * sent to the report output configured at the experiment's
                 * messagedistributor. Note that a report can only be produced, if a valid
                 * main model is already connected to the experiment.
                 * @param {desmoj.core.simulator.Model} m
                 */
                Experiment.prototype.report = function (m) {
                    if (((m != null && m instanceof desmoj.core.simulator.Model) || m === null)) {
                        return this.report$desmoj_core_simulator_Model(m);
                    }
                    else if (m === undefined) {
                        return this.report$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Creates and sends a debugnote to the messagedistributor. Be sure to have
                 * a correct location, since the object and method that the error becomes
                 * apparent is not necessary the location it was produced in. The
                 * information about the simulation time is extracted from the Experiment
                 * and must not be given as a parameter.
                 *
                 * @param {string} description
                 * java.lang.String : The description of the error that occured
                 * @param {string} component
                 */
                Experiment.prototype.sendDebugNote = function (component, description) {
                    this.sendMessage(new desmoj.core.report.DebugNote(this.clientScheduler.getCurrentModel(), this.clientScheduler.getSimClock().getTime(), component, description));
                };
                /**
                 * Sends a message to the messagedistributor. Note that there are other
                 * shorthands for sending the standard DESMO-J messages.
                 *
                 * @param {desmoj.core.report.Message} m
                 * Message : The Message to be transmitted
                 * @see ModelComponent#sendTraceNote
                 * @see ModelComponent#sendDebugNote
                 * @see ModelComponent#sendWarning
                 */
                Experiment.prototype.sendMessage = function (m) {
                    if (m == null) {
                        this.sendWarning("Can\'t send Message!", "Experiment :" + this.getName() + " Method: SendMessage(Message m)", "The Message given as parameter is a null reference.", "Be sure to have a valid Message reference.");
                        return;
                    }
                    if (!this._error && (m != null && m instanceof desmoj.core.report.ErrorMessage)) {
                        this._error = true;
                    }
                    this._messMan.receive$desmoj_core_report_Message(m);
                };
                /**
                 * Creates and sends an error message to the messagedistributor to warn the
                 * modeller that some conditions required by the framework are not met. Be
                 * sure to have a correct location, since the object and method that the
                 * error becomes apparent is not necessary the location it was produced in.
                 * The information about the simulation time is extracted from the
                 * experiment and must not be given as a parameter.
                 *
                 * @param {string} description
                 * java.lang.String : The description of the error that occured
                 * @param {string} location
                 * java.lang.String : The class and method the error occured in
                 * @param {string} reason
                 * java.lang.String : The reason most probably responsible for
                 * the error to occur
                 * @param {string} prevention
                 * java.lang.String : The measures a user should take to prevent
                 * this warning to be issued again
                 */
                Experiment.prototype.sendWarning = function (description, location, reason, prevention) {
                    this.sendMessage(new desmoj.core.report.ErrorMessage(this.clientScheduler.getCurrentModel(), description, location, reason, prevention, this.clientScheduler.getSimClock().getTime()));
                };
                /**
                 * Sets the <code>TimeFormatter</code> to be used for output of time strings.
                 * Observe that if this method is called <i>before</i> creating an <code>Experiment</code>
                 * object, a non-null <code>TimeFormatter</code> passed to the <code>Experiment</code>'s
                 * constructor will overwrite the setting of this method-
                 *
                 * @param {*} format
                 * TimeFormatter : the formatter to be used for formatting time
                 * Strings.
                 */
                Experiment.setTimeFormatter = function (format) {
                    desmoj.core.simulator.TimeOperations.setTimeFormatter(format, true);
                };
                /**
                 * Sets the speed rate for an execution that is proportional to wall-clock
                 * time (real time). Set the speed rate to a value bigger than zero for a
                 * simulation that will progress proportional to wall-clock time. The
                 * following equation applies for speed rates >0 : rate*simulation time =
                 * wallclock-time. If the speed rate is 0 or less the simulation will be
                 * executed as fast as possible. Default is 0 (as-fast-as-possible).
                 *
                 * @param {number} rate
                 * double : The execution speed rate
                 */
                Experiment.prototype.setExecutionSpeedRate = function (rate) {
                    this.clientScheduler.setExecutionSpeedRate(rate);
                };
                /**
                 * Sets the seed of the SeedGenerator to the given value. If the seed is not
                 * set here, its default is 979, unless specified different in the
                 * ExperimentOptions.
                 *
                 * @param {number} seed
                 * long : The seed for the SeedGenerator
                 */
                Experiment.prototype.setSeedGenerator = function (seed) {
                    this._distMan.setSeed(seed);
                };
                /**
                 * Sets the underlying pseudo random number generator to be used by all
                 * distributions created from now on. The default generator is
                 * LinearCongruentialRandomGenerator; any other generator to be used must
                 * implement the interface UniformRandomGenerator.
                 *
                 * @see desmoj.core.dist.LinearCongruentialRandomGenerator
                 * @see desmoj.core.dist.UniformRandomGenerator
                 *
                 * @param {*} randomNumberGenerator
                 * Class : The random number generator class to be used
                 */
                Experiment.prototype.setRandomNumberGenerator = function (randomNumberGenerator) {
                    var classValid = true;
                    classValid = this.checkRandomGeneratorClassValidity(randomNumberGenerator);
                    if (classValid) {
                        this._distMan.setRandomNumberGenerator(randomNumberGenerator);
                    }
                    else {
                        this.sendWarning("Invalid random number generator given! Method call ignored!", "Experiment \'" + this.getName() + "\', Method \'setRandomNumberGenerator(Class randomNumberGenerator)\'", "The class provided \'" + (function (c) { return c["__class"] ? c["__class"].substring(c["__class"].lastIndexOf('.') + 1) : c["name"].substring(c["name"].lastIndexOf('.') + 1); })(randomNumberGenerator) + "\' is abstract or does not implement the interface" + " desmoj.core.dist.UniformRandomGenerator.", "Make sure to use a non-abstract class that implements the interface desmoj.core.dist.UniformRandomGenerator.");
                    }
                };
                /**
                 * Check whether the given class is valid random generator in JavaScript //[REFLECT]
                 * @param {*} randomNumberGenerator
                 * @return {boolean} true if random generator is valid
                 * @private
                 */
                /*private*/ Experiment.prototype.checkRandomGeneratorClassValidity = function (randomNumberGenerator) {
                    throw Object.defineProperty(new Error("Not yet implemented"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.UnsupportedOperationException', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.Exception'] });
                };
                /**
                 * Sets the underlying event list to be used be the experiment.
                 * Entries already present in the current event list (if any) will be copied across.
                 *
                 * @see desmoj.core.simulator.EventTreeList, FIFO order
                 * @see desmoj.core.simulator.SortedMapEventList, FIFO order
                 * @see desmoj.core.simulator.RandominzingEventTreeList, random order
                 *
                 * @param {*} eventList
                 * Class : The event list class to be used
                 */
                Experiment.prototype.setEventList = function (eventList) {
                    var classValid = true;
                    classValid = this.checkEventListClassValidity(eventList);
                    var el = null;
                    if (classValid) {
                        try {
                            el = new eventList();
                        }
                        catch (__e) {
                            if (__e != null && (__e["__classes"] && __e["__classes"].indexOf("java.lang.InstantiationException") >= 0)) {
                                var ex = __e;
                            }
                            if (__e != null && (__e["__classes"] && __e["__classes"].indexOf("java.lang.IllegalAccessException") >= 0)) {
                                var ex = __e;
                            }
                        }
                        ;
                    }
                    if (el != null) {
                        this.clientScheduler.switchEventList(el);
                    }
                    else {
                        this.sendWarning("Invalid event list classs given! Method call ignored!", "Experiment \'" + this.getName() + "\', Method \'setEventList(Class eventList)\'", "The class provided \'" + (function (c) { return c["__class"] ? c["__class"].substring(c["__class"].lastIndexOf('.') + 1) : c["name"].substring(c["name"].lastIndexOf('.') + 1); })(eventList) + "\' is abstract or no subclass of desmoj.core.simulator.EventList.", "Make sure to use a non-abstract class that inherits from desmoj.core.simulator.EventList.");
                    }
                };
                /**
                 * Check whether the given class is valid event list in JavaScript //[REFLECT]
                 * @param {*} eventList
                 * @return {boolean} true if event list is valid
                 * @private
                 */
                /*private*/ Experiment.prototype.checkEventListClassValidity = function (eventList) {
                    throw Object.defineProperty(new Error("Not yet implemented"), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.UnsupportedOperationException', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.Exception'] });
                };
                /**
                 * Sets the new value for showing the progress bar for this experiment or
                 * not. Must be called before the experiment is started.
                 *
                 * @param {boolean} newShowProgressBar
                 * boolean : set it to <code>true</code> if a progress bar should
                 * be displayed; for not showing the progress bar of this
                 * experiment set it to <code>false</code>.
                 */
                Experiment.prototype.setShowProgressBar = function (newShowProgressBar) {
                    this._showProgressBar = newShowProgressBar;
                };
                /**
                 * Sets the new value for automatically dismissing the progress bar
                 * for this experiment after completion. <p>
                 * Not that a call to this method has no impact if the progress bar
                 * is suppessed by invoking <code>setShowProgressBar(false)</code>.
                 * Must be called before the experiment is started.
                 *
                 * @param {boolean} autoclose
                 * boolean : if set to <code>true</code>, the progress bar will be
                 * automaticalled closed one the experiment terminates. If set to
                 * <code>false</code> (default), the progress bar window persists after the
                 * experiment terminates until closed by the user.
                 */
                Experiment.prototype.setShowProgressBarAutoclose = function (autoclose) {
                    this._showProgressBarAutoclose = autoclose;
                };
                /**
                 * Returns if the progress bar windows should be automatically closed after
                 * the experiment or not.
                 * Note that the result of this method is meaningless if displaying the progress bar
                 * has been suppessed by invoking <code>setShowProgressBar(false)</code>.
                 *
                 * @return {boolean} boolean :<code>true</code> if a progress bar should be automatically
                 * closed after this experiment, while <code>false</code> (default) indicates
                 * that the progress bar window persists after the experiment terminates
                 * until closed by the user..
                 */
                Experiment.prototype.isShowProgressBarAutoclose = function () {
                    return this._showProgressBarAutoclose;
                };
                /**
                 * Sets the epsilon value representing the granularity of simulation time to
                 * the given TimeUnit parameter. Should not be called after time objects
                 * (<code>TimeInstant</code>, <code>TimeSpan</code>) have been created as
                 * existing <code>TimeSpan</code> and <code>TimeInstant</code> objects will
                 * point to wrong spans/durations.
                 * Default is <code>TimeUnit.MICROSECONDS</code>.
                 *
                 * @param {def.TimeUnit} epsilon
                 * TimeUnit : The granularity of simulation time, i.e. the
                 * smallest distinguishable span of simulation time.
                 */
                Experiment.setEpsilon = function (epsilon) {
                    if (!def.TimeUnit["_$wrappers"][epsilon].equals(desmoj.core.simulator.TimeOperations.getEpsilon()) && desmoj.core.simulator.TimeOperations.timeObjectsCreated) {
                        console.info("Warning    : Internal time granularity epsilon has changed after already creating time objects.");
                        console.info("description: Existing TimeSpan and TimeInstant objects will point to wrong spans/durations.");
                        console.info("origin     : Experiment auxiliaries");
                        console.info("location   : TimeOperations.setEpsilon(" + epsilon + ")");
                        console.info("hint       : Be sure to first set epsilon before creating TimeInstants and TimeSpan");
                        console.info("             afterwards. For example, use your model\'s init()-method to create time objects, but");
                        console.info("             not the model\'s constructor. The latter is often invoked before creating an experiment.");
                    }
                    desmoj.core.simulator.TimeOperations.setEpsilonUnit(epsilon);
                };
                /**
                 * Sets the reference time unit specifying what is meant by the simulation
                 * time step of 1 in statements without an explicit declaration of a time
                 * unit like in <code>new TimeSpan(5)</code>.
                 * Default is <code>TimeUnit.SECONDS</code>.
                 *
                 * @param {def.TimeUnit} referenceUnit
                 * TimeUnit : the reference time unit
                 *
                 */
                Experiment.setReferenceUnit = function (referenceUnit) {
                    desmoj.core.simulator.TimeOperations.setReferenceUnitX(referenceUnit);
                };
                /**
                 * Sets the new value for displaying basic experiment notifications like
                 * 'experiment started', 'experiment stopped' oder 'experiment resumed'
                 * at the system output.
                 *
                 * @param {boolean} silent
                 * boolean : set it to <code>true</code> to suppress notifications
                 * or <code>false</code> to print them.
                 */
                Experiment.prototype.setSilent = function (silent) {
                    this._silent = silent;
                };
                /**
                 * Sets the experiment's status to the given integer value. The value must
                 * be in the legal range of [-1,5], otherwise a warning is issued.
                 *
                 * @param {number} newStatus
                 * int : The integer value of the experiments' new status
                 */
                Experiment.prototype.setStatus = function (newStatus) {
                    if ((newStatus < -1) || (newStatus > 5)) {
                        this.sendWarning("Can not start experiment! Command ignored.", "Experiment \'" + this.getName() + "\', Method \'start\'", "No main model\'s connectToExperiment(Experiment e) method was called.", "Make sure to connect a valid main model first before starting this experiment.");
                        return;
                    }
                    else
                        this._status = newStatus;
                };
                Experiment.prototype.start$ = function () {
                    if (this._status === Experiment.STOPPED)
                        this.proceed();
                    else {
                        this.start$desmoj_core_simulator_TimeInstant(new desmoj.core.simulator.TimeInstant(0));
                    }
                };
                Experiment.prototype.start$desmoj_core_simulator_TimeInstant = function (initTime) {
                    if (this._status < Experiment.CONNECTED) {
                        this.sendWarning("Can not start experiment! Command ignored.", "Experiment: " + this.getName() + " Method: void start(SimTime initTime)", "The Experiment has not been connected to a model to report about yet.", "Connect a model to the experiment first using the model\'s method connectToExperiment(Experiment exp).");
                        return;
                    }
                    if (this._status > Experiment.CONNECTED) {
                        this.sendWarning("Can not start experiment! Command ignored.", "Experiment: " + this.getName() + " Method: void start(SimTime initTime)", "The Experiment has already been started before.", "An experiment can only be started once. If it has been stopped, it can be issued to continue using method proceed()");
                        return;
                    }
                    if (initTime != null) {
                        this.clientScheduler.getSimClock().setInitTime(initTime);
                        if (!desmoj.core.simulator.TimeInstant.isEqual(initTime, new desmoj.core.simulator.TimeInstant(0))) {
                            this._client.reset();
                        }
                    }
                    else {
                        this.clientScheduler.getSimClock().setTime(new desmoj.core.simulator.TimeInstant(0));
                        this.sendWarning("Invalid start time parameter given! Start time set to " + this.clientScheduler.presentTime() + ".", "Experiment: \'" + this.getName() + "\', Method: void start(SimTime initTime)", "A null calue or a not initialized TimeInstant reference has been passed.", "Make sure to have a valid TimeInstnat object, otherwise use method start() without TimeInstant parameter.");
                    }
                    this._client.doInitialSchedules();
                    this._client.doSubmodelSchedules();
                    desmoj.core.simulator.TimeOperations.setStartTime(initTime);
                    this._client.register(new desmoj.core.report.SimulationRunReporter.SimulationRunReporterProvider(this._client));
                    this._status = Experiment.STARTED;
                    this._realTimeStartTime = def.System.nanoTime();
                    this.proceed();
                };
                /**
                 * Starts the experiment with the given simulation time as starting time.
                 * The experiment will not start unless a valid model has been connected to
                 * it before. Note that in order to stop the simulation at some point of
                 * time, the <code>stop</code> method has to be called first.
                 * <code>StopCondition</code> s can be given alternatively.
                 *
                 * @param {desmoj.core.simulator.TimeInstant} initTime
                 * TimeInstant : The starting time instant
                 */
                Experiment.prototype.start = function (initTime) {
                    if (((initTime != null && initTime instanceof desmoj.core.simulator.TimeInstant) || initTime === null)) {
                        return this.start$desmoj_core_simulator_TimeInstant(initTime);
                    }
                    else if (initTime === undefined) {
                        return this.start$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                Experiment.prototype.stop$desmoj_core_simulator_ModelCondition = function (stopCond) {
                    if (stopCond == null) {
                        this.sendWarning("Can not set stop-condition! Command ignored.", "Experiment \'" + this.getName() + "\', Method \'stop(Condition stopCond)\'", "The parameter passed was either null or a not initialized Condition reference.", "Make sure to provide a valid stop Condition for this experiment.");
                    }
                    else {
                        /* add */ (this._stopConditions.push(stopCond) > 0);
                    }
                };
                /**
                 * Specifies a ModelCondition to stop the simulation. Note that this methode can
                 * be called muliple times, defining alternative conditions to terminate the
                 * simulation. Once at least one of the conditions passed using this method
                 * returns true, the experiment will stop.
                 * Beware that the simulation will run endlessly if none of the conditions
                 * are met; thus it is recommended to additionally always use a time limit
                 * if none of the conditions in question can be proven to be met during the
                 * run of the simulation!
                 *
                 * @param {desmoj.core.simulator.ModelCondition} stopCond
                 * ModelCondition : A condition to stop the simulation once
                 * it's check() methode returns true.
                 */
                Experiment.prototype.stop = function (stopCond) {
                    if (((stopCond != null && stopCond instanceof desmoj.core.simulator.ModelCondition) || stopCond === null)) {
                        return this.stop$desmoj_core_simulator_ModelCondition(stopCond);
                    }
                    else if (((stopCond != null && stopCond instanceof desmoj.core.simulator.TimeInstant) || stopCond === null)) {
                        return this.stop$desmoj_core_simulator_TimeInstant(stopCond);
                    }
                    else if (stopCond === undefined) {
                        return this.stop$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                Experiment.prototype.stop$desmoj_core_simulator_TimeInstant = function (stopTime) {
                    if (stopTime == null) {
                        this.sendWarning("Can not set stop-time! The stop-time will be set to 0", "Experiment \'" + this.getName() + "\', Method: \'stop(TimeInstant stopTime)\'", "The parameter passed was either null or a not initialized TimeInstance reference.", "Pass an initialized TimeInstant object as stop time.");
                        var stopper = new desmoj.core.simulator.ExternalEventStop(this._client, "Simulation stopped", true);
                        stopper.schedule$desmoj_core_simulator_TimeInstant(new desmoj.core.simulator.TimeInstant(0));
                    }
                    else {
                        this._stopTime = stopTime;
                        if (this._stopTimeEvent != null)
                            this._stopTimeEvent.cancel();
                        this._stopTimeEvent = new desmoj.core.simulator.ExternalEventStop(this._client, "Simulation stopped", true);
                        this._stopTimeEvent.schedule$desmoj_core_simulator_TimeInstant(stopTime);
                    }
                };
                Experiment.prototype.stop$ = function () {
                    this.setStatus(Experiment.STOPPED);
                    this.clientScheduler.signalStop();
                };
                /**
                 * Returns a boolean indicating whether trace notes are forwarded to the
                 * trace ouput or not. Trace ouput can be switched on and off using the
                 * methods <code>traceOn(TimeInstant startTime)</code> and
                 * <code>traceOff(TimeInstant stopTime)</code>
                 *
                 * @return {boolean} boolean : Is <code>true</code>
                 */
                Experiment.prototype.traceIsOn = function () {
                    return this._messMan.isOn(Experiment.tracenote);
                };
                /**
                 * Switches the trace output off at the given point of simulation time.
                 *
                 * @param {desmoj.core.simulator.TimeInstant} stopTime
                 * TimeInstant : The point in simulation time to switch trace off
                 */
                Experiment.prototype.traceOff = function (stopTime) {
                    if (stopTime == null) {
                        this.sendWarning("Invalid start time parameter for trace output given! Trace output is set to start immediately.", "Experiment \'" + this.getName() + "\', Method \'traceOn(TimeInstant startTime)\'", "A null value or a not initialized TimeInstant reference has been passed.", "Make sure to have a valid TimeInstant object, otherwise use method start() without TimeInstant parameter.");
                        stopTime = this.clientScheduler.presentTime();
                    }
                    if (desmoj.core.simulator.TimeInstant.isAfter(this.clientScheduler.presentTime(), stopTime)) {
                        this.sendWarning("Invalid start time parameter for trace output given! Trace output is set to start immediately.", "Experiment \'" + this.getName() + "\', Method \'traceOn(TimeInstant stopTime)\'", "The stopTime given is in the past.", "Make sure to give a TimeInstant parameter larger than the current time.");
                        stopTime = this.clientScheduler.presentTime();
                    }
                    var traceOff = new desmoj.core.simulator.ExternalEventTraceOff(this._client, true);
                    traceOff.schedule$desmoj_core_simulator_TimeInstant(stopTime);
                };
                /**
                 * Switches the trace output on at the given point of simulation time.
                 *
                 * @param {desmoj.core.simulator.TimeInstant} startTime
                 * TimeInstant : The point in simulation time to switch trace on
                 */
                Experiment.prototype.traceOn = function (startTime) {
                    if (startTime == null) {
                        this.sendWarning("Invalid start time parameter for trace output given! Trace output is set to start immediately.", "Experiment \'" + this.getName() + "\', Method \'traceOn(TimeInstant startTime)\'", "A null value or a not initialized TimeInstant reference has been passed.", "Make sure to have a valid TimeInstant object, otherwise use method start() without TimeInstant parameter.");
                        startTime = this.clientScheduler.presentTime();
                    }
                    if (desmoj.core.simulator.TimeInstant.isAfter(this.clientScheduler.presentTime(), startTime)) {
                        this.sendWarning("Invalid start time parameter for trace output given! Trace output is set to start immediately.", "Experiment \'" + this.getName() + "\', Method \'traceOn(TimeInstant startTime)\'", "The startTime given is in the past.", "Make sure to give a TimeInstant parameter larger than the current time.");
                        startTime = this.clientScheduler.presentTime();
                    }
                    if (desmoj.core.simulator.TimeInstant.isEqual(this.clientScheduler.presentTime(), startTime)) {
                        this.getMessageManager().switchOn(Experiment.tracenote);
                        this._client.sendTraceNote("Trace switched on");
                    }
                    else {
                        var traceOn = new desmoj.core.simulator.ExternalEventTraceOn(this._client, true);
                        traceOn.schedule$desmoj_core_simulator_TimeInstant(startTime);
                    }
                };
                /**
                 * Switches the trace output on for the given period of simulation time. If
                 * the second parameter (off) is "sooner" then the first parameter (on),
                 * they will be swapped automatically. Same parameters will result in no
                 * trace output at all.
                 *
                 * @param {desmoj.core.simulator.TimeInstant} startTime
                 * TimeInstant : The point in simulation time to switch trace on
                 * @param {desmoj.core.simulator.TimeInstant} stopTime
                 * TimeInstant : The point in simulation time to switch trace off
                 */
                Experiment.prototype.tracePeriod = function (startTime, stopTime) {
                    if (startTime == null) {
                        this.sendWarning("Invalid start time parameter for trace output given! Command ignored", "Experiment \'" + this.getName() + "\', Method \'tracePeriod(TimeInstant startTime, " + "TimeInstant stopTime)\'", "A null value or a not initialized TimeInstant reference has been passed.", "Make sure to have a valid TimeInstant object.");
                        return;
                    }
                    if (stopTime == null) {
                        this.sendWarning("Invalid stop time parameter for trace output given! Command ignored.", "Experiment \'" + this.getName() + "\', Method \'tracePeriod(TimeInstant startTime, " + "TimeInstant stopTime)\'", "A null value or a not initialized TimeInstant reference has been passed.", "Make sure to have a valid TimeInstant object.");
                        return;
                    }
                    if (desmoj.core.simulator.TimeInstant.isAfter(startTime, stopTime)) {
                        var buffer = stopTime;
                        stopTime = startTime;
                        startTime = buffer;
                    }
                    if (desmoj.core.simulator.TimeInstant.isAfter(this.clientScheduler.presentTime(), stopTime)) {
                        this.sendWarning("Invalid stop time parameter for trace output given! Command ignored.", "Experiment \'" + this.getName() + "\', Method \'tracePeriod(TimeInstant startTime, " + "TimeInstant stopTime)\'", "The stopTime given is in the past.", "Make sure to give a TimeInstant parameter larger than the current time.");
                        return;
                    }
                    if (desmoj.core.simulator.TimeInstant.isAfter(this.clientScheduler.presentTime(), startTime)) {
                        this.sendWarning("Invalid start time parameter for trace output given! Trace output has been set to start immediately.", "Experiment \'" + this.getName() + "\', Method \'tracePeriod(TimeInstant startTime, " + "TimeInstant startTime)\'", "The startTime given is in the past.", "Make sure to give a TimeInstant parameter larger than the current time.");
                        startTime = this.clientScheduler.presentTime();
                    }
                    this.traceOn(startTime);
                    this.traceOff(stopTime);
                };
                Experiment.prototype.writeReport$desmoj_core_simulator_Model$java_lang_String = function (m, suffix) {
                    if (suffix == null)
                        suffix = "";
                    var nameBuffer = null;
                    for (var index781 = 0; index781 < this._registryFileOutput.length; index781++) {
                        var f = this._registryFileOutput[index781];
                        {
                            nameBuffer = f.getFileName();
                            f.close();
                            nameBuffer = nameBuffer.substring(0, nameBuffer.lastIndexOf("."));
                            f.open$java_lang_String(nameBuffer.substring(0, (nameBuffer.length - Experiment.lastSuffix)) + suffix + "html");
                        }
                    }
                    Experiment.lastSuffix = suffix.length;
                    this.report$desmoj_core_simulator_Model(m);
                };
                /**
                 * Triggers the reporters of the given model or submodel to write their
                 * report data into the report output registered at the experiment's
                 * messagemanager. The string given will be added as a suffix to the report
                 * filename to help identify teh report when more than one report is
                 * produced by one Experiment at differnet points of simulation time.
                 *
                 * @param {desmoj.core.simulator.Model} m
                 * desmoj.Model
                 * @param {string} suffix
                 * java.lang.String : Suffix for report filename if multiple
                 * reports are drawn
                 */
                Experiment.prototype.writeReport = function (m, suffix) {
                    if (((m != null && m instanceof desmoj.core.simulator.Model) || m === null) && ((typeof suffix === 'string') || suffix === null)) {
                        return this.writeReport$desmoj_core_simulator_Model$java_lang_String(m, suffix);
                    }
                    else if (((typeof m === 'string') || m === null) && suffix === undefined) {
                        return this.writeReport$java_lang_String(m);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Experiment.prototype.writeReport$java_lang_String = function (suffix) {
                    if (suffix == null)
                        suffix = "";
                    this.report$desmoj_core_simulator_Model(this._client);
                    var nameBuffer = null;
                    for (var index782 = 0; index782 < this._registryFileOutput.length; index782++) {
                        var f = this._registryFileOutput[index782];
                        {
                            nameBuffer = f.getFileName();
                            f.close();
                            nameBuffer = nameBuffer.substring(0, nameBuffer.lastIndexOf("_"));
                            nameBuffer = nameBuffer.substring(0, nameBuffer.length - Experiment.lastSuffix);
                            nameBuffer = nameBuffer + suffix;
                            f.open$java_lang_String(nameBuffer);
                        }
                    }
                    Experiment.lastSuffix = suffix.length;
                };
                /**
                 * Returns the current DESMO-J version
                 *
                 * @return {string} The string "2.5.1e".
                 */
                Experiment.getDesmoJVersion = function () {
                    return "2.5.1e";
                };
                /**
                 * Returns the DESMO-J license
                 *
                 * @param {boolean} html
                 * boolean: Include link (HTML, true) or not (plain text, false)
                 *
                 * @return {string} The string "Apache License, Version 2.0", embedded in a HTML link
                 * tag (currently http://www.apache.org/licenses/LICENSE-2.0) if
                 * <code>html</code> is set true.
                 */
                Experiment.getDesmoJLicense = function (html) {
                    return html ? "<A HREF=http://www.apache.org/licenses/LICENSE-2.0>Apache License, Version 2.0</A>" : "Apache License, Version 2.0";
                };
                return Experiment;
            }(desmoj.core.simulator.NamedObject));
            /**
             *
             * The default report output
             */
            Experiment.DEFAULT_REPORT_OUTPUT_TYPE = "desmoj.core.report.HTMLReportOutput";
            /**
             *
             * The default trace output
             */
            Experiment.DEFAULT_TRACE_OUTPUT_TYPE = "desmoj.core.report.HTMLTraceOutput";
            /**
             *
             * The default error output
             */
            Experiment.DEFAULT_ERROR_OUTPUT_TYPE = "desmoj.core.report.HTMLErrorOutput";
            /**
             *
             * The default debug output
             */
            Experiment.DEFAULT_DEBUG_OUTPUT_TYPE = "desmoj.core.report.HTMLDebugOutput";
            /**
             * Status of an Experiment just created without any accessories created yet.
             */
            Experiment.NOT_INITIALIZED = -3;
            /**
             * Status of an Experiment instantiated with all needed accessories
             * available.
             */
            Experiment.INITIALIZED = -2;
            /**
             * Status of an Experiment connected to a Model and ready to be started.
             */
            Experiment.CONNECTED = -1;
            /**
             * Status of an Experiment being started. Only if an Experiment is
             */
            Experiment.STARTED = 0;
            /**
             * Status of an Experiment stopped after having run.
             */
            Experiment.STOPPED = 1;
            /**
             * Status of an Experiment currently running the simulation.
             */
            Experiment.RUNNING = 2;
            /**
             * Status of an Experiment finished and to be cleared.
             */
            Experiment.ABORTED = 3;
            /**
             * The last suffix used with filenames when creating multiple batch runs of
             * an experiment.
             */
            Experiment.lastSuffix = 0;
            /**
             * The class reference to messages of type desmoj.core.report.TraceNote
             */
            Experiment.tracenote = null;
            /**
             * The class reference to messages of type desmoj.core.report.DebugNote
             */
            Experiment.debugnote = null;
            /**
             * The class reference to messages of type desmoj.core.report.ErrorMessage
             */
            Experiment.errormessage = null;
            /**
             * The class reference to messages of type desmoj.core.report.Reporter
             */
            Experiment.reporter = null;
            simulator.Experiment = Experiment;
            Experiment["__class"] = "desmoj.core.simulator.Experiment";
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Constructs a modelcomponent with the given String as name and the given
             * model as the associated owner of this component. Components can thus only
             * be created after the corresponding model object has been instantiated.
             *
             * @param {string} name
             * java.lang.String : The name of the component
             * @param {desmoj.core.simulator.Model} ownerModel
             * Model : The model this component is associated to
             * @param {boolean} showInTrace
             * boolean : Flag for showing component in trace-files. Set it to
             * <code>true</code> if component should show up in trace. Set it
             * to <code>false</code> if component should not be shown in
             * trace.
             * @class
             * @extends desmoj.core.simulator.NamedObject
             * @author Tim Lechler
             */
            var ModelComponent = (function (_super) {
                __extends(ModelComponent, _super);
                function ModelComponent(ownerModel, name, showInTrace) {
                    var _this = this;
                    if (((ownerModel != null && ownerModel instanceof desmoj.core.simulator.Model) || ownerModel === null) && ((typeof name === 'string') || name === null) && ((typeof showInTrace === 'boolean') || showInTrace === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        _this = _super.call(this, name) || this;
                        _this._owner = null;
                        _this._traceMode = false;
                        _this._debugMode = false;
                        _this._owner = null;
                        _this._traceMode = false;
                        _this._debugMode = false;
                        (function () {
                            _this._owner = ownerModel;
                            _this._traceMode = showInTrace;
                        })();
                    }
                    else if (((ownerModel != null && ownerModel instanceof desmoj.core.simulator.Model) || ownerModel === null) && ((typeof name === 'string') || name === null) && showInTrace === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        {
                            var __args_20 = Array.prototype.slice.call(arguments);
                            var showInTrace_1 = false;
                            _this = _super.call(this, name) || this;
                            _this._owner = null;
                            _this._traceMode = false;
                            _this._debugMode = false;
                            _this._owner = null;
                            _this._traceMode = false;
                            _this._debugMode = false;
                            (function () {
                                _this._owner = ownerModel;
                                _this._traceMode = showInTrace_1;
                            })();
                        }
                    }
                    else
                        throw new Error('invalid overload');
                    return _this;
                }
                /**
                 * Returns the currently active Schedulable object that is handled by the
                 * scheduler.
                 *
                 * @return {desmoj.core.simulator.Schedulable} Schedulable : The current Schedulable object.
                 */
                ModelComponent.prototype.current = function () {
                    return this._owner.getExperiment().getScheduler().getCurrentSchedulable();
                };
                /**
                 * Returns the currently active Entity. Returns <code>null</code> if the current
                 * Schedulable happens to be an external event or a SimProcess.
                 * Note that in case the current Event refers to more than one entity
                 * (<code>EventTwoEntitties</code>, <code>EventThreeEntitties</code>),
                 * only the first entity is returned; to obtain all such entities,
                 * use <code>getAllCurrentEntities()</code> instead.
                 *
                 * @return {desmoj.core.simulator.Entity} Entity : The currently active Entity or
                 * <code>null</code> in case of an external event or a SimProcess
                 * being the currently active Schedulable
                 */
                ModelComponent.prototype.currentEntity = function () {
                    return this._owner.getExperiment().getScheduler().getCurrentEntity();
                };
                /**
                 * Returns the currently active entities. Returns an empty list
                 * if the current Schedulable happens to be an external event or a SimProcess.
                 *
                 * @return {desmoj.core.simulator.Entity[]} List<Entity> : A list containing the currently active entities
                 */
                ModelComponent.prototype.currentEntityAll = function () {
                    return this._owner.getExperiment().getScheduler().getAllCurrentEntities();
                };
                /**
                 * Returns the currently active Event that is handled by the scheduler. It
                 * returns <code>null</code> if a process Event is the current active
                 * Schedulable, thus no Event is active.
                 *
                 * @return {desmoj.core.simulator.EventAbstract} Event : The current active Event or <code>null</code> if the
                 * current active Schedulable is a process
                 *
                 */
                ModelComponent.prototype.currentEvent = function () {
                    return this._owner.getExperiment().getScheduler().getCurrentEvent();
                };
                /**
                 * Returns the model that the currently active Event or Entity handled by
                 * the scheduler belongs to or the main model connected to the experiment,
                 * if no model can be returned by the scheduler.
                 *
                 * @return {desmoj.core.simulator.Model} Model : The current active or the main model connected to the
                 * experiment, if no model can be returned by the scheduler
                 */
                ModelComponent.prototype.currentModel = function () {
                    var mBuff = this._owner.getExperiment().getScheduler().getCurrentModel();
                    if (mBuff != null)
                        return mBuff;
                    else
                        return this._owner.getExperiment().getModel();
                };
                /**
                 * Returns the current simulation time as displayed by the simulation clock
                 * responsible for this modelcomponent.
                 *
                 * @return {desmoj.core.simulator.TimeInstant} TimeInstant : The current point of simulation time
                 */
                ModelComponent.prototype.presentTime = function () {
                    return this._owner.getExperiment().getSimClock().getTime();
                };
                /**
                 * Shows if this modelcomponent currently produces debug output.
                 *
                 * @return {boolean} boolean : true, if modelcomponent shows in debug, false if not
                 */
                ModelComponent.prototype.debugIsOn = function () {
                    return this._debugMode;
                };
                /**
                 * Switches off debug output for this modelcomponent. Does nothing if trace
                 * is already switched off.
                 */
                ModelComponent.prototype.debugOff = function () {
                    this._debugMode = false;
                };
                /**
                 * Switches on debug output for this modelcomponent. Does nothing if debug
                 * is already switched on.
                 */
                ModelComponent.prototype.debugOn = function () {
                    this._debugMode = true;
                };
                /**
                 * Returns the model that owns this component.
                 *
                 * @return {desmoj.core.simulator.Model} Model : The model that this component is associated to
                 */
                ModelComponent.prototype.getModel = function () {
                    return this._owner;
                };
                /**
                 * Tests if the modelcomponent given as parameter is a component of the same
                 * experiment as this modelcomponent.
                 *
                 * @return {boolean} boolean : true, if this modelcomponent belongs to the same
                 * experiment as this modelcomponent, false otherwise
                 * @param {desmoj.core.simulator.ModelComponent} other
                 * ModelComponent : the other modelcomponent to check
                 * compatibility with
                 */
                ModelComponent.prototype.isExperimentCompatible = function (other) {
                    return (this._owner.getExperiment() === other.getModel().getExperiment());
                };
                /**
                 * Tests if the modelcomponent given as parameter is a component of the same
                 * model as this modelcomponent.
                 *
                 * @return {boolean} boolean :<code>true</code>, if this modelcomponent belongs to the
                 * same model as the given modelcomponent, <code>false</code>
                 * otherwise
                 * @param {desmoj.core.simulator.ModelComponent} other
                 * ModelComponent : the other modelcomponent to check
                 * compatibility with
                 */
                ModelComponent.prototype.isModelCompatible = function (other) {
                    return this._owner.checkCompatibility(other);
                };
                /**
                 * Creates and sends a debugnote to the experiment's messagedistributor.
                 * Debugnotes express the internal state of a modelcomponent to visualize
                 * the changes of state to help find bugs. Classes <code>Scheduler</code>
                 * and <code>Queue</code> both produce debugnotes if set to do so
                 * representing the data stored inside them. The information about the
                 * simulation time is extracted from the experiment and must not be given as
                 * a parameter.
                 *
                 * @param {string} description
                 * java.lang.String : The description of a modelcomponent's
                 * internal state to be passed with this debugnote
                 */
                ModelComponent.prototype.sendDebugNote = function (description) {
                    if (this.currentlySendDebugNotes()) {
                        this.sendMessage(new desmoj.core.report.DebugNote(this.getModel(), this.presentTime(), this.getName(), description));
                    }
                };
                /**
                 * returns true if this model component should currently send debug notes
                 * (i.e. experiment and the component are both in debug mode).
                 *
                 * @return
                 * @return {boolean}
                 */
                ModelComponent.prototype.currentlySendDebugNotes = function () {
                    return this.debugIsOn() && this.getModel().getExperiment().debugIsOn();
                };
                /**
                 * Sends a message to the messagedistributor handled by the experiment. This
                 * modelcomponent must already be connected to an experiment in order to
                 * have a messagedistributor available to send this message to and an
                 * appropriate messagereceiver must already be registered at the
                 * messagedistributor to receive that type of message passed on to it. If no
                 * messaging subsystem is available to this modelcomponent, then the mesage
                 * is printed to the standard <code>out</code> printstream as configured in
                 * the local Java runtime environment of the computer this simulation is
                 * running on. Note that there are shorthands for sending the standard
                 * DESMO-J messages. These methods create and send the appropriate Message
                 * on-the-fly:
                 * <ul>
                 * <li><code>sendTraceNote()</clode> to send a tracenote</li>
                 * <li><code>sendDebugNote()</code> to send the data needed to debug models</li>
                 * <li><code>sendWarning()</code> to send an errormessage that does not stop
                 * the experiment</li>
                 * </ul>
                 *
                 * @param {desmoj.core.report.Message} m
                 * Message : The message to be transmitted
                 * @see ModelComponent#sendTraceNote
                 * @see ModelComponent#sendDebugNote
                 * @see ModelComponent#sendWarning
                 */
                ModelComponent.prototype.sendMessage = function (m) {
                    if (m == null) {
                        this.sendWarning("Can\'t send Message!", "ModelComponent : " + this.getName() + " Method: SendMessage(Message m)", "The Message given as parameter is a null reference.", "Be sure to have a valid Message reference.");
                        return;
                    }
                    if (this._owner != null) {
                        if (this._owner.getExperiment() != null) {
                            this.getModel().getExperiment().getMessageManager().receive$desmoj_core_report_Message(m);
                            return;
                        }
                    }
                    console.info(m);
                };
                /**
                 * Creates and sends a tracenote to the experiment's messagedistributor. The
                 * information about the simulation time, model and component producing this
                 * tracenote is extracted from the experiment and must not be given as
                 * parameters.
                 *
                 * @param {string} description
                 * java.lang.String : The description of the tracenote
                 */
                ModelComponent.prototype.sendTraceNote = function (description) {
                    var mode = "";
                    if (this.currentModel().isConnected() && this.currentModel().getExperiment().isPreparing())
                        mode = "initially ";
                    if (this.currentlySendTraceNotes()) {
                        this.sendMessage(new desmoj.core.report.TraceNote(this.currentModel(), mode + description, this.presentTime(), this.currentEntityAll(), this.currentEvent()));
                    }
                };
                /**
                 * returns true if this model component should currently send trace notes
                 * (i.e. experiment and the component are both in trace mode).
                 *
                 * @return
                 * @return {boolean}
                 */
                ModelComponent.prototype.currentlySendTraceNotes = function () {
                    return this.traceIsOn() && this.getModel().getExperiment().traceIsOn();
                };
                /**
                 * Creates and sends an error message to warn about a erroneous condition in
                 * the DESMO-J framework to the experiment's messagedistributor. Be sure to
                 * have a correct location, since the object and method that the error
                 * becomes apparent is not necessary the location it was produced in. The
                 * information about the simulation time is extracted from the Experiment
                 * and must not be given as a parameter.
                 *
                 * @param {string} description
                 * java.lang.String : The description of the error that occured
                 * @param {string} location
                 * java.lang.String : The class and method the error occured in
                 * @param {string} reason
                 * java.lang.String : The reason most probably responsible for
                 * the error to occur
                 * @param {string} prevention
                 * java.lang.String : The measures a user should take to prevent
                 * this warning to be issued again
                 */
                ModelComponent.prototype.sendWarning = function (description, location, reason, prevention) {
                    this.sendMessage(new desmoj.core.report.ErrorMessage(this.getModel(), description, location, reason, prevention, this.presentTime()));
                };
                /**
                 * Sets the owner of a modelcomponent to the given reference. This is
                 * exclusively needed to build a self-reference for the main model of an
                 * experiment. Has to be delegated to class <code>modelcomponent</code>
                 * since the owner attribute is encapsulated in this class.
                 *
                 * @param {desmoj.core.simulator.Model} newOwner
                 * desmoj.Model : The modelcomponent's new owner
                 */
                ModelComponent.prototype.setOwner = function (newOwner) {
                    this._owner = newOwner;
                };
                ModelComponent.prototype.skipTraceNote$ = function () {
                    this.skipTraceNote$int(1);
                };
                ModelComponent.prototype.skipTraceNote$int = function (numSkipped) {
                    if (numSkipped < 1)
                        return;
                    if (!this.currentlySendTraceNotes())
                        return;
                    try {
                        this.getModel().getExperiment().getMessageManager().skip$java_lang_Class$int(/* forName */ eval("desmoj.core.report.TraceNote"), numSkipped);
                    }
                    catch (cnfx) {
                        throw new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(this.getModel(), "Can not skip tracenotes! Simulation aborted.", "ModelComponent : " + this.getName() + " Method : skipTraceNote()", "The file for class desmoj.report.TraceNote can not be found by " + "the Java runtime. Following exception was caught : " + cnfx.toString(), "Check that all pathnames for DESMOJ are set in your environment.", this.presentTime()));
                    }
                    ;
                };
                /**
                 * Skips the next number of tracenotes. The next -numSkipped - number of
                 * tracenotes produced by any object in the DESMO-J framework will not be
                 * distributed by the experiment's messagemanager. This is necessary for
                 * some operations to hide the framework's actions and thus not confuse the
                 * modeller.
                 *
                 * @param {number} numSkipped
                 * int : The number of future tracenotes to be skipped
                 */
                ModelComponent.prototype.skipTraceNote = function (numSkipped) {
                    if (((typeof numSkipped === 'number') || numSkipped === null)) {
                        return this.skipTraceNote$int(numSkipped);
                    }
                    else if (numSkipped === undefined) {
                        return this.skipTraceNote$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Shows if this modelcomponent currently produces trace output.
                 *
                 * @return {boolean} boolean : true, if modelcomponent shows in trace, false if not
                 */
                ModelComponent.prototype.traceIsOn = function () {
                    return this._traceMode;
                };
                /**
                 * Switches off trace output for this modelcomponent. Does nothing if trace
                 * is already switched off.
                 */
                ModelComponent.prototype.traceOff = function () {
                    this._traceMode = false;
                };
                /**
                 * Switches on trace output for this modelcomponent. Does nothing if trace
                 * is already switched on.
                 */
                ModelComponent.prototype.traceOn = function () {
                    this._traceMode = true;
                };
                ModelComponent.prototype.clone = function () {
                    var _this = this;
                    return (function (o) { if (_super.prototype.clone != undefined) {
                        return _super.prototype.clone.call(_this);
                    }
                    else {
                        var clone = Object.create(o);
                        for (var p in o) {
                            if (o.hasOwnProperty(p))
                                clone[p] = o[p];
                        }
                        return clone;
                    } })(this);
                };
                return ModelComponent;
            }(desmoj.core.simulator.NamedObject));
            simulator.ModelComponent = ModelComponent;
            ModelComponent["__class"] = "desmoj.core.simulator.ModelComponent";
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Constructs a scheduler with given name and the event-list (i.e. inheritor
             * of <code>desmoj.core.simulator.EventList</code>) to use.
             *
             * @param {desmoj.core.simulator.Experiment} exp
             * Experiment : The experiment that uses this Scheduler
             * @param {string} name
             * java.lang.String : The scheduler's name
             * @param {desmoj.core.simulator.EventList} eventList
             * EventList : The event-list to store scheduled events
             * @class
             * @extends desmoj.core.simulator.NamedObject
             * @author Tim Lechler, modified by Ruth Meyer, Justin Neumann
             */
            var Scheduler = (function (_super) {
                __extends(Scheduler, _super);
                function Scheduler(exp, name, eventList) {
                    var _this = _super.call(this, name + "_scheduler") || this;
                    /**
                     * The execution speed rate. Default is zero (as-fast-as-possible).
                     * (Modification by Felix Klueckmann, 05/2009)
                     */
                    /*private*/ _this._executionSpeedRate = 0.0;
                    _this.myExperiment = null;
                    _this.clock = null;
                    _this.evList = null;
                    _this.simulationFinished = false;
                    _this._currentEntity1 = null;
                    _this._currentEntity2 = null;
                    _this._currentEntity3 = null;
                    _this._currentEvent = null;
                    _this._currentSource = null;
                    _this._currentModel = null;
                    _this._currentSchedulable = null;
                    _this._realTimeAtResetInNanos = 0;
                    _this._simulationTimeAtReset = null;
                    _this._timeReset = false;
                    _this._realTimeEventQueue = null;
                    _this.myExperiment = exp;
                    _this.evList = eventList;
                    _this.clock = new desmoj.core.simulator.SimClock(name);
                    _this.simulationFinished = false;
                    _this._realTimeEventQueue = ([]);
                    return _this;
                }
                /**
                 * Returns the actual simulation time as displayed by the simulation clock.
                 *
                 * @return {desmoj.core.simulator.TimeInstant} TimeInstant : The current point in simulation time
                 */
                Scheduler.prototype.presentTime = function () {
                    return this.clock.getTime();
                };
                /**
                 * Returns the currently active Entity. Returns <code>null</code> if the current
                 * Schedulable happens to be an external event or a simprocess.
                 * Note that in case the current Event refers to more than one entity
                 * (<code>EventOfTwoEntities</code>, <code>EventOfThreeEntitties</code>),
                 * only the first entity is returned; to obtain all such entities,
                 * use <code>getAllCurrentEntities()</code> instead.
                 *
                 * @return {desmoj.core.simulator.Entity} Entity : The currently active Entity or
                 * <code>null</code> in case of an external event or a simprocess
                 * being the currently active Schedulable
                 */
                Scheduler.prototype.getCurrentEntity = function () {
                    return this._currentEntity1;
                };
                /**
                 * Returns the currently active entities. Returns an empty list
                 * if the current Schedulable happens to be an external event or a SimProcess.
                 *
                 * @return {desmoj.core.simulator.Entity[]} List<Entity> : A list containing the currently active entities
                 */
                Scheduler.prototype.getAllCurrentEntities = function () {
                    var entities = ([]);
                    if (this._currentEntity1 != null)
                        (entities.push(this._currentEntity1) > 0);
                    if (this._currentEntity2 != null)
                        (entities.push(this._currentEntity2) > 0);
                    if (this._currentEntity3 != null)
                        (entities.push(this._currentEntity3) > 0);
                    return entities;
                };
                /**
                 * Returns the current active Event or <code>null</code>. Note that this
                 * method can also return an external event that can not be handled like an
                 * Event since it does not support scheduling together with an entity.
                 * Returns <code>null</code> if the current Schedulable happens to be a
                 * Sim-process that has been activated, thus no kind of Event is associated
                 * with it.
                 *
                 * @return {desmoj.core.simulator.EventAbstract} Event : The currently active Event or external event or
                 * <code>null</code> if the current Schedulable happens to be an
                 * activated SimProcess
                 */
                Scheduler.prototype.getCurrentEvent = function () {
                    return this._currentEvent;
                };
                /**
                 * Returns the currently active model.
                 *
                 * @return {desmoj.core.simulator.Model} Model : The currently active model or <code>null</code> in case
                 * of no model being connected so far.
                 */
                Scheduler.prototype.getCurrentModel = function () {
                    return this._currentModel;
                };
                /**
                 * Returns the Schedulable object that as created the current EventNode,
                 * thus being responsible for what is going on at the moment
                 *
                 * @return {desmoj.core.simulator.Schedulable} Schedulable : The source of the currently active object(s).
                 * @see Entity
                 * @see SimProcess
                 * @see ExternalEvent
                 */
                Scheduler.prototype.getCurrentSource = function () {
                    return this._currentSource;
                };
                /**
                 * Returns the currently active Schedulable object. This can be any of its
                 * subtypes Entity, SimProcess or external event in that order.
                 * For events referring to multiple enities, the first entity is returned.
                 *
                 * @return {desmoj.core.simulator.Schedulable} Schedulable : The currently active Schedulable
                 * @see Entity
                 * @see SimProcess
                 * @see ExternalEvent
                 */
                Scheduler.prototype.getCurrentSchedulable = function () {
                    return this._currentSchedulable;
                };
                /**
                 * Returns the current execution Speed Rate.
                 *
                 * @return {number} double : The current execution speed rate.
                 */
                Scheduler.prototype.getExecutionSpeedRate = function () {
                    return this._executionSpeedRate;
                };
                /**
                 * Returns the actual clock for this model.
                 *
                 * @return {desmoj.core.simulator.SimClock} SimClock : The actual clock for simulation time
                 */
                Scheduler.prototype.getSimClock = function () {
                    return this.clock;
                };
                /**
                 * Returns if the event-list processes concurrent Events in random order or
                 * not.
                 *
                 * @return {boolean} boolean: <code>true</code> if concurrent Events are randomized,
                 * <code>false</code> otherwise
                 * @author Ruth Meyer
                 */
                Scheduler.prototype.isRandomizingConcurrentEvents = function () {
                    return this.evList.isRandomizingConcurrentEvents();
                };
                /**
                 * Processes the next event-note on the event-list. Returns <code>true</code>
                 * if that EventNote has been processed correctly, <code>false</code> if an
                 * error occurred or the event-list is empty.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if the next event-note was
                 * processed correctly, <code>false</code> if not
                 */
                Scheduler.prototype.processNextEventNote = function () {
                    var _currentNote;
                    if (!(this._executionSpeedRate > 0)) {
                        if (this.evList.isEmpty()) {
                            return false;
                        }
                    }
                    else {
                        while ((true)) {
                            if (this.evList.isEmpty() && (this._realTimeEventQueue.length == 0)) {
                                return false;
                            }
                            if (this.myExperiment.isStopped()) {
                                return true;
                            }
                            if (this._timeReset) {
                                this._realTimeAtResetInNanos = def.System.nanoTime();
                                this._simulationTimeAtReset = this.presentTime();
                                this._timeReset = false;
                            }
                            while ((!(this._realTimeEventQueue.length == 0))) {
                                var currentRealTimeWrapper = (function (a) { return a.length == 0 ? null : a.shift(); })(this._realTimeEventQueue);
                                var currentRealTimeEvent = currentRealTimeWrapper.getExternalEvent();
                                var weightedRealTimeEventNanos = Math.floor(((currentRealTimeWrapper.getNanos() - this._realTimeAtResetInNanos) * this._executionSpeedRate));
                                if (weightedRealTimeEventNanos < 0) {
                                    this.myExperiment.sendWarning("Can not schedule real time external event! The external event is discarded.", "Scheduler of experiment " + this.myExperiment.getName() + " Method processNextEventNote() " + "external event: " + currentRealTimeEvent.getName() + " deviation in nanoseconds: " + -weightedRealTimeEventNanos, "The given real-time time stamp is in the future.", "Real-time events are not supposed to be scheduled in the (real time) future.");
                                }
                                else {
                                    var realTimeNanosEquivalent = desmoj.core.simulator.TimeOperations.add$desmoj_core_simulator_TimeInstant$desmoj_core_simulator_TimeSpan(this._simulationTimeAtReset, new desmoj.core.simulator.TimeSpan(weightedRealTimeEventNanos, def.TimeUnit.NANOSECONDS));
                                    if (desmoj.core.simulator.TimeInstant.isAfterOrEqual(realTimeNanosEquivalent, this.presentTime())) {
                                        currentRealTimeEvent.schedule$desmoj_core_simulator_TimeInstant(realTimeNanosEquivalent);
                                    }
                                    else {
                                        currentRealTimeEvent.schedule$desmoj_core_simulator_TimeInstant(this.presentTime());
                                        this.myExperiment.sendWarning("Can not schedule real time external event at the simulation time equivalent to the given timeStamp! The external event is scheduled at the present simulation time instead.", "Scheduler of experiment " + this.myExperiment.getName() + " Method processNextEventNote() " + "external event: " + currentRealTimeEvent.getName() + " deviation in nanoseconds: " + (this.presentTime().getTimeTruncated$def_TimeUnit(def.TimeUnit.NANOSECONDS) - weightedRealTimeEventNanos), "The simulation time equivalent of the given time stamp is before the current simulation time. Can not perform a rollback.", "Check if this deviation constitutes a problem.");
                                    }
                                }
                            }
                            ;
                            _currentNote = this.evList.firstNote();
                            var weightedTimeSinceReset = Math.floor(((def.System.nanoTime() - this._realTimeAtResetInNanos) * this._executionSpeedRate));
                            var timeToWait = Math.floor(((desmoj.core.simulator.TimeOperations.diff$desmoj_core_simulator_TimeInstant$desmoj_core_simulator_TimeInstant(_currentNote.getTime(), this._simulationTimeAtReset).getTimeTruncated$def_TimeUnit(def.TimeUnit.NANOSECONDS) - weightedTimeSinceReset) / this._executionSpeedRate));
                            if (timeToWait > 0) {
                            }
                            else {
                            }
                            if (!this._timeReset && (this._realTimeEventQueue.length == 0)) {
                                break;
                            }
                        }
                        ;
                    }
                    _currentNote = this.evList.removeFirst();
                    var nextTime = _currentNote.getTime();
                    if (desmoj.core.simulator.TimeInstant.isAfter(nextTime, this.presentTime())) {
                        this.advanceTime(this.presentTime(), nextTime);
                    }
                    else {
                        if (desmoj.core.simulator.TimeInstant.isBefore(nextTime, this.presentTime())) {
                            throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "The simulation Time of the next event is in the past! Simulation aborted.", "Class : Scheduler  Method : processNextEventNote()", "the simulation time of the next event-note (" + _currentNote + ") is before the current simulation time : " + this.presentTime(), "Make sure not to schedule events in the past.", null)));
                        }
                    }
                    this._currentEntity1 = _currentNote.getEntity1();
                    this._currentEntity2 = _currentNote.getEntity2();
                    this._currentEntity3 = _currentNote.getEntity3();
                    this._currentSchedulable = null;
                    this._currentSource = _currentNote.getSource();
                    if (this._currentEntity1 != null) {
                        this._currentModel = this._currentEntity1.getModel();
                        this._currentSchedulable = this._currentEntity1;
                        this._currentEntity1.removeEventNote(_currentNote);
                    }
                    if (this._currentEntity2 != null) {
                        this._currentEntity2.removeEventNote(_currentNote);
                    }
                    if (this._currentEntity3 != null) {
                        this._currentEntity3.removeEventNote(_currentNote);
                    }
                    this._currentEvent = _currentNote.getEvent();
                    if (this._currentEvent != null) {
                        this._currentEvent.removeEventNote(_currentNote);
                        if (this._currentSchedulable == null) {
                            this._currentSchedulable = this._currentEvent;
                            this._currentModel = this._currentEvent.getModel();
                        }
                    }
                    if (this._currentSchedulable == null)
                        return false;
                    _currentNote = null;
                    if (this._currentEvent != null) {
                        if (this._currentEvent.getNumberOfEntities() === 1) {
                            this._currentEvent.eventRoutine(this._currentEntity1);
                        }
                        else if (this._currentEvent.getNumberOfEntities() === 2) {
                            this._currentEvent.eventRoutine(this._currentEntity1, this._currentEntity2);
                        }
                        else if (this._currentEvent.getNumberOfEntities() === 3) {
                            this._currentEvent.eventRoutine(this._currentEntity1, this._currentEntity2, this._currentEntity3);
                        }
                        else {
                            this._currentEvent.eventRoutine();
                        }
                    }
                    else {
                    }
                    if (this._executionSpeedRate > 0) {
                        var simTimeSinceReset = desmoj.core.simulator.TimeOperations.diff$desmoj_core_simulator_TimeInstant$desmoj_core_simulator_TimeInstant(this.presentTime(), this._simulationTimeAtReset).getTimeTruncated$def_TimeUnit(def.TimeUnit.NANOSECONDS);
                        var realTimeSinceReset = (def.System.nanoTime() - this._realTimeAtResetInNanos);
                        var deviationInNanoseconds = Math.floor((realTimeSinceReset - (simTimeSinceReset / this._executionSpeedRate)));
                        if (this._currentEvent != null) {
                            var deadLine = this._currentEvent.getRealTimeConstraint();
                            if (deadLine > 0 && deadLine < deviationInNanoseconds) {
                                this.myExperiment.sendWarning("The real-time deadline of this event was missed!", "Scheduler of experiment " + this.myExperiment.getName() + " Method processNextEventNote() " + "Event : " + this._currentEvent.getName(), "The real-time deadline of this event was " + deadLine + " nanoseconds. It was missed by " + (deviationInNanoseconds - deadLine) + " nanoseconds.", "Check if the deadline can be met.");
                            }
                        }
                        else {
                        }
                    }
                    return true;
                };
                /**
                 * This method is called to notify simulator about the time
                 * passed between the execution of two events with a positive
                 * (non-zero) offset. The implementation of this method just
                 * sets the scheduler's clock to the new instant; note, though,
                 * that extensions to DESMO-J may overwrite this method
                 * to conduct more complex operations, e.g. extrapolate
                 * variables in continuous simulation.
                 *
                 * @param {desmoj.core.simulator.TimeInstant} now
                 * TimeInstant : The current point in simulation time
                 * @param {desmoj.core.simulator.TimeInstant} next
                 * TimeInstant : The next point in simulation time to
                 * advance the clock to (e.g. instant of the next event)
                 */
                Scheduler.prototype.advanceTime = function (now, next) {
                    this.clock.setTime(next);
                };
                /**
                 * Schedules the external event to happen at the simulation time equivalent
                 * to the current value of wall-clock time.
                 *
                 * @param {desmoj.core.simulator.RealTimeEventWrapper} what
                 * ExternalEvent : The external event to be scheduled
                 *
                 */
                Scheduler.prototype.realTimeSchedule = function (what) {
                    if (!this.myExperiment.isRunning()) {
                        this.myExperiment.sendWarning("Can not schedule real time external event! Command ignored.", "Experiment \'" + this.getName() + "\' method void realTimeSchedule(ExternalEvent what).", "The experiment is not running.", "events can only be scheduled when the exeriment is running.");
                        return;
                    }
                    if (what == null) {
                        this.myExperiment.sendWarning("Can\'t schedule ExternalEvent! Command ignored.", "Scheduler : " + this.getName() + " Method: realTimeSchedule(ExternalEvent what)", "The ExternalEvent reference passed is a null references.", "Always make sure to use valid references only.");
                        return;
                    }
                    /* add */ (this._realTimeEventQueue.push(what) > 0);
                };
                /**
                 * Schedules the event to happen after a specified time. Checks that only
                 * legal combinations of valid parameters are scheduled. Preemption.
                 * <p>
                 * <DIV align=center>
                 * <TABLE BORDER >
                 * <CAPTION>Valid scheduling types </CAPTION>
                 * <TR>
                 * <TH><DIV align=center>scheduling type</TH>
                 * <TH>Entity object</TH>
                 * <TH>Event object</TH>
                 * </TR>
                 * <TR>
                 * <TH>Event oriented</TH>
                 * <TD>Event or SimProcess</TD>
                 * <TD>Event</TD>
                 * </TR>
                 * <TR>
                 * <TH>process oriented</TH>
                 * <TD>SimProcess</TD>
                 * <TD>null</TD>
                 * </TR>
                 * <TR>
                 * <TH>external event</TH>
                 * <TD>null</TD>
                 * <TD>external event</TD>
                 * </TR>
                 * </TABLE>
                 * </DIV>
                 *
                 * @param {desmoj.core.simulator.Schedulable} who
                 * Entity : The Entity to be scheduled
                 */
                Scheduler.prototype.reScheduleWithPreempt = function (who) {
                    if (who == null) {
                        this.myExperiment.sendWarning("Can\'t reschedule Schedulable at given time! Command ignored.", "Scheduler : " + this.getName() + " Method: reSchedule(Schedulable who, TimeSpan dt)", "The Schedulable reference passed as parameter is a null reference.", "Always make sure to use valid references only.");
                        return;
                    }
                    if (!who.isScheduled()) {
                        this.myExperiment.sendWarning("Can\'t reschedule Schedulable at given time! Command ignored.", "Scheduler : " + this.getName() + " Method: reSchedule(Schedulable who, TimeSpan dt)", "The Schedulable given is not scheduled, thus can not be rescheduled.", "To reschedule a Schedulable, it must already be scheduled. You can check that by calling the Schedulable\'s isScheduled() method");
                        return;
                    }
                    var notes = who.getEventNotes();
                    for (var index783 = 0; index783 < notes.length; index783++) {
                        var note = notes[index783];
                        {
                            this.evList.remove(note);
                            note.setTime(this.presentTime());
                            this.evList.insertAsFirst(note);
                        }
                    }
                };
                Scheduler.prototype.reScheduleNoPreempt$desmoj_core_simulator_Schedulable$desmoj_core_simulator_TimeSpan = function (who, dt) {
                    if (dt == null) {
                        this.myExperiment.sendWarning("Can\'t reschedule Schedulable at given time! Command ignored.", "Scheduler : " + this.getName() + " Method: reSchedule(Schedulable who, TimeSpan dt)", "The simulation time reference passed as parameter is a null reference.", "Always make sure to use valid references only.");
                        return;
                    }
                    if (who == null) {
                        this.myExperiment.sendWarning("Can\'t reschedule Schedulable at given time! Command ignored.", "Scheduler : " + this.getName() + " Method: reSchedule(Schedulable who, TimeSpan dt)", "The Schedulable reference passed as parameter is a null reference.", "Always make sure to use valid references only.");
                        return;
                    }
                    if (!who.isScheduled()) {
                        this.myExperiment.sendWarning("Can\'t reschedule Schedulable at given time! Command ignored.", "Scheduler : " + this.getName() + " Method: reSchedule(Schedulable who, TimeSpan dt)", "The Schedulable given is not scheduled, thus can not be rescheduled.", "To reschedule a Schedulable, it must already be scheduled. You can check that by calling the Schedulable\'s isScheduled() method");
                        return;
                    }
                    var notes = who.getEventNotes();
                    for (var index784 = 0; index784 < notes.length; index784++) {
                        var note = notes[index784];
                        {
                            this.evList.remove(note);
                            note.setTime(desmoj.core.simulator.TimeOperations.add$desmoj_core_simulator_TimeInstant$desmoj_core_simulator_TimeSpan(this.presentTime(), dt));
                            this.evList.insert(note);
                        }
                    }
                };
                /**
                 * Schedules the event to happen after a specified time. Checks that only
                 * legal combinations of valid parameters are scheduled. No preemption.
                 * <p>
                 * <DIV align=center>
                 * <TABLE BORDER >
                 * <CAPTION>Valid scheduling types </CAPTION>
                 * <TR>
                 * <TH><DIV align=center>scheduling type</TH>
                 * <TH>Entity object</TH>
                 * <TH>Event object</TH>
                 * </TR>
                 * <TR>
                 * <TH>Event oriented</TH>
                 * <TD>Event or SimProcess</TD>
                 * <TD>Event</TD>
                 * </TR>
                 * <TR>
                 * <TH>process oriented</TH>
                 * <TD>SimProcess</TD>
                 * <TD>null</TD>
                 * </TR>
                 * <TR>
                 * <TH>external event</TH>
                 * <TD>null</TD>
                 * <TD>external event</TD>
                 * </TR>
                 * </TABLE>
                 * </DIV>
                 *
                 * @param {desmoj.core.simulator.Schedulable} who
                 * Entity : The Entity to be scheduled
                 * @param {desmoj.core.simulator.TimeSpan} dt
                 * TimeSpan : The point in simulation time for the event to happen
                 * as an offset to the current simulation time
                 */
                Scheduler.prototype.reScheduleNoPreempt = function (who, dt) {
                    if (((who != null && who instanceof desmoj.core.simulator.Schedulable) || who === null) && ((dt != null && dt instanceof desmoj.core.simulator.TimeSpan) || dt === null)) {
                        return this.reScheduleNoPreempt$desmoj_core_simulator_Schedulable$desmoj_core_simulator_TimeSpan(who, dt);
                    }
                    else if (((who != null && who instanceof desmoj.core.simulator.Schedulable) || who === null) && ((dt != null && dt instanceof desmoj.core.simulator.TimeInstant) || dt === null)) {
                        return this.reScheduleNoPreempt$desmoj_core_simulator_Schedulable$desmoj_core_simulator_TimeInstant(who, dt);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Scheduler.prototype.reScheduleNoPreempt$desmoj_core_simulator_Schedulable$desmoj_core_simulator_TimeInstant = function (who, time) {
                    if (time == null) {
                        this.myExperiment.sendWarning("Can\'t reschedule Schedulable at given time! Command ignored.", "Scheduler : " + this.getName() + " Method: reSchedule(Schedulable who, TimeInstant time)", "The simulation time reference passed as parameter is a null reference.", "Always make sure to use valid references only.");
                        return;
                    }
                    if (who == null) {
                        this.myExperiment.sendWarning("Can\'t reschedule Schedulable at given time! Command ignored.", "Scheduler : " + this.getName() + " Method: reSchedule(Schedulable who, TimeInstant time)", "The Schedulable reference passed as parameter is a null reference.", "Always make sure to use valid references only.");
                        return;
                    }
                    if (!who.isScheduled()) {
                        this.myExperiment.sendWarning("Can\'t reschedule Schedulable at given time! Command ignored.", "Scheduler : " + this.getName() + " Method: reSchedule(Schedulable who, TimeInstant time)", "The Schedulable given is not scheduled, thus can not be rescheduled.", "To reschedule a Schedulable, it must already be scheduled. You can check that by calling the Schedulable\'s isScheduled() method");
                        return;
                    }
                    if (desmoj.core.simulator.TimeInstant.isBefore(time, this.presentTime())) {
                        this.myExperiment.sendWarning("Can\'t reschedule Schedulable at given time! Command ignored.", "Scheduler : " + this.getName() + " Method: reSchedule(Schedulable who, TimeInstant time)", "The instant given is in the past.", "To reschedule a Schedulable, use a TimeInstant no earlier than the present time. The present time can be obtained using the presentTime() method");
                        return;
                    }
                    var notes = (who.getEventNotes().slice(0));
                    for (var index785 = 0; index785 < notes.length; index785++) {
                        var note = notes[index785];
                        {
                            this.evList.remove(note);
                            note.setTime(time);
                            this.evList.insert(note);
                        }
                    }
                };
                Scheduler.prototype.scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_EventAbstract$desmoj_core_simulator_TimeSpan = function (who, what, dt) {
                    if (dt == null) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event at given time! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who, " + "EventAbstract what, TimeSpan dt)", "The simulation time reference passed as parameter is a null reference.", "Always make sure to use valid references only.");
                        return;
                    }
                    if ((who == null) && (what == null)) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who, " + "EventAbstract what, TimeSpan dt)", "The Event and Entity references passed are both null references.", "Either Event or Entity references must be valid.");
                        return;
                    }
                    if ((who == null) && !(what != null && what instanceof desmoj.core.simulator.ExternalEvent)) {
                        this.myExperiment.sendWarning("Can\'t schedule Event! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who, " + "EventAbstract what, TimeSpan dt)", "The Entity reference passed is a null reference but the Event references is not an external event.", "If no valid Entity is given, the event must be of type external event.");
                        return;
                    }
                    if (what != null) {
                        if (what.getNumberOfEntities() > 1) {
                            this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who, " + "EventAbstract what, TimeSpan dt)", "The method needs the correct Event to be scheduled with.", "You are using an event for multiple entities. You need an event for a single entity.");
                            return;
                        }
                    }
                    var time = desmoj.core.simulator.TimeOperations.add$desmoj_core_simulator_TimeInstant$desmoj_core_simulator_TimeSpan(this.presentTime(), dt);
                    var priority = 0;
                    priority = what.getSchedulingPriority();
                    var note = new desmoj.core.simulator.EventNote(who, null, null, what, time, priority, this._currentSchedulable);
                    this.evList.insert(note);
                };
                Scheduler.prototype.scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_EventAbstract$desmoj_core_simulator_TimeInstant = function (who, what, when) {
                    if (when == null) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event at given time! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who, " + "EventAbstract what, TimeInstant when)", "The simulation time reference passed as parameter is a null reference.", "Always make sure to use valid references only.");
                        return;
                    }
                    if ((who == null) && (what == null)) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who, " + "EventAbstract what, TimeInstant when)", "The Event and Entity references passed are both null references.", "Either Event or Entity references must be valid.");
                        return;
                    }
                    if ((who == null) && !(what != null && what instanceof desmoj.core.simulator.ExternalEvent)) {
                        this.myExperiment.sendWarning("Can\'t schedule Event! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who, " + "EventAbstract what, TimeInstant when)", "The Entity reference passed is a null reference but the Event references is not an external event.", "If no valid Entity is given, the event must be of type external event.");
                        return;
                    }
                    if (desmoj.core.simulator.TimeInstant.isBefore(when, this.presentTime())) {
                        this.myExperiment.sendWarning("Can\'t reschedule Schedulable at given time! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who, " + "EventAbstract what, TimeInstant when)", "The instant given is in the past.", "To schedule a Schedulable, use a TimeInstant no earlier than the present time. The present time can be obtained using the presentTime() method.");
                        return;
                    }
                    if (what != null) {
                        if (what.getNumberOfEntities() > 1) {
                            this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who, " + "Event what, TimeSpan dt)", "The method needs the correct Event to be scheduled with.", "You are using an event for multiple entities. You need an event for a single entity.");
                            return;
                        }
                    }
                    var priority = 0;
                    priority = what.getSchedulingPriority();
                    var note = new desmoj.core.simulator.EventNote(who, null, null, what, when, priority, this._currentSchedulable);
                    this.evList.insert(note);
                };
                Scheduler.prototype.scheduleWithPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_EventAbstract = function (who, what) {
                    if ((who == null) && (what == null)) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who, " + "EventAbstract what, TimeInstant when)", "The Event and Entity references passed are both null references.", "Either Event or Entity references must be valid.");
                        return;
                    }
                    if ((who == null) && !(what != null && what instanceof desmoj.core.simulator.ExternalEvent)) {
                        this.myExperiment.sendWarning("Can\'t schedule Event! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who, " + "EventAbstract what, TimeInstant when)", "The Entity reference passed is a null reference but the Event references is not an external event.", "If no valid Entity is given, the event must be of type external event.");
                        return;
                    }
                    if (what != null) {
                        if (what.getNumberOfEntities() > 1) {
                            this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who, " + "Event what, TimeSpan dt)", "The method needs the correct Event to be scheduled with.", "You are using an event for multiple entities. You need an event for a single entity.");
                            return;
                        }
                    }
                    var priority = 0;
                    priority = what.getSchedulingPriority();
                    var note = new desmoj.core.simulator.EventNote(who, null, null, what, this.presentTime(), priority, this._currentSchedulable);
                    this.evList.insertAsFirst(note);
                };
                Scheduler.prototype.scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf2Entities$desmoj_core_simulator_TimeSpan = function (who1, who2, what, dt) {
                    if (dt == null) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event at given time! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who1, Entity who2, " + "EventOf2Entities what, TimeSpan dt)", "The simulation time reference passed as parameter is a null reference.", "Always make sure to use valid references only.");
                        return;
                    }
                    if ((who1 == null) && (what == null)) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who1, Entity who2, " + "EventOf2Entities what, TimeSpan dt)", "The event and first entity references passed are both null references.", "Either Event or first entity references must be valid.");
                        return;
                    }
                    if ((who2 == null) && (what == null)) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who1, Entity who2, " + "EventOf2Entities what, TimeSpan dt)", "The event and second entity references passed are both null references.", "Either Event or second entity references must be valid.");
                        return;
                    }
                    var time = desmoj.core.simulator.TimeOperations.add$desmoj_core_simulator_TimeInstant$desmoj_core_simulator_TimeSpan(this.presentTime(), dt);
                    var note = new desmoj.core.simulator.EventNote(who1, who2, null, what, time, what.getSchedulingPriority(), this._currentSchedulable);
                    this.evList.insert(note);
                };
                Scheduler.prototype.scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf2Entities$desmoj_core_simulator_TimeInstant = function (who1, who2, what, when) {
                    if (when == null) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event at given time! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who1, Entity who2, " + "EventOf2Entities what, TimeInstant when)", "The simulation time reference passed as parameter is a null reference.", "Always make sure to use valid references only.");
                        return;
                    }
                    if ((who1 == null) && (what == null)) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who1, Entity who2, " + "EventOf2Entities what, TimeInstant when)", "The event and first entity references passed are both null references.", "Either Event or first entity references must be valid.");
                        return;
                    }
                    if ((who2 == null) && (what == null)) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who1, Entity who2, " + "EventOf2Entities what, TimeInstant when)", "The event and second entity references passed are both null references.", "Either Event or second entity references must be valid.");
                        return;
                    }
                    if (desmoj.core.simulator.TimeInstant.isBefore(when, this.presentTime())) {
                        this.myExperiment.sendWarning("Can\'t reschedule Schedulable at given time! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who1, Entity who2, EventOf2Entities what, TimeInstant when)", "The instant given is in the past.", "To schedule a Schedulable, use a TimeInstant no earlier than the present time. The present time can be obtained using the presentTime() method.");
                        return;
                    }
                    var note = new desmoj.core.simulator.EventNote(who1, who2, null, what, when, what.getSchedulingPriority(), this._currentSchedulable);
                    this.evList.insert(note);
                };
                Scheduler.prototype.scheduleWithPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf2Entities = function (who1, who2, what) {
                    if ((who1 == null) && (what == null)) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who1, Entity who2, " + "EventOf2Entities what, TimeInstant when)", "The event and first entity references passed are both null references.", "Either Event or first entity references must be valid.");
                        return;
                    }
                    if ((who2 == null) && (what == null)) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who1, Entity who2, " + "EventOf2Entities what, TimeInstant when)", "The event and second entity references passed are both null references.", "Either Event or second entity references must be valid.");
                        return;
                    }
                    var note = new desmoj.core.simulator.EventNote(who1, who2, null, what, this.presentTime(), what.getSchedulingPriority(), this._currentSchedulable);
                    this.evList.insertAsFirst(note);
                };
                Scheduler.prototype.scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf3Entities$desmoj_core_simulator_TimeSpan = function (who1, who2, who3, what, dt) {
                    if (dt == null) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event at given time! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who1, Entity who2, Entity who3, " + "EventOf3Entities what, TimeSpan dt)", "The simulation time reference passed as parameter is a null reference.", "Always make sure to use valid references only.");
                        return;
                    }
                    if ((who1 == null) && (what == null)) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who1, Entity who2, Entity who3, " + "EventOf3Entities what, TimeSpan dt)", "The event and first entity references passed are both null references.", "Either Event or first entity references must be valid.");
                        return;
                    }
                    if ((who2 == null) && (what == null)) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who1, Entity who2, Entity who3, " + "EventOf3Entities what, TimeSpan dt)", "The event and second entity references passed are both null references.", "Either Event or second entity references must be valid.");
                        return;
                    }
                    if ((who3 == null) && (what == null)) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who1, Entity who2, Entity who3, " + "EventOf3Entities what, TimeSpan dt)", "The event and third entity references passed are both null references.", "Either Event or third entity references must be valid.");
                        return;
                    }
                    var time = desmoj.core.simulator.TimeOperations.add$desmoj_core_simulator_TimeInstant$desmoj_core_simulator_TimeSpan(this.presentTime(), dt);
                    var note = new desmoj.core.simulator.EventNote(who1, who2, who3, what, time, what.getSchedulingPriority(), this._currentSchedulable);
                    this.evList.insert(note);
                };
                /**
                 * Schedules the event to happen after a specified time span. Does not allow preemption.
                 * @param {desmoj.core.simulator.Entity} who1
                 * @param {desmoj.core.simulator.Entity} who2
                 * @param {desmoj.core.simulator.Entity} who3
                 * @param {desmoj.core.simulator.EventOf3Entities} what
                 * @param {desmoj.core.simulator.TimeSpan} dt
                 */
                Scheduler.prototype.scheduleNoPreempt = function (who1, who2, who3, what, dt) {
                    if (((who1 != null && who1 instanceof desmoj.core.simulator.Entity) || who1 === null) && ((who2 != null && who2 instanceof desmoj.core.simulator.Entity) || who2 === null) && ((who3 != null && who3 instanceof desmoj.core.simulator.Entity) || who3 === null) && ((what != null && what instanceof desmoj.core.simulator.EventOf3Entities) || what === null) && ((dt != null && dt instanceof desmoj.core.simulator.TimeSpan) || dt === null)) {
                        return this.scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf3Entities$desmoj_core_simulator_TimeSpan(who1, who2, who3, what, dt);
                    }
                    else if (((who1 != null && who1 instanceof desmoj.core.simulator.Entity) || who1 === null) && ((who2 != null && who2 instanceof desmoj.core.simulator.Entity) || who2 === null) && ((who3 != null && who3 instanceof desmoj.core.simulator.Entity) || who3 === null) && ((what != null && what instanceof desmoj.core.simulator.EventOf3Entities) || what === null) && ((dt != null && dt instanceof desmoj.core.simulator.TimeInstant) || dt === null)) {
                        return this.scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf3Entities$desmoj_core_simulator_TimeInstant(who1, who2, who3, what, dt);
                    }
                    else if (((who1 != null && who1 instanceof desmoj.core.simulator.Entity) || who1 === null) && ((who2 != null && who2 instanceof desmoj.core.simulator.Entity) || who2 === null) && ((who3 != null && who3 instanceof desmoj.core.simulator.EventOf2Entities) || who3 === null) && ((what != null && what instanceof desmoj.core.simulator.TimeSpan) || what === null) && dt === undefined) {
                        return this.scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf2Entities$desmoj_core_simulator_TimeSpan(who1, who2, who3, what);
                    }
                    else if (((who1 != null && who1 instanceof desmoj.core.simulator.Entity) || who1 === null) && ((who2 != null && who2 instanceof desmoj.core.simulator.Entity) || who2 === null) && ((who3 != null && who3 instanceof desmoj.core.simulator.EventOf2Entities) || who3 === null) && ((what != null && what instanceof desmoj.core.simulator.TimeInstant) || what === null) && dt === undefined) {
                        return this.scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf2Entities$desmoj_core_simulator_TimeInstant(who1, who2, who3, what);
                    }
                    else if (((who1 != null && who1 instanceof desmoj.core.simulator.Entity) || who1 === null) && ((who2 != null && who2 instanceof desmoj.core.simulator.EventAbstract) || who2 === null) && ((who3 != null && who3 instanceof desmoj.core.simulator.TimeSpan) || who3 === null) && what === undefined && dt === undefined) {
                        return this.scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_EventAbstract$desmoj_core_simulator_TimeSpan(who1, who2, who3);
                    }
                    else if (((who1 != null && who1 instanceof desmoj.core.simulator.Entity) || who1 === null) && ((who2 != null && who2 instanceof desmoj.core.simulator.EventAbstract) || who2 === null) && ((who3 != null && who3 instanceof desmoj.core.simulator.TimeInstant) || who3 === null) && what === undefined && dt === undefined) {
                        return this.scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_EventAbstract$desmoj_core_simulator_TimeInstant(who1, who2, who3);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Scheduler.prototype.scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf3Entities$desmoj_core_simulator_TimeInstant = function (who1, who2, who3, what, when) {
                    if (when == null) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event at given time! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who1, Entity who2, Entity who3, " + "EventOf3Entities what, TimeInstant when)", "The simulation time reference passed as parameter is a null reference.", "Always make sure to use valid references only.");
                        return;
                    }
                    if ((who1 == null) && (what == null)) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who1, Entity who2, Entity who3, " + "EventOf3Entities what, TimeInstant when)", "The first Event and Entity references passed are both null references.", "Either Event or Entity references must be valid.");
                        return;
                    }
                    if ((who2 == null) && (what == null)) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who1, Entity who2, Entity who3, " + "EventOf3Entities what, TimeInstant when)", "The EEvent and second entity references passed are both null references.", "Either Event or second entity references must be valid.");
                        return;
                    }
                    if ((who3 == null) && (what == null)) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who1, Entity who2, Entity who3, " + "EventOf3Entities what, TimeInstant when)", "The event and third entity references passed are both null references.", "Either Event or third entity references must be valid.");
                        return;
                    }
                    if (desmoj.core.simulator.TimeInstant.isBefore(when, this.presentTime())) {
                        this.myExperiment.sendWarning("Can\'t reschedule Schedulable at given time! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who1, Entity who2, Entity who3, EventOf3Entities what, TimeInstant when)", "The instant given is in the past.", "To schedule a Schedulable, use a TimeInstant no earlier than the present time. The present time can be obtained using the presentTime() method.");
                        return;
                    }
                    var note = new desmoj.core.simulator.EventNote(who1, who2, who3, what, when, what.getSchedulingPriority(), this._currentSchedulable);
                    this.evList.insert(note);
                };
                Scheduler.prototype.scheduleWithPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf3Entities = function (who1, who2, who3, what) {
                    if ((who1 == null) && (what == null)) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who1, Entity who2, Entity who3, " + "EventOf3Entities what, TimeInstant when)", "The first Event and Entity references passed are both null references.", "Either Event or Entity references must be valid.");
                        return;
                    }
                    if ((who2 == null) && (what == null)) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who1, Entity who2, Entity who3, " + "EventOf3Entities what, TimeInstant when)", "The EEvent and second entity references passed are both null references.", "Either Event or second entity references must be valid.");
                        return;
                    }
                    if ((who3 == null) && (what == null)) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: schedule(Entity who1, Entity who2, Entity who3, " + "EventOf3Entities what, TimeInstant when)", "The event and third entity references passed are both null references.", "Either Event or third entity references must be valid.");
                        return;
                    }
                    var note = new desmoj.core.simulator.EventNote(who1, who2, who3, what, this.presentTime(), what.getSchedulingPriority(), this._currentSchedulable);
                    this.evList.insertAsFirst(note);
                };
                /**
                 * Schedules the event to happen immediately.
                 * @param {desmoj.core.simulator.Entity} who1
                 * @param {desmoj.core.simulator.Entity} who2
                 * @param {desmoj.core.simulator.Entity} who3
                 * @param {desmoj.core.simulator.EventOf3Entities} what
                 */
                Scheduler.prototype.scheduleWithPreempt = function (who1, who2, who3, what) {
                    if (((who1 != null && who1 instanceof desmoj.core.simulator.Entity) || who1 === null) && ((who2 != null && who2 instanceof desmoj.core.simulator.Entity) || who2 === null) && ((who3 != null && who3 instanceof desmoj.core.simulator.Entity) || who3 === null) && ((what != null && what instanceof desmoj.core.simulator.EventOf3Entities) || what === null)) {
                        return this.scheduleWithPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf3Entities(who1, who2, who3, what);
                    }
                    else if (((who1 != null && who1 instanceof desmoj.core.simulator.Entity) || who1 === null) && ((who2 != null && who2 instanceof desmoj.core.simulator.Entity) || who2 === null) && ((who3 != null && who3 instanceof desmoj.core.simulator.EventOf2Entities) || who3 === null) && what === undefined) {
                        return this.scheduleWithPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf2Entities(who1, who2, who3);
                    }
                    else if (((who1 != null && who1 instanceof desmoj.core.simulator.Entity) || who1 === null) && ((who2 != null && who2 instanceof desmoj.core.simulator.EventAbstract) || who2 === null) && who3 === undefined && what === undefined) {
                        return this.scheduleWithPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_EventAbstract(who1, who2);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Scheduler.prototype.scheduleAfter$desmoj_core_simulator_Schedulable$desmoj_core_simulator_Entity$desmoj_core_simulator_EventAbstract = function (after, who, what) {
                    if (after == null) {
                        this.myExperiment.sendWarning("Can\'t schedule after Schedulable! Command ignored.", "Scheduler : " + this.getName() + " Method: scheduleAfter(Schedulable after " + ", Entity who, EventAbstract what)", "The reference for the Schedulable to schedule after is a null references.", "Always check to use valid references.");
                        return;
                    }
                    if (!after.isScheduled() && (after !== this._currentSchedulable)) {
                        this.myExperiment.sendWarning("Can\'t schedule after Schedulable! Command ignored.", "Scheduler : " + this.getName() + " Method: scheduleAfter(Schedulable after " + ", Entity who, EventAbstract what)", "The Schedulable to be scheduled after is not scheduled.", "The Schedulable taken as reference must be scheduled.");
                        return;
                    }
                    if ((who == null) && (what == null)) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: scheduleAfter(Schedulable after " + ", Entity who, EventAbstract what)", "The Event and Entity references passed are both null references.", "Either Event or Entity references must be valid.");
                        return;
                    }
                    if ((who == null) && !(what != null && what instanceof desmoj.core.simulator.ExternalEvent)) {
                        this.myExperiment.sendWarning("Can\'t schedule Event! Command ignored.", "Scheduler : " + this.getName() + " Method: scheduleAfter(Schedulabe " + "after, Entity who, EventAbstract what)", "The Entity reference passed is a null reference but the Event references is not an external event.", "If no valid Entity is given, the event must be of type external event.");
                        return;
                    }
                    if (what != null) {
                        if (what.getNumberOfEntities() > 1) {
                            this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: scheduleAfter(Schedulabe " + "after, Entity who, EventAbstract what)", "The method needs the correct Event to be scheduled with.", "You are using an event for multiple entities. You need an event for a single entity.");
                            return;
                        }
                    }
                    if (after !== this._currentSchedulable) {
                        var afterNote = after.getEventNotes()[after.getEventNotes().length - 1];
                        this.evList.insertAfter(afterNote, new desmoj.core.simulator.EventNote(who, null, null, what, afterNote.getTime(), afterNote.getPriority(), this._currentSchedulable));
                    }
                    else {
                        this.evList.insertAsFirst(new desmoj.core.simulator.EventNote(who, null, null, what, this.presentTime(), Number.MAX_VALUE, this._currentSchedulable));
                    }
                };
                Scheduler.prototype.scheduleAfter$desmoj_core_simulator_Schedulable$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf2Entities = function (after, who1, who2, what) {
                    if (after == null) {
                        this.myExperiment.sendWarning("Can\'t schedule after Schedulable! Command ignored.", "Scheduler : " + this.getName() + " Method: scheduleAfter(Schedulable after, Entity who1, Entity who2, EventOf2Entities what)", "The reference for the Schedulable to schedule after is a null references.", "Always check to use valid references.");
                        return;
                    }
                    if (!after.isScheduled() && (after !== this._currentSchedulable)) {
                        this.myExperiment.sendWarning("Can\'t schedule after Schedulable! Command ignored.", "Scheduler : " + this.getName() + " Method: scheduleAfter(Schedulable after, Entity who1, Entity who2, EventOf2Entities what)", "The Schedulable to be scheduled after is not scheduled.", "The Schedulable taken as reference must be scheduled.");
                        return;
                    }
                    if ((who1 == null) && (what == null)) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: scheduleAfter(Schedulable after, Entity who1, Entity who2, EventOf2Entities what)", "The event and Entity \'who1\' references passed are both null references.", "Either Event or Entity \'who1\' references must be valid.");
                        return;
                    }
                    if ((who2 == null) && (what == null)) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: scheduleAfter(Schedulable after, Entity who1, Entity who2, EventOf2Entities what)", "The event and Entity \'who2\' references passed are both null references.", "Either Event or Entity \'who2\' references must be valid.");
                        return;
                    }
                    if (after !== this._currentSchedulable) {
                        var afterNote = after.getEventNotes()[after.getEventNotes().length - 1];
                        this.evList.insertAfter(afterNote, new desmoj.core.simulator.EventNote(who1, who2, null, what, afterNote.getTime(), afterNote.getPriority(), this._currentSchedulable));
                    }
                    else {
                        this.evList.insertAsFirst(new desmoj.core.simulator.EventNote(who1, who2, null, what, this.presentTime(), Number.MAX_VALUE, this._currentSchedulable));
                    }
                };
                Scheduler.prototype.scheduleAfter$desmoj_core_simulator_Schedulable$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf3Entities = function (after, who1, who2, who3, what) {
                    if (after == null) {
                        this.myExperiment.sendWarning("Can\'t schedule after Schedulable! Command ignored.", "Scheduler : " + this.getName() + " Method: scheduleAfter(Schedulable after, Entity who1, Entity who2, Entity who3, EventOf3Entities what)", "The reference for the Schedulable to schedule after is a null references.", "Always check to use valid references.");
                        return;
                    }
                    if (!after.isScheduled() && (after !== this._currentSchedulable)) {
                        this.myExperiment.sendWarning("Can\'t schedule after Schedulable! Command ignored.", "Scheduler : " + this.getName() + " Method: scheduleAfter(Schedulable after, Entity who1, Entity who2, Entity who3, EventOf3Entities what)", "The Schedulable to be scheduled after is not scheduled.", "The Schedulable taken as reference must be scheduled.");
                        return;
                    }
                    if ((who1 == null) && (what == null)) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: scheduleAfter(Schedulable after, Entity who1, Entity who2, Entity who3, EventOf3Entities what)", "The event and Entity \'who1\' references passed are both null references.", "Either Event or Entity \'who1\' references must be valid.");
                        return;
                    }
                    if ((who2 == null) && (what == null)) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: scheduleAfter(Schedulable after, Entity who1, Entity who2, Entity who3, EventOf3Entities what)", "The event and Entity \'who2\' references passed are both null references.", "Either Event or Entity \'who2\' references must be valid.");
                        return;
                    }
                    if ((who3 == null) && (what == null)) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: scheduleAfter(Schedulable after, Entity who1, Entity who2, Entity who3, EventOf3Entities what)", "The event and Entity \'who3\' references passed are both null references.", "Either Event or Entity \'who3\' references must be valid.");
                        return;
                    }
                    if (after !== this._currentSchedulable) {
                        var afterNote = after.getEventNotes()[after.getEventNotes().length - 1];
                        this.evList.insertAfter(afterNote, new desmoj.core.simulator.EventNote(who1, who2, who3, what, afterNote.getTime(), afterNote.getPriority(), this._currentSchedulable));
                    }
                    else {
                        this.evList.insertAsFirst(new desmoj.core.simulator.EventNote(who1, who2, who3, what, this.presentTime(), Number.MAX_VALUE, this._currentSchedulable));
                    }
                };
                /**
                 * Schedules the given Entity and Event to happen straight after the given
                 * Schedulable is set to be activated. Note that the siulation time for the
                 * newly entered EventNote will be set to the Schedulable's time and the new
                 * EventNote will be inserted directly after the Schedulable's EventNote.
                 * <p>
                 * <DIV align=center>
                 * <TABLE BORDER >
                 * <CAPTION>Valid scheduling types </CAPTION>
                 * <TR>
                 * <TH><DIV align=center>scheduling type</TH>
                 * <TH>Entity object</TH>
                 * <TH>Event object</TH>
                 * </TR>
                 * <TR>
                 * <TH>Event oriented</TH>
                 * <TD>Event or SimProcess</TD>
                 * <TD>Event</TD>
                 * </TR>
                 * <TR>
                 * <TH>process oriented</TH>
                 * <TD>SimProcess</TD>
                 * <TD>null</TD>
                 * </TR>
                 * <TR>
                 * <TH>external event</TH>
                 * <TD>null</TD>
                 * <TD>external event</TD>
                 * </TR>
                 * </TABLE>
                 * </DIV>
                 *
                 * @param {desmoj.core.simulator.Schedulable} after
                 * Schedulable : The Schedulable after which the new event-note is
                 * to be scheduled
                 * @param {desmoj.core.simulator.Entity} who1
                 * Entity : The first entity to be scheduled
                 *
                 * @param {desmoj.core.simulator.Entity} who2
                 * Entity : The second entity to be scheduled
                 *
                 * @param {desmoj.core.simulator.Entity} who3
                 * Entity : The third entity to be scheduled
                 *
                 * @param {desmoj.core.simulator.EventOf3Entities} what
                 * EventOf3Entities : The event to be scheduled
                 */
                Scheduler.prototype.scheduleAfter = function (after, who1, who2, who3, what) {
                    if (((after != null && after instanceof desmoj.core.simulator.Schedulable) || after === null) && ((who1 != null && who1 instanceof desmoj.core.simulator.Entity) || who1 === null) && ((who2 != null && who2 instanceof desmoj.core.simulator.Entity) || who2 === null) && ((who3 != null && who3 instanceof desmoj.core.simulator.Entity) || who3 === null) && ((what != null && what instanceof desmoj.core.simulator.EventOf3Entities) || what === null)) {
                        return this.scheduleAfter$desmoj_core_simulator_Schedulable$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf3Entities(after, who1, who2, who3, what);
                    }
                    else if (((after != null && after instanceof desmoj.core.simulator.Schedulable) || after === null) && ((who1 != null && who1 instanceof desmoj.core.simulator.Entity) || who1 === null) && ((who2 != null && who2 instanceof desmoj.core.simulator.Entity) || who2 === null) && ((who3 != null && who3 instanceof desmoj.core.simulator.EventOf2Entities) || who3 === null) && what === undefined) {
                        return this.scheduleAfter$desmoj_core_simulator_Schedulable$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf2Entities(after, who1, who2, who3);
                    }
                    else if (((after != null && after instanceof desmoj.core.simulator.Schedulable) || after === null) && ((who1 != null && who1 instanceof desmoj.core.simulator.Entity) || who1 === null) && ((who2 != null && who2 instanceof desmoj.core.simulator.EventAbstract) || who2 === null) && who3 === undefined && what === undefined) {
                        return this.scheduleAfter$desmoj_core_simulator_Schedulable$desmoj_core_simulator_Entity$desmoj_core_simulator_EventAbstract(after, who1, who2);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Scheduler.prototype.scheduleBefore$desmoj_core_simulator_Schedulable$desmoj_core_simulator_Entity$desmoj_core_simulator_EventAbstract = function (before, who, what) {
                    if (before == null) {
                        this.myExperiment.sendWarning("Can\'t schedule after Schedulable! Command ignored.", "Scheduler : " + this.getName() + " Method: Schedulable before, Entity who, EventAbstract what", "The reference for the Schedulable to schedule before is a null references.", "Always check to use valid references.");
                        return;
                    }
                    if (!before.isScheduled()) {
                        this.myExperiment.sendWarning("Can\'t schedule after Schedulable! Command ignored.", "Scheduler : " + this.getName() + " Method: Schedulable before, Entity who, EventAbstract what", "The Schedulable to schedule after is not scheduled.", "The Schedulable taken as reference must be scheduled.");
                        return;
                    }
                    if ((who == null) && (what == null)) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: Schedulable before, Entity who, EventAbstract what", "The Event and Entity references passed are both null references.", "Either Event or Entity references must be valid.");
                        return;
                    }
                    if ((who == null) && !(what != null && what instanceof desmoj.core.simulator.ExternalEvent)) {
                        this.myExperiment.sendWarning("Can\'t schedule Event! Command ignored.", "Scheduler : " + this.getName() + " Method: Schedulable before, Entity who, EventAbstract what", "The Entity reference passed is a null reference but the Event references is not an external event.", "If no valid Entity is given, the event must be of type external event.");
                        return;
                    }
                    var beforeNote = before.getEventNotes()[0];
                    this.evList.insertBefore(beforeNote, new desmoj.core.simulator.EventNote(who, null, null, what, beforeNote.getTime(), beforeNote.getPriority(), this._currentSchedulable));
                };
                Scheduler.prototype.scheduleBefore$desmoj_core_simulator_Schedulable$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf2Entities = function (before, who1, who2, what) {
                    if (before == null) {
                        this.myExperiment.sendWarning("Can\'t schedule after Schedulable! Command ignored.", "Scheduler : " + this.getName() + " Method: scheduleBefore(Schedulable before, Entity who1, Entity who2, EventOf2Entities what)", "The reference for the Schedulable to schedule before is a null references.", "Always check to use valid references.");
                        return;
                    }
                    if (!before.isScheduled()) {
                        this.myExperiment.sendWarning("Can\'t schedule after Schedulable! Command ignored.", "Scheduler : " + this.getName() + " Method: scheduleBefore(Schedulable before, Entity who1, Entity who2, EventOf2Entities what)", "The Schedulable to schedule after is not scheduled.", "The Schedulable taken as reference must be scheduled.");
                        return;
                    }
                    if ((who1 == null) && (what == null)) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: scheduleAfter(Schedulable after, Entity who1, Entity who2, EventOf2Entities what)", "The event and Entity \'who1\' references passed are both null references.", "Either Event or Entity \'who1\' references must be valid.");
                        return;
                    }
                    if ((who2 == null) && (what == null)) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: scheduleAfter(Schedulable after, Entity who1, Entity who2, EventOf2Entities what)", "The event and Entity \'who2\' references passed are both null references.", "Either Event or Entity \'who2\' references must be valid.");
                        return;
                    }
                    var beforeNote = before.getEventNotes()[0];
                    this.evList.insertBefore(beforeNote, new desmoj.core.simulator.EventNote(who1, who2, null, what, beforeNote.getTime(), beforeNote.getPriority(), this._currentSchedulable));
                };
                Scheduler.prototype.scheduleBefore$desmoj_core_simulator_Schedulable$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf3Entities = function (before, who1, who2, who3, what) {
                    if (before == null) {
                        this.myExperiment.sendWarning("Can\'t schedule after Schedulable! Command ignored.", "Scheduler : " + this.getName() + " Method: scheduleBefore(Schedulable before, Entity who1, Entity who2, Entity who3, EventOf3Entities what)", "The reference for the Schedulable to schedule before is a null references.", "Always check to use valid references.");
                        return;
                    }
                    if (!before.isScheduled()) {
                        this.myExperiment.sendWarning("Can\'t schedule after Schedulable! Command ignored.", "Scheduler : " + this.getName() + " Method: scheduleBefore(Schedulable before, Entity who1, Entity who2, Entity who3, EventOf3Entities what)", "The Schedulable to schedule after is not scheduled.", "The Schedulable taken as reference must be scheduled.");
                        return;
                    }
                    if ((who1 == null) && (what == null)) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: scheduleAfter(Schedulable after, Entity who1, Entity who2, Entity who3, EventOf3Entities what)", "The event and Entity \'who1\' references passed are both null references.", "Either Event or Entity \'who1\' references must be valid.");
                        return;
                    }
                    if ((who2 == null) && (what == null)) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: scheduleAfter(Schedulable after, Entity who1, Entity who2, Entity who3, EventOf3Entities what)", "The event and Entity \'who2\' references passed are both null references.", "Either Event or Entity \'who2\' references must be valid.");
                        return;
                    }
                    if ((who3 == null) && (what == null)) {
                        this.myExperiment.sendWarning("Can\'t schedule Entity and Event! Command ignored.", "Scheduler : " + this.getName() + " Method: scheduleAfter(Schedulable after, Entity who1, Entity who2, Entity who3, EventOf3Entities what)", "The event and Entity \'who3\' references passed are both null references.", "Either Event or Entity \'who3\' references must be valid.");
                        return;
                    }
                    var beforeNote = before.getEventNotes()[0];
                    this.evList.insertBefore(beforeNote, new desmoj.core.simulator.EventNote(who1, who2, who3, what, beforeNote.getTime(), beforeNote.getPriority(), this._currentSchedulable));
                };
                /**
                 * Schedules the given Entity and Event to happen straight before the given
                 * Schedulable is scheduled. Note that the simulation time for the newly
                 * entered EventNote will be set to the Schedulable's time and the new
                 * EventNote will be inserted directly before the Schedulable's EventNote.
                 * <p>
                 * <DIV align=center>
                 * <TABLE BORDER >
                 * <CAPTION>Valid scheduling types </CAPTION>
                 * <TR>
                 * <TH><DIV align=center>scheduling type</TH>
                 * <TH>Entity object</TH>
                 * <TH>Event object</TH>
                 * </TR>
                 * <TR>
                 * <TH>Event oriented</TH>
                 * <TD>Event or SimProcess</TD>
                 * <TD>Event</TD>
                 * </TR>
                 * <TR>
                 * <TH>process oriented</TH>
                 * <TD>SimProcess</TD>
                 * <TD>null</TD>
                 * </TR>
                 * <TR>
                 * <TH>external event</TH>
                 * <TD>null</TD>
                 * <TD>external event</TD>
                 * </TR>
                 * </TABLE>
                 * </DIV>
                 *
                 * @param {desmoj.core.simulator.Schedulable} before
                 * Schedulable : The Schedulable before which the new event-note
                 * is to be scheduled
                 * @param {desmoj.core.simulator.Entity} who1
                 * Entity : The first entity to be scheduled
                 *
                 * @param {desmoj.core.simulator.Entity} who2
                 * Entity : The second entity to be scheduled
                 *
                 * @param {desmoj.core.simulator.Entity} who3
                 * Entity : The third entity to be scheduled
                 *
                 * @param {desmoj.core.simulator.EventOf3Entities} what
                 * EventOf3Entities : The event to be scheduled
                 */
                Scheduler.prototype.scheduleBefore = function (before, who1, who2, who3, what) {
                    if (((before != null && before instanceof desmoj.core.simulator.Schedulable) || before === null) && ((who1 != null && who1 instanceof desmoj.core.simulator.Entity) || who1 === null) && ((who2 != null && who2 instanceof desmoj.core.simulator.Entity) || who2 === null) && ((who3 != null && who3 instanceof desmoj.core.simulator.Entity) || who3 === null) && ((what != null && what instanceof desmoj.core.simulator.EventOf3Entities) || what === null)) {
                        return this.scheduleBefore$desmoj_core_simulator_Schedulable$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf3Entities(before, who1, who2, who3, what);
                    }
                    else if (((before != null && before instanceof desmoj.core.simulator.Schedulable) || before === null) && ((who1 != null && who1 instanceof desmoj.core.simulator.Entity) || who1 === null) && ((who2 != null && who2 instanceof desmoj.core.simulator.Entity) || who2 === null) && ((who3 != null && who3 instanceof desmoj.core.simulator.EventOf2Entities) || who3 === null) && what === undefined) {
                        return this.scheduleBefore$desmoj_core_simulator_Schedulable$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf2Entities(before, who1, who2, who3);
                    }
                    else if (((before != null && before instanceof desmoj.core.simulator.Schedulable) || before === null) && ((who1 != null && who1 instanceof desmoj.core.simulator.Entity) || who1 === null) && ((who2 != null && who2 instanceof desmoj.core.simulator.EventAbstract) || who2 === null) && who3 === undefined && what === undefined) {
                        return this.scheduleBefore$desmoj_core_simulator_Schedulable$desmoj_core_simulator_Entity$desmoj_core_simulator_EventAbstract(before, who1, who2);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets the execution speed rate.
                 *
                 * @param {number} executionSpeedRate
                 * double : the execution speed rate
                 * @author Felix Klueckmann
                 */
                Scheduler.prototype.setExecutionSpeedRate = function (executionSpeedRate) {
                    this._executionSpeedRate = executionSpeedRate;
                    this._timeReset = true;
                };
                /**
                 * Switches to a different event list.
                 *
                 * @param {desmoj.core.simulator.EventList} newEventList
                 * EventList : the new event list
                 * @author Ruth Meyer
                 */
                Scheduler.prototype.switchEventList = function (newEventList) {
                    if (this.evList === newEventList) {
                        return;
                    }
                    var note = this.evList.firstNote();
                    while ((note != null)) {
                        newEventList.insert(note);
                        note = this.evList.nextNote(note);
                    }
                    ;
                    this.evList = newEventList;
                };
                /**
                 * Returns the status of the current simulation. Clients should not need to
                 * use this method explicitly. This method is polled by each thread when it
                 * exits a lock to check wether it should continue its lifeCycle() method ot
                 * throw a SimulationFinishedException, which seems to be the only legal way
                 * to break out of the deep call hierarchies and stop the Process'
                 * lifeCycle.
                 *
                 * @return {boolean} boolean : state of the simulation. False if still running, true
                 * if the simulation has already finished correctly
                 */
                Scheduler.prototype.simFinished = function () {
                    return this.simulationFinished;
                };
                /**
                 * Signals that the experiment is stopped.
                 *
                 * @author Felix Klueckmann
                 */
                Scheduler.prototype.signalStop = function () {
                    this._timeReset = true;
                };
                /**
                 * Returns a string representation of the current state of the event-list.
                 * The string is built by concatenating all string representations of the
                 * contained entities, events and TimeInstant objects calling their
                 * <code>toString()</code> methods.
                 *
                 * @return {string} java.lang.String : The string representation of the queuelist
                 */
                Scheduler.prototype.toString = function () {
                    var _this = this;
                    var buffer = { str: "", toString: function () { return this.str; } };
                    var enBuff = null;
                    var evBuff;
                    var tiBuff;
                    /* append */ (function (sb) { return sb.str = sb.str.concat("At " + _this.presentTime()); })(buffer);
                    if (this._currentEvent != null) {
                        /* append */ (function (sb) { return sb.str = sb.str.concat(" current event ["); })(buffer);
                        if (this._currentEvent.getNumberOfEntities() === 0) {
                            /* append */ (function (sb) { return sb.str = sb.str.concat("-"); })(buffer);
                        }
                        else {
                            /* append */ (function (sb) { return sb.str = sb.str.concat(_this._currentEntity1); })(buffer);
                            if (this._currentEntity2 != null)
                                (function (sb) { return sb.str = sb.str.concat("," + _this._currentEntity2); })(buffer);
                            if (this._currentEntity3 != null)
                                (function (sb) { return sb.str = sb.str.concat("," + _this._currentEntity3); })(buffer);
                        }
                        /* append */ (function (sb) { return sb.str = sb.str.concat("][" + _this._currentEvent + "]"); })(buffer);
                    }
                    /* append */ (function (sb) { return sb.str = sb.str.concat(" <br>EvenList: "); })(buffer);
                    if (this.evList.isEmpty()) {
                        /* append */ (function (sb) { return sb.str = sb.str.concat("- empty -"); })(buffer);
                        return buffer.str;
                    }
                    else {
                        var i_1 = 0;
                        for (var iNote = this.evList.firstNote(); iNote != null; iNote = this.evList.nextNote(iNote)) {
                            /* append */ (function (sb) { return sb.str = sb.str.concat(i_1 + ":"); })(buffer);
                            i_1++;
                            evBuff = iNote.getEvent();
                            var e1 = iNote.getEntity1();
                            var e2 = iNote.getEntity2();
                            var e3 = iNote.getEntity3();
                            if (e1 == null) {
                                enBuff = null;
                            }
                            else if (e2 == null) {
                                enBuff = { str: e1.toString(), toString: function () { return this.str; } };
                            }
                            else if (e3 == null) {
                                enBuff = { str: e1.toString() + "," + e2.toString(), toString: function () { return this.str; } };
                            }
                            else {
                                enBuff = { str: e1.toString() + "," + e2.toString() + "," + e3.toString(), toString: function () { return this.str; } };
                            }
                            tiBuff = iNote.getTime();
                            if (enBuff == null)
                                (function (sb) { return sb.str = sb.str.concat("[-]"); })(buffer);
                            else
                                (function (sb) { return sb.str = sb.str.concat("[" + enBuff.str + "]"); })(buffer);
                            if (evBuff == null)
                                (function (sb) { return sb.str = sb.str.concat("[-]"); })(buffer);
                            else
                                (function (sb) { return sb.str = sb.str.concat("[" + evBuff.toString() + "]"); })(buffer);
                            if (tiBuff == null)
                                (function (sb) { return sb.str = sb.str.concat("[-]"); })(buffer);
                            else
                                (function (sb) { return sb.str = sb.str.concat("[" + tiBuff.toString() + "]<br>"); })(buffer);
                        }
                        ;
                    }
                    return buffer.str;
                };
                return Scheduler;
            }(desmoj.core.simulator.NamedObject));
            simulator.Scheduler = Scheduler;
            Scheduler["__class"] = "desmoj.core.simulator.Scheduler";
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Constructs an empty <code>QueueList</code> with no reference to its
             * client QueueBased. This no-arg constructor is necessary to instantiate an
             * object of this class by calling the
             * <code>java.lang.Class.newInstance()</code> method. The reference to the
             * QueueBased object making use of this queue-functionality must be provided
             * later by calling the setQueueBased() method. The initial length is always
             * zero.
             * @class
             * @extends desmoj.core.simulator.QueueList
             * @author Justin Neumann
             */
            var QueueListStandard = (function (_super) {
                __extends(QueueListStandard, _super);
                function QueueListStandard() {
                    var _this = _super.call(this) || this;
                    _this.abbreviation = null;
                    _this.queuelist = null;
                    _this.queuelist = ([]);
                    _this.timemap = ({});
                    return _this;
                }
                /**
                 * Returns true if the given Entity is contained in the list, false
                 * otherwise.
                 *
                 * @return {boolean} boolean : True if the given Entity is contained in the list,
                 * false otherwise
                 * @param {desmoj.core.simulator.Entity} e
                 * Entity : The Entity assumed to be in the list
                 */
                QueueListStandard.prototype.contains = function (e) {
                    if (e == null) {
                        this.sendWarning("Can not check if the given Entity is contained in QueueListStandardFifo. Command ignored!", "Class: QueueListStandardFifo Method: boolean contains(Entity e).", "The Entity reference given as parameter is a null reference.", "Be sure to only use valid references.");
                        return false;
                    }
                    return (this.queuelist.indexOf((e)) >= 0);
                };
                /**
                 * Returns the first entity stored in the list. If the queue is empty,
                 * <code>null</code> is returned.
                 *
                 * @return {desmoj.core.simulator.Entity} Entity : The first entity in the list or <code>null</code> if
                 * list is empty
                 */
                QueueListStandard.prototype.first = function () {
                    if ((this.queuelist.length == 0)) {
                        return null;
                    }
                    else {
                        return this.queuelist[0];
                    }
                };
                QueueListStandard.prototype.get$desmoj_core_simulator_Entity = function (element) {
                    return this.queuelist.indexOf(element);
                };
                /**
                 * Returns the position of the named <code>Entity</code>.
                 * The first position is 0, the last one size()-1.
                 *
                 * @return {number} : The position of the <code>Entity</code> or <code>-1</code> if no such exists.
                 * @param {desmoj.core.simulator.Entity} element
                 */
                QueueListStandard.prototype.get = function (element) {
                    if (((element != null) || element === null)) {
                        return this.get$desmoj_core_simulator_Entity(element);
                    }
                    else if (((typeof element === 'number') || element === null)) {
                        return this.get$int(element);
                    }
                    else
                        throw new Error('invalid overload');
                };
                QueueListStandard.prototype.get$int = function (index) {
                    if (this.isEmpty()) {
                        this.sendWarning("Can not remove Entity. Command ignored.", "Class: QueueListStandardFifo Method: boolean remove(Entity e).", "The Queue is empty, no Entities are contained.", "Check if an entity is enqueued by calling method contains(Entity e).");
                        return null;
                    }
                    if ((function (lhs, rhs) { return lhs || rhs; })((index > this.size() - 1), (index < 0))) {
                        this.sendWarning("Can not retrieve index. Command ignored.", "Class: QueueListStandard Method: Entity get(int index).", "The index of the method is out of the list range.", "Check correct position in queue.");
                        return null;
                    }
                    return this.queuelist[index];
                };
                /**
                 * Returns an abbreviation as a String to identify the sort of queueing
                 * discipline (like FIFO or LIFO or ...). Is used to display the queueing
                 * discipline in the report of the QueueBased objects.
                 *
                 * @return {string} java.lang.String : An abbreviation to identify the sort of
                 * queueing discipline (like FIFO or LIFO or ...)
                 */
                QueueListStandard.prototype.getAbbreviation = function () {
                    return this.abbreviation;
                };
                /**
                 * Inserts the given "e" after the position of "which" in the QueueList.
                 * Returns true if "e" is inserted correctly after "which". If the list is
                 * empty or the referenced "which" is not contained, the "e" will not be
                 * inserted and false is returned.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if inserted correctly,
                 * <code>false</code> otherwise
                 * @param {desmoj.core.simulator.Entity} e
                 * Entity : The Entity to be inserted
                 * @param {desmoj.core.simulator.Entity} which
                 * Entity : The referenced Entity that the given "e" has to be
                 * inserted after
                 */
                QueueListStandard.prototype.insertAfter = function (e, which) {
                    if (e == null) {
                        this.sendWarning("Can not insert entity. Command ignored.", "Class \'QueueListStandardFifo\' Method: boolean insertAfter(Entity e, Entity which).", "The Entity reference \'e\' given as parameter is a null reference.", "Be sure to only use valid references.");
                        return false;
                    }
                    if (which == null) {
                        this.sendWarning("Can not insert entity. Command ignored.", "Class \'QueueListStandardFifo\' Method: boolean insertAfter(Entity e, Entity which).", "The Entity reference \'which\' given as parameter is a null reference.", "Be sure to only use valid references.");
                        return false;
                    }
                    if (this.contains(e)) {
                        this.sendWarning("Can not insert entity. Command ignored.", "Class \'QueueListStandardFifo\' Method: boolean insertAfter(Entity e, Entity which).", "The Entity \'e\' given as parameter is already enqueued.", "Make sure the entity is not enqueued here by calling method \'contains(Entity e)\'.");
                        return false;
                    }
                    /* add */ this.queuelist.splice(this.queuelist.indexOf(which) + 1, 0, e);
                    e.addQueueBased(this.clientQ);
                    this.statisticalInsert(e);
                    return true;
                };
                /**
                 * Inserts the given "e" before the position of "which" in the
                 * QueueList. Returns true if "e" is inserted correctly after "which".
                 * If the list is empty or the referenced "which" is not contained, the "e"
                 * will not be inserted and false is returned.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if inserted correctly,
                 * <code>false</code> otherwise
                 * @param {desmoj.core.simulator.Entity} e
                 * Entity : The Entity to be inserted
                 * @param {desmoj.core.simulator.Entity} which
                 * Entity : The referenced Entity that the given "e" has to be
                 * inserted before
                 */
                QueueListStandard.prototype.insertBefore = function (e, which) {
                    if (e == null) {
                        this.sendWarning("Can not insert entity. Command ignored.", "Class \'QueueListStandardFifo\' Method: insertBefore(Entity e, Entity which).", "The Entity reference \'e\' given as parameter is a null reference.", "Be sure to only use valid references.");
                        return false;
                    }
                    if (which == null) {
                        this.sendWarning("Can not insert entity. Command ignored.", "Class \'QueueListStandardFifo\' Method: insertBefore(Entity e, Entity which).", "The Entity reference \'which\' given as parameter is a null reference.", "Be sure to only use valid references.");
                        return false;
                    }
                    if (this.contains(e)) {
                        this.sendWarning("Can not insert entity. Command ignored.", "Class \'QueueListStandardFifo\' Method: insertBefore(Entity e, Entity which).", "The Entity \'e\' given as parameter is already enqueued.", "Make sure the entity is not enqueued here by calling method \'contains(Entity e)\'.");
                        return false;
                    }
                    /* add */ this.queuelist.splice(this.queuelist.indexOf(which), 0, e);
                    e.addQueueBased(this.clientQ);
                    this.statisticalInsert(e);
                    return true;
                };
                /**
                 * Returns <code>true</code>, if no elements are inside the
                 * <code>QueueList</code>,<code>false</code> otherwise
                 *
                 * @return {boolean} boolean : true, if no elements are inside the
                 * <code>QueueList</code>, false otherwise
                 */
                QueueListStandard.prototype.isEmpty = function () {
                    return (this.queuelist.length == 0);
                };
                /**
                 * Returns the last Entity stored in the QueueList. If the QueueList
                 * is empty, <code>null</code> is returned.
                 *
                 * @return {desmoj.core.simulator.Entity} Entity : The last Entity in the list or <code>null</code> if
                 * QueueList is empty
                 */
                QueueListStandard.prototype.last = function () {
                    if ((this.queuelist.length == 0)) {
                        return null;
                    }
                    else {
                        return this.queuelist[this.queuelist.length - 1];
                    }
                };
                /**
                 * Returns the predecessor to the given Entity in the QueueList. If
                 * there is no predecessor or no Entity, <code>null</code> is returned.
                 *
                 * @return {desmoj.core.simulator.Entity} Entity : The Entity before the given parameter in the
                 * QueueList or <code>null</code> if e has no predecessor in
                 * the QueueList or Entity parameter 'e' itself is not contained
                 * @param {desmoj.core.simulator.Entity} e
                 * Entity : The Entity contained in the QueueList whose
                 * predecessor will be returned.
                 */
                QueueListStandard.prototype.pred = function (e) {
                    if (e == null) {
                        this.sendWarning("Can not return predecessor Entity. Command ignored.", "Class: QueueListStandardFifo Method: Entity pred (Entity e).", "The Entity reference \'e\' given as parameter is a null reference.", "Check if Entity \'e\' is enqueued using method \'QueueListStandardFifo.contains(e)\'.");
                        return null;
                    }
                    if (!this.contains(e)) {
                        return null;
                    }
                    if (e.equals(/* get */ this.queuelist[0])) {
                        return null;
                    }
                    return this.queuelist[this.queuelist.indexOf(e) - 1];
                };
                QueueListStandard.prototype.remove$desmoj_core_simulator_Entity = function (e) {
                    if (e == null) {
                        this.sendWarning("Can not remove Entity. Command ignored.", "Class: QueueListStandardFifo Method: boolean remove(Entity e).", "The Entity reference given as parameter is a null reference.", "Be sure to only use valid references.");
                        return false;
                    }
                    if (this.isEmpty()) {
                        this.sendWarning("Can not remove Entity. Command ignored.", "Class: QueueListStandardFifo Method: boolean remove(Entity e).", "The Queue is empty, no Entities are contained.", "Check if an entity is enqueued by calling method contains(Entity e).");
                        return false;
                    }
                    if (!this.contains(e)) {
                        this.sendWarning("Can not return predecessor Entity. Command ignored.", "Class: QueueListStandardFifo Method: Entity remove (Entity e).", "The Entity reference \'e\' given as parameter is not contained reference.", "Insert e first.");
                        return false;
                    }
                    /* remove */ (function (a) { return a.splice(a.indexOf(e), 1); })(this.queuelist);
                    e.removeQueueBased(this.clientQ);
                    this.statisticalRemove(e);
                    return true;
                };
                /**
                 * Removes the first occurrence of the given Entity from the QueueList. Checks if the given
                 * Entity to be removed does apply to all restrictions on this operation.
                 * These are :
                 * <ul>
                 * <li>The given reference to an entity must not be <code>null</code>
                 * </li>
                 * <li>This QueueList must not be empty, otherwise there's nothing to
                 * remove</li>
                 * If all these restrictions apply, <code>true</code> is returned and the
                 * Entity is removed, otherwise <code>false</code> is the return value
                 * because the given Entity could not be removed since one of the
                 * restrictions above was not met.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if the given Entity is contained
                 * in the QueueList, <code>false</code> otherwise
                 * @param {desmoj.core.simulator.Entity} e
                 * Entity : The Entity to be removed from the QueueList
                 */
                QueueListStandard.prototype.remove = function (e) {
                    if (((e != null) || e === null)) {
                        return this.remove$desmoj_core_simulator_Entity(e);
                    }
                    else if (((typeof e === 'number') || e === null)) {
                        return this.remove$int(e);
                    }
                    else
                        throw new Error('invalid overload');
                };
                QueueListStandard.prototype.remove$int = function (index) {
                    if (!this.contains(this.get$int(index))) {
                        this.sendWarning("Can not return predecessor Entity. Command ignored.", "Class: QueueListStandardFifo Method: Entity remove (int index).", "The Entity reference \'e\' given as parameter is not contained reference.", "Insert element first.");
                        return false;
                    }
                    var e = this.queuelist[index];
                    if ((function (a) { return a.splice(a.indexOf(e), 1); })(this.queuelist)) {
                        return false;
                    }
                    e.removeQueueBased(this.clientQ);
                    this.statisticalRemove(e);
                    return true;
                };
                /**
                 * Removes the first entity from this QueueList and returns
                 * <code>true</code> if it was removed successfully. If the QueueList
                 * is empty, <code>false</code> is returned.
                 *
                 * @return {boolean} boolean : Is <code>true</code>, if the first element has been
                 * removed successfully, <code>false</code> if the QueueList
                 * happened to be empty.
                 */
                QueueListStandard.prototype.removeFirst = function () {
                    if (this.isEmpty()) {
                        this.sendWarning("Can not remove first entity in queue. Command ignored.", "Class: QueueListStandardFifo Method: boolean removeFirst().", "The queue is empty, thus no Entity can be removed.", "Check if any Entity \'e\' is enqueued using method \'QueueListStandardFifo.contains(e)\'.");
                        return false;
                    }
                    return this.remove(this.first());
                };
                /**
                 * Removes the last Entity from the QueueList and returns
                 * <code>true</code> if it was removed successfully. If the QueueList
                 * is empty, <code>false</code> is returned.
                 *
                 * @return {boolean} boolean : Is <code>true</code>, if the last element has been
                 * removed successfully, <code>false</code> if the QueueList
                 * happened to be empty
                 */
                QueueListStandard.prototype.removeLast = function () {
                    if (this.isEmpty()) {
                        this.sendWarning("Can not remove last Entity in queue. Command ignored.", "Class: QueueListStandardFifo Method: boolean removeLast().", "The queue is empty, thus no Entity can be removed.", "Check if any Entity \'e\' is enqueued using method \'QueueListStandardFifo.contains(e)\'.");
                        return false;
                    }
                    return this.remove(this.last());
                };
                /**
                 * Sends a warning to the error output by forwarding it to the associated
                 * QueueBased's <code>sendwarning</code> method. Warnings are sent only if
                 * the QueueBased's flag for queue implementation warnings is set to
                 * <code>true</code>.
                 *
                 * @param {string} description
                 * java.lang.String : describing the error
                 * @param {string} location
                 * java.lang.String : describing the location the error occurred
                 * @param {string} reason
                 * java.lang.String : describing the possible cause for this
                 * error
                 * @param {string} prevention
                 * java.lang.String : telling what to do to prevent this error
                 * @see QueueBased
                 */
                QueueListStandard.prototype.sendWarning = function (description, location, reason, prevention) {
                    if (this.clientQ.qImpWarn()) {
                        this.clientQ.sendWarning(description, location, reason, prevention);
                    }
                };
                /**
                 * Returns the successor to the given Entity in the QueueList. If there
                 * is no successor or no Entity in the QueueList, <code>null</code> is
                 * returned.
                 *
                 * @return {desmoj.core.simulator.Entity} Entity : The Entity before the given parameter in the
                 * QueueList or <code>null</code> if the given Entity
                 * parameter 'e' has no successor in the QueueList or e itself
                 * is not contained in the QueueList
                 * @param {desmoj.core.simulator.Entity} e
                 * Entity : The Entity contained in the QueueList
                 */
                QueueListStandard.prototype.succ = function (e) {
                    if (e == null) {
                        this.sendWarning("Can not return successing Entity. Command ignored.", "Class: QueueListStandardFifo Method: Entity succ (Entity e).", "The Entity reference \'e\' given as parameter is a null reference.", "Check if Entity \'e\' is enqueued using method \'QueueListStandardFifo.contains(e)\'.");
                        return null;
                    }
                    if (!this.contains(e)) {
                        return null;
                    }
                    if (e.equals(/* get */ this.queuelist[this.queuelist.length - 1])) {
                        return null;
                    }
                    return this.queuelist[this.queuelist.indexOf(e) + 1];
                };
                /**
                 * Returns a string representation of the QueueList. The string is built
                 * by concatenating all string representations of the contained entities,
                 * calling their <code>toString()</code> methods.
                 *
                 * @return {string} java.lang.String : The string representation of the QueueList
                 */
                QueueListStandard.prototype.toString = function () {
                    var s = "";
                    for (var i = 0; i < this.size(); i++) {
                        var e = this.queuelist[i];
                        s = s + i + ":[" + e + "]<br>";
                    }
                    ;
                    if (this.isEmpty()) {
                        s = "-";
                    }
                    return s;
                };
                return QueueListStandard;
            }(desmoj.core.simulator.QueueList));
            simulator.QueueListStandard = QueueListStandard;
            QueueListStandard["__class"] = "desmoj.core.simulator.QueueListStandard";
            QueueListStandard["__interfaces"] = ["java.lang.Iterable"];
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            /**
             * Creates a new TableOutput with the given time precision and
             * TableFormatter
             *
             * @param {number} timePrec
             * precision for writing time values.
             * @param {string} format
             * fully qualified class name of assigned TableFormatter
             * @class
             * @extends desmoj.core.report.FileOutput
             * @author Nicolas Knaak edited by Gunnar Kiesel, 5.1.2004
             */
            var TableOutput = (function (_super) {
                __extends(TableOutput, _super);
                function TableOutput(timePrec, format) {
                    var _this = _super.call(this) || this;
                    _this.formatter = null;
                    TableOutput.setSeparator("\t");
                    _this.formatter = _this.createFormatter(format);
                    _this.formatter.setOutput(_this);
                    _this.formatter.setTimePrecision(timePrec);
                    return _this;
                }
                TableOutput.prototype.open = function (pathname, name) {
                    if (((typeof pathname === 'string') || pathname === null) && name === undefined) {
                        return this.open$java_lang_String(pathname);
                    }
                    else
                        throw new Error('invalid overload');
                };
                TableOutput.prototype.open$java_lang_String = function (name) {
                    _super.prototype.open$java_lang_String.call(this, name);
                    this.formatter.open(name);
                };
                /**
                 * Closes the table output (and the assigned file).
                 */
                TableOutput.prototype.close = function () {
                    this.formatter.close();
                    _super.prototype.close.call(this);
                };
                /**
                 * Tries creating a TableFormatter from the given class name. If creation
                 * fails (e.g. because the class name does not exist) the assigned
                 * experiments default table formatter is created
                 *
                 * @param {string} formatter
                 * fully qualified class name of TableFormatter subclass.
                 * @return {*} created TableFormatter object Since the Experiment class no
                 * longer contains a default formater, the default formatter is now
                 * located in this class
                 */
                TableOutput.prototype.createFormatter = function (formatter) {
                    var t;
                    try {
                        var formatterClass = eval(formatter);
                        t = new formatterClass();
                        return t;
                    }
                    catch (e) {
                        return this.createFormatter(TableOutput.DEFAULT_FORMATTER);
                    }
                    ;
                };
                /**
                 * Creates a valid filename from the given information
                 *
                 * @param {string} pathname
                 * name of path
                 * @param {string} name
                 * name of file
                 * @param {string} type
                 * kind of simulation output (e.g. <code>"report"</code>)
                 * @return {string}
                 */
                TableOutput.prototype.createFileName = function (pathname, name, type) {
                    if ((pathname == null) || (pathname.length === 0))
                        pathname = ".";
                    if ((name == null) || (name.length === 0))
                        name = "DESMOJ";
                    var appendix = "." + this.formatter.getFileFormat().toLowerCase();
                    if ((!(function (str, searchString) { var pos = str.length - searchString.length; var lastIndex = str.indexOf(searchString, pos); return lastIndex !== -1 && lastIndex === pos; })(name, appendix)) || (!(function (str, searchString) { var pos = str.length - searchString.length; var lastIndex = str.indexOf(searchString, pos); return lastIndex !== -1 && lastIndex === pos; })(name, appendix.toUpperCase())))
                        return pathname + def.File.separator + name + "_" + type + appendix;
                    else
                        return pathname + def.File.separator + name;
                };
                return TableOutput;
            }(desmoj.core.report.FileOutput));
            /**
             * The table formatter used if formatter is invalid
             */
            TableOutput.DEFAULT_FORMATTER = "desmoj.core.report.HTMLTableFormatter";
            report.TableOutput = TableOutput;
            TableOutput["__class"] = "desmoj.core.report.TableOutput";
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            /**
             * Creates a new ContDistExponentialReporter.
             *
             * @param {desmoj.core.simulator.Reportable} informationSource
             * desmoj.core.simulator.Reportable : The ContDistExponential distribution to
             * report about
             * @class
             * @extends desmoj.core.report.DistributionReporter
             * @author Tim Lechler
             */
            var ContDistExponReporter = (function (_super) {
                __extends(ContDistExponReporter, _super);
                function ContDistExponReporter(informationSource) {
                    var _this = _super.call(this, informationSource) || this;
                    _this.groupID = 153;
                    return _this;
                }
                /**
                 * Returns the array of strings containing all information about the
                 * ContDistExponential distribution.
                 *
                 * @return {Array} java.lang.String[] : The array of Strings containing all
                 * information about the ContDistExponential distribution
                 */
                ContDistExponReporter.prototype.getEntries = function () {
                    if (this.source != null && this.source instanceof desmoj.core.dist.ContDistWeibull) {
                        var rdw = this.source;
                        this.entries[0] = rdw.getName();
                        this.entries[1] = rdw.resetAt().toString();
                        this.entries[2] = ('' + (rdw.getObservations()));
                        this.entries[3] = "Cont Weibull";
                        this.entries[4] = ('' + (rdw.getMean()));
                        this.entries[5] = ('' + (rdw.getBeta()));
                        this.entries[6] = " ";
                        this.entries[7] = ('' + (rdw.getInitialSeed()));
                    }
                    else if (this.source != null && this.source instanceof desmoj.core.dist.ContDistExponential) {
                        var rdx = this.source;
                        if (this.source != null && this.source instanceof desmoj.core.dist.ContDistWeibull) {
                            var rdw = rdx;
                        }
                        this.entries[0] = rdx.getName();
                        this.entries[1] = rdx.resetAt().toString();
                        this.entries[2] = ('' + (rdx.getObservations()));
                        this.entries[3] = "Cont Exponential";
                        this.entries[4] = ('' + (rdx.getMean()));
                        this.entries[5] = " ";
                        this.entries[6] = " ";
                        this.entries[7] = ('' + (rdx.getInitialSeed()));
                    }
                    else {
                        for (var i = 0; i < this.__numColumns; i++) {
                            this.entries[i] = "Invalid source!";
                        }
                        ;
                    }
                    return this.entries;
                };
                return ContDistExponReporter;
            }(desmoj.core.report.DistributionReporter));
            report.ContDistExponReporter = ContDistExponReporter;
            ContDistExponReporter["__class"] = "desmoj.core.report.ContDistExponReporter";
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            /**
             * Creates a new ContDistUniformReporter.
             *
             * @param {desmoj.core.simulator.Reportable} informationSource
             * desmoj.core.simulator.Reportable : The ContDistUniform distribution to report
             * about
             * @class
             * @extends desmoj.core.report.DistributionReporter
             * @author Tim Lechler
             */
            var ContDistUniformReporter = (function (_super) {
                __extends(ContDistUniformReporter, _super);
                function ContDistUniformReporter(informationSource) {
                    var _this = _super.call(this, informationSource) || this;
                    _this.groupID = 155;
                    return _this;
                }
                /**
                 * Returns the array of strings containing all information about the
                 * ContDistUniform distribution.
                 *
                 * @return {Array} java.lang.String[] : The array of Strings containing all
                 * information about the ContDistUniform distribution
                 */
                ContDistUniformReporter.prototype.getEntries = function () {
                    if (this.source != null && this.source instanceof desmoj.core.dist.ContDistUniform) {
                        var rdn = this.source;
                        this.entries[0] = rdn.getName();
                        this.entries[1] = rdn.resetAt().toString();
                        this.entries[2] = ('' + (rdn.getObservations()));
                        this.entries[3] = "Cont Uniform";
                        this.entries[4] = ('' + (rdn.getLower()));
                        this.entries[5] = ('' + (rdn.getUpper()));
                        this.entries[6] = " ";
                        this.entries[7] = ('' + (rdn.getInitialSeed()));
                    }
                    else {
                        for (var i = 0; i < this.__numColumns; i++) {
                            this.entries[i] = "Invalid source!";
                        }
                        ;
                    }
                    return this.entries;
                };
                return ContDistUniformReporter;
            }(desmoj.core.report.DistributionReporter));
            report.ContDistUniformReporter = ContDistUniformReporter;
            ContDistUniformReporter["__class"] = "desmoj.core.report.ContDistUniformReporter";
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Constructs a new randomizing Event tree list. Initializes the event tree list
             * and the random position generator.
             * @class
             * @extends desmoj.core.simulator.EventTreeList
             * @author Ruth Meyer, modified by Johannes G&ouml;bel
             */
            var RandomizingEventTreeList = (function (_super) {
                __extends(RandomizingEventTreeList, _super);
                function RandomizingEventTreeList() {
                    var _this = _super.call(this) || this;
                    _this._positionGenerator = null;
                    var random = new def.Random(0);
                    random.autoSeed();
                    _this._positionGenerator = random;
                    return _this;
                }
                /**
                 * Inserts the given new event-note directly before the specified Event
                 * note. Registers <code>where</code> as connected to <code>newNote</code>.
                 *
                 * @param {desmoj.core.simulator.EventNote} where :
                 * the event-note before which the new note shall be inserted
                 * @param {desmoj.core.simulator.EventNote} newNote :
                 * the new event-note to be inserted
                 */
                RandomizingEventTreeList.prototype.insertBefore = function (where, newNote) {
                    _super.prototype.insertBefore.call(this, where, newNote);
                    var i = this.eTreeList.indexOf(where);
                    if (i >= 0)
                        where.setConnected(true);
                };
                /**
                 * Inserts the given new event-note directly behind the specified Event
                 * note. Registers <code>newNote</code> as connected to <code>where</code>.
                 *
                 * @param {desmoj.core.simulator.EventNote} where :
                 * the event-note after which the new note shall be inserted
                 * @param {desmoj.core.simulator.EventNote} newNote :
                 * the new event-note to be inserted
                 */
                RandomizingEventTreeList.prototype.insertAfter = function (where, newNote) {
                    _super.prototype.insertAfter.call(this, where, newNote);
                    var i = this.eTreeList.indexOf(newNote);
                    if (i >= 0)
                        newNote.setConnected(true);
                };
                /**
                 * Inserts the given event-note at the front of the event tree list.
                 *
                 * @param {desmoj.core.simulator.EventNote} newNote
                 * EventNote : the new event-note to be inserted as first note.
                 */
                RandomizingEventTreeList.prototype.insertAsFirst = function (newNote) {
                    _super.prototype.insertAsFirst.call(this, newNote);
                    newNote.setConnected(false);
                };
                /**
                 * Removes the given note from the event tree list.
                 * A connection between the note's previous and next note
                 * is established if and only if the given note was
                 * connnect to both the previous and next node.
                 *
                 * @param {desmoj.core.simulator.EventNote} note
                 * EventNote : the event-note to be removed
                 */
                RandomizingEventTreeList.prototype.remove = function (note) {
                    var i = this.eTreeList.indexOf(note);
                    if (i >= 0) {
                        var prev = this.prevNote(note);
                        var next = this.nextNote(note);
                        if (prev != null && next != null) {
                            if (note.isConnected() && next.isConnected())
                                next.setConnected(true);
                            else
                                next.setConnected(false);
                        }
                        _super.prototype.remove.call(this, note);
                    }
                };
                /**
                 * Removes the first event-note (if any).
                 * @return {desmoj.core.simulator.EventNote}
                 */
                RandomizingEventTreeList.prototype.removeFirst = function () {
                    if (!this.isEmpty()) {
                        var note = _super.prototype.removeFirst.call(this);
                        if (this.isEmpty())
                            this.firstNote().setConnected(false);
                        return note;
                    }
                    return null;
                };
                /**
                 * Inserts the given event-note into the event tree list. Overwrites the
                 * inherited insert() method to achieve random insert for concurrent Events.
                 * Takes possible connections between existing event-notes into account,
                 * i.e. will not insert the new note between connected events. Connections
                 * may only exist between two events of the same time where one of the
                 * events has been inserted via insertBefore() or insertAfter().
                 *
                 * @param {desmoj.core.simulator.EventNote} newNote
                 * EventNote : the event-note to be inserted
                 */
                RandomizingEventTreeList.prototype.insert = function (newNote) {
                    if (this.isEmpty()) {
                        _super.prototype.insert.call(this, newNote);
                        newNote.setConnected(false);
                        return;
                    }
                    var refTime = newNote.getTime();
                    var refPrio = newNote.getPriority();
                    var firstIndexForInsert;
                    var lastIndexForInsert;
                    var left = 0;
                    var right = this.eTreeList.length;
                    while ((left < right)) {
                        var middle = ((left + right) / 2 | 0);
                        if (desmoj.core.simulator.TimeInstant.isBefore(this.eTreeList[middle].getTime(), refTime) || (desmoj.core.simulator.TimeInstant.isEqual(this.eTreeList[middle].getTime(), refTime) && this.eTreeList[middle].getPriority() > refPrio)) {
                            left = middle + 1;
                        }
                        else {
                            right = middle;
                        }
                    }
                    ;
                    if (right < this.eTreeList.length && desmoj.core.simulator.TimeInstant.isEqual(this.eTreeList[right].getTime(), refTime) && this.eTreeList[right].getPriority() === refPrio) {
                        firstIndexForInsert = right;
                        lastIndexForInsert = this.findLastIndex(firstIndexForInsert) + 1;
                    }
                    else {
                        firstIndexForInsert = right;
                        lastIndexForInsert = firstIndexForInsert;
                    }
                    if (firstIndexForInsert !== lastIndexForInsert) {
                        firstIndexForInsert += this._positionGenerator.nextIntWithBound(lastIndexForInsert - firstIndexForInsert + 1);
                        while ((firstIndexForInsert < this.eTreeList.length && this.eTreeList[firstIndexForInsert].isConnected()))
                            firstIndexForInsert++;
                    }
                    /* add */ this.eTreeList.splice(firstIndexForInsert, 0, newNote);
                    newNote.setConnected(false);
                };
                /**
                 * This helper method determines the position of the last event-note with
                 * the same time/priority as the event-note at position firstIndex doing a simple
                 * linear search from firstIndex.
                 * @param {number} firstIndex
                 * @return {number}
                 */
                RandomizingEventTreeList.prototype.findLastIndex = function (firstIndex) {
                    var refTime = this.eTreeList[firstIndex].getTime();
                    var refPrio = this.eTreeList[firstIndex].getPriority();
                    var lastIndex = firstIndex + 1;
                    while ((lastIndex < this.eTreeList.length && desmoj.core.simulator.TimeInstant.isEqual(refTime, this.eTreeList[lastIndex].getTime()) && refPrio === this.eTreeList[lastIndex].getPriority())) {
                        lastIndex++;
                    }
                    ;
                    return lastIndex - 1;
                };
                /**
                 * Returns if the event-list processes concurrent Events in random order or
                 * not.
                 *
                 * @return {boolean} boolean: <code>true</code> since random order used if time and pririty equal
                 */
                RandomizingEventTreeList.prototype.isRandomizingConcurrentEvents = function () {
                    return true;
                };
                return RandomizingEventTreeList;
            }(desmoj.core.simulator.EventTreeList));
            simulator.RandomizingEventTreeList = RandomizingEventTreeList;
            RandomizingEventTreeList["__class"] = "desmoj.core.simulator.RandomizingEventTreeList";
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            var html5chart;
            (function (html5chart) {
                /**
                 * Create a canvas.
                 *
                 * @param {string} canvasID
                 * The ID of this canvas.
                 * @param {number} canvasHeight
                 * The height of this canvas.<br>
                 * Should be larger then <code>this.getTopGap() + this.getBottomGap() + 100</code>.
                 * @param {number} canvasWidth
                 * The width of this canvas.<br>
                 * Should be larger then <code>this.getLeftGap() + this.getRightGap() + 100</code>.
                 *
                 * @param {*} data
                 * @class
                 * @extends desmoj.core.report.html5chart.AbstractNumericalChartCanvas
                 * @author Johanna Djimandjaja
                 */
                var AbstractNumericalCoorChartCanvas = (function (_super) {
                    __extends(AbstractNumericalCoorChartCanvas, _super);
                    function AbstractNumericalCoorChartCanvas(canvasID, canvasHeight, canvasWidth, data) {
                        var _this = _super.call(this, canvasID, canvasHeight, canvasWidth) || this;
                        _this.chartData = null;
                        _this._dataColors = null;
                        _this._numOfYScale = 0;
                        _this._yScale = null;
                        _this.chartData = data;
                        _this._dataColors = new Array(_this.chartData.getNumOfData());
                        _this.determineDataColors();
                        _this.determineYScale();
                        return _this;
                    }
                    /*private*/ AbstractNumericalCoorChartCanvas.getColor = function (index) {
                        var color = null;
                        switch ((index)) {
                            case 0:
                                color = def.Color.black_$LI$();
                                break;
                            case 1:
                                color = def.Color.red_$LI$();
                                break;
                            case 2:
                                color = def.Color.blue_$LI$();
                                break;
                            case 3:
                                color = def.Color.green_$LI$();
                                break;
                            case 4:
                                color = def.Color.pink_$LI$();
                                break;
                            case 5:
                                color = def.Color.darkGray_$LI$();
                                break;
                            case 6:
                                color = def.Color.orange_$LI$();
                                break;
                            case 7:
                                color = def.Color.magenta_$LI$();
                                break;
                            case 8:
                                color = def.Color.yellow_$LI$();
                                break;
                            case 9:
                                color = def.Color.cyan_$LI$();
                                break;
                            case 10:
                                color = def.Color.lightGray_$LI$();
                                break;
                            case 11:
                                color = new def.Color(120, 150, 210);
                                break;
                            case 12:
                                color = new def.Color(106, 50, 154);
                                break;
                            case 13:
                                color = new def.Color(94, 55, 41);
                                break;
                            case 14:
                                color = new def.Color(104, 0, 31);
                                break;
                            case 15:
                                color = new def.Color(180, 144, 90);
                                break;
                            case 16:
                                color = new def.Color(120, 88, 54);
                                break;
                            case 17:
                                color = new def.Color(238, 180, 159);
                                break;
                            case 18:
                                color = new def.Color(184, 135, 100);
                                break;
                            case 19:
                                color = new def.Color(43, 23, 71);
                                break;
                            case 20:
                                color = new def.Color(140, 152, 248);
                                break;
                            case 21:
                                color = new def.Color(255, 255, 128);
                                break;
                            case 22:
                                color = new def.Color(70, 10, 20);
                                break;
                            case 23:
                                color = new def.Color(42, 79, 140);
                                break;
                            default:
                                color = def.Color.black_$LI$();
                                break;
                        }
                        return color;
                    };
                    /**
                     * Determines the colors, representing each data.
                     * @private
                     */
                    /*private*/ AbstractNumericalCoorChartCanvas.prototype.determineDataColors = function () {
                        for (var i = 0; i < this._dataColors.length; i++) {
                            this._dataColors[i] = AbstractNumericalCoorChartCanvas.getColor(i);
                        }
                        ;
                    };
                    /**
                     * Returns the color, that represents the data in cell n.
                     * @param {number} index
                     * the index of the data, which color is asked for
                     *
                     * @return
                     * java.awt.Color : The color of the data at index n.
                     * @return {def.Color}
                     */
                    AbstractNumericalCoorChartCanvas.prototype.getDataColor = function (index) {
                        if (index < 0 || index >= this._dataColors.length) {
                            return def.Color.WHITE_$LI$();
                        }
                        return this._dataColors[index];
                    };
                    /**
                     *
                     * @return
                     * @return {number}
                     */
                    AbstractNumericalCoorChartCanvas.prototype.getNumOfData = function () {
                        return this.chartData.getNumOfData();
                    };
                    /**
                     * Returns the number of scales to be shown on the y-axis.
                     * @return
                     * @return {number}
                     */
                    AbstractNumericalCoorChartCanvas.prototype.getNumOfYScale = function () {
                        return this._numOfYScale;
                    };
                    /**
                     * Returns the difference between each scale on the y-axis.
                     * @return
                     * @return {number}
                     */
                    AbstractNumericalCoorChartCanvas.prototype.getYScale = function () {
                        return this._yScale;
                    };
                    return AbstractNumericalCoorChartCanvas;
                }(desmoj.core.report.html5chart.AbstractNumericalChartCanvas));
                html5chart.AbstractNumericalCoorChartCanvas = AbstractNumericalCoorChartCanvas;
                AbstractNumericalCoorChartCanvas["__class"] = "desmoj.core.report.html5chart.AbstractNumericalCoorChartCanvas";
                AbstractNumericalCoorChartCanvas["__interfaces"] = ["desmoj.core.report.html5chart.Canvas", "desmoj.core.report.html5chart.CanvasCoordinateChart"];
            })(html5chart = report.html5chart || (report.html5chart = {}));
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            var html5chart;
            (function (html5chart) {
                /**
                 * A canvas to display data from multiple TimeSeries.
                 *
                 * @version DESMO-J, Ver. 2.5.1e copyright (c) 2017
                 * @author Johanna Djimandjaja
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License. You
                 * may obtain a copy of the License at
                 * http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS"
                 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
                 * or implied. See the License for the specific language governing
                 * permissions and limitations under the License.
                 * @param {string} name
                 * @param {number} canvasHeight
                 * @param {number} canvasWidth
                 * @param {desmoj.core.report.html5chart.ChartDataTimeSeries} timeSeriesData
                 * @param {string} axis_x
                 * @param {string} axis_y
                 * @class
                 * @extends desmoj.core.report.html5chart.AbstractNumericalChartCanvas
                 */
                var CanvasTimeSeries = (function (_super) {
                    __extends(CanvasTimeSeries, _super);
                    function CanvasTimeSeries(name, canvasHeight, canvasWidth, timeSeriesData, axis_x, axis_y) {
                        var _this = _super.call(this, name, canvasHeight, canvasWidth) || this;
                        _this._xAxisTitle = null;
                        _this._yAxisTitle = null;
                        _this._numOfYScale = 0;
                        _this._yScale = 0;
                        _this._numOfXScale = 0;
                        _this._startXScale = 0;
                        _this._xScale = 0;
                        _this._timeSeries = null;
                        _this._dataColors = null;
                        _this._timeSeries = ([]);
                        _this._dataColors = ([]);
                        /* add */ (_this._timeSeries.push(timeSeriesData) > 0);
                        /* add */ (_this._dataColors.push(CanvasTimeSeries.getColor(CanvasTimeSeries.nextColorAvailable++)) > 0);
                        _this._numOfXScale = Number.MIN_VALUE;
                        _this._numOfYScale = Number.MIN_VALUE;
                        _this._startXScale = NaN;
                        _this._xScale = NaN;
                        _this._yScale = NaN;
                        _this._xAxisTitle = axis_x;
                        _this._yAxisTitle = axis_y;
                        return _this;
                    }
                    /*private*/ CanvasTimeSeries.getColor = function (index) {
                        var color = null;
                        switch ((index)) {
                            case 0:
                                color = def.Color.black_$LI$();
                                break;
                            case 1:
                                color = def.Color.red_$LI$();
                                break;
                            case 2:
                                color = def.Color.blue_$LI$();
                                break;
                            case 3:
                                color = def.Color.green_$LI$();
                                break;
                            case 4:
                                color = def.Color.pink_$LI$();
                                break;
                            case 5:
                                color = def.Color.darkGray_$LI$();
                                break;
                            case 6:
                                color = def.Color.orange_$LI$();
                                break;
                            case 7:
                                color = def.Color.magenta_$LI$();
                                break;
                            case 8:
                                color = def.Color.yellow_$LI$();
                                break;
                            case 9:
                                color = def.Color.cyan_$LI$();
                                break;
                            case 10:
                                color = def.Color.lightGray_$LI$();
                                break;
                            case 11:
                                color = new def.Color(120, 150, 210);
                                break;
                            case 12:
                                color = new def.Color(106, 50, 154);
                                break;
                            case 13:
                                color = new def.Color(94, 55, 41);
                                break;
                            case 14:
                                color = new def.Color(104, 0, 31);
                                break;
                            case 15:
                                color = new def.Color(180, 144, 90);
                                break;
                            case 16:
                                color = new def.Color(120, 88, 54);
                                break;
                            case 17:
                                color = new def.Color(238, 180, 159);
                                break;
                            case 18:
                                color = new def.Color(184, 135, 100);
                                break;
                            case 19:
                                color = new def.Color(43, 23, 71);
                                break;
                            case 20:
                                color = new def.Color(140, 152, 248);
                                break;
                            case 21:
                                color = new def.Color(255, 255, 128);
                                break;
                            case 22:
                                color = new def.Color(70, 10, 20);
                                break;
                            case 23:
                                color = new def.Color(42, 79, 140);
                                break;
                            default:
                                color = def.Color.black_$LI$();
                                break;
                        }
                        return color;
                    };
                    /*private*/ CanvasTimeSeries.prototype.determineXScale = function () {
                        if ((this._timeSeries.length == 0)) {
                            this._xScale = 1;
                            this._numOfXScale = 10;
                            this._startXScale = 0;
                        }
                        else {
                            var left = this.getMinTimeValue();
                            var right = this.getMaxTimeValue();
                            var ticks = 10;
                            this._xScale = (right - left) / ticks;
                            this._numOfXScale = ticks;
                            this._startXScale = left;
                        }
                    };
                    /**
                     * Determines the difference between each scale on the y-axis.
                     */
                    CanvasTimeSeries.prototype.determineYScale = function () {
                        var maxEntry = this.getMaxDataValue();
                        if (maxEntry <= 1) {
                            this._numOfYScale = 1;
                            this._yScale = 1;
                            return;
                        }
                        var hight_candidates = [1.2, 1.4, 1.5, 1.8, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0];
                        var hight_candidates_ticks = [6, 7, 6, 9, 10, 10, 6, 7, 8, 9, 10, 6, 7, 8, 9, 10];
                        var power = ((function (x) { return Math.log(x) * Math.LOG10E; })(maxEntry) | 0);
                        var candidate = 0;
                        for (candidate = 0; candidate < hight_candidates.length; candidate++) {
                            if (Math.pow(10, power) * hight_candidates[candidate] > maxEntry)
                                break;
                        }
                        ;
                        this._numOfYScale = hight_candidates_ticks[candidate];
                        this._yScale = Math.pow(10, power) * hight_candidates[candidate] / hight_candidates_ticks[candidate];
                    };
                    /**
                     * Returns the maximum data value of all TimeSeries.<br>
                     * If there're no TimeSeries chart data for this canvas, <code>0</code> will be returned.
                     * @return
                     * @return {number}
                     * @private
                     */
                    /*private*/ CanvasTimeSeries.prototype.getMaxDataValue = function () {
                        var max = 0;
                        for (var index786 = 0; index786 < this._timeSeries.length; index786++) {
                            var timeSeriesData = this._timeSeries[index786];
                            {
                                if (max < timeSeriesData.getHighestDataValue()) {
                                    max = timeSeriesData.getHighestDataValue();
                                }
                            }
                        }
                        return max;
                    };
                    /**
                     * Returns the maximum time value of all TimeSeries.<br>
                     * If there're no TimeSeries chart data for this canvas, <code>0</code> will be returned.
                     * @return
                     * @return {number}
                     * @private
                     */
                    /*private*/ CanvasTimeSeries.prototype.getMaxTimeValue = function () {
                        var max = 0;
                        for (var index787 = 0; index787 < this._timeSeries.length; index787++) {
                            var timeSeriesData = this._timeSeries[index787];
                            {
                                if (timeSeriesData.getValidTo() > max) {
                                    max = timeSeriesData.getValidTo();
                                }
                            }
                        }
                        return max;
                    };
                    /**
                     * Returns the minimum time value of all TimeSeries.<br>
                     * If there're no TimeSeries chart data for this canvas, <code>0</code> will be returned.
                     * @return
                     * @return {number}
                     * @private
                     */
                    /*private*/ CanvasTimeSeries.prototype.getMinTimeValue = function () {
                        if ((this._timeSeries.length == 0)) {
                            return 0;
                        }
                        else {
                            var min = Number.MAX_VALUE;
                            for (var index788 = 0; index788 < this._timeSeries.length; index788++) {
                                var timeSeriesData = this._timeSeries[index788];
                                {
                                    if (timeSeriesData.getValidFrom() < min) {
                                        min = timeSeriesData.getValidFrom();
                                    }
                                }
                            }
                            return min;
                        }
                    };
                    /**
                     * Add a chart data of a TimeSeries to this canvas.
                     * The color will be defined to represent this TimeSeries in the canvas
                     * @param {desmoj.core.report.html5chart.ChartDataTimeSeries} timeSeries
                     * ChartDataTimeSeries: the chart data of a TimeSeries to be added to this canvas
                     * @return
                     * Color: the color defined to represent this TimeSeries in the canvas
                     * @return {def.Color}
                     */
                    CanvasTimeSeries.prototype.addTimeSeries = function (timeSeries) {
                        /* add */ (this._timeSeries.push(timeSeries) > 0);
                        var color = CanvasTimeSeries.getColor(CanvasTimeSeries.nextColorAvailable++);
                        /* add */ (this._dataColors.push(color) > 0);
                        return color;
                    };
                    /**
                     * Returns the color, that represents the TimeSEries at index i.
                     * @param {number} i
                     * @return
                     * @return {def.Color}
                     */
                    CanvasTimeSeries.prototype.getDataColor = function (i) {
                        if (i < 0 || i >= this._timeSeries.length)
                            return def.Color.WHITE_$LI$();
                        return this._dataColors[i];
                    };
                    /**
                     * Returns the number of scales to be shown on the y-axis.
                     * @return
                     * @return {number}
                     */
                    CanvasTimeSeries.prototype.getNumOfYScale = function () {
                        if (this._numOfYScale === Number.MIN_VALUE)
                            this.determineYScale();
                        return this._numOfYScale;
                    };
                    /**
                     * Returns the difference between each scale on the y-axis.
                     * @return
                     * @return {number}
                     */
                    CanvasTimeSeries.prototype.getYScale = function () {
                        if (isNaN(this._yScale))
                            this.determineYScale();
                        return this._yScale;
                    };
                    /**
                     * Returns the number of scales to be shown on the x-axis.
                     * @return
                     * @return {number}
                     */
                    CanvasTimeSeries.prototype.getNumOfXScale = function () {
                        if (this._numOfXScale === Number.MIN_VALUE)
                            this.determineXScale();
                        return this._numOfXScale;
                    };
                    /**
                     * Returns the difference between each scale on the x-axis.
                     * @return
                     * @return {number}
                     */
                    CanvasTimeSeries.prototype.getXScale = function () {
                        if (isNaN(this._xScale))
                            this.determineXScale();
                        return this._xScale;
                    };
                    /**
                     * Returns the number for the first xScale.
                     * @return
                     * @return {number}
                     */
                    CanvasTimeSeries.prototype.getStartXScale = function () {
                        if (isNaN(this._startXScale))
                            this.determineXScale();
                        return this._startXScale;
                    };
                    CanvasTimeSeries.prototype.getNumOfTimeSeries = function () {
                        return this._timeSeries.length;
                    };
                    /**
                     * Returns the data value of the TimeSeriesData at index i.
                     * @param {number} i
                     * @return
                     * @return {Array}
                     */
                    CanvasTimeSeries.prototype.getDataValues = function (i) {
                        if (i < 0 || i >= this.getNumOfTimeSeries())
                            return new Array(0);
                        else
                            return this._timeSeries[i].getDataValues();
                    };
                    /**
                     * Returns the time value of the TimeSeriesData at index i.
                     * @param {number} i
                     * @return
                     * @return {Array}
                     */
                    CanvasTimeSeries.prototype.getTimeValues = function (i) {
                        if (i < 0 || i >= this.getNumOfTimeSeries())
                            return new Array(0);
                        else
                            return this._timeSeries[i].getTimeValues();
                    };
                    /**
                     * Returns the number of TimeSeries displayed by this canvas.
                     * @return {number}
                     */
                    CanvasTimeSeries.prototype.getNumOfData = function () {
                        return this._timeSeries.length;
                    };
                    /**
                     *
                     * @return {string}
                     */
                    CanvasTimeSeries.prototype.getXAxisTitle = function () {
                        return this._xAxisTitle;
                    };
                    /**
                     *
                     * @return {string}
                     */
                    CanvasTimeSeries.prototype.getYAxisTitle = function () {
                        return this._yAxisTitle;
                    };
                    return CanvasTimeSeries;
                }(desmoj.core.report.html5chart.AbstractNumericalChartCanvas));
                CanvasTimeSeries.nextColorAvailable = 0;
                html5chart.CanvasTimeSeries = CanvasTimeSeries;
                CanvasTimeSeries["__class"] = "desmoj.core.report.html5chart.CanvasTimeSeries";
                CanvasTimeSeries["__interfaces"] = ["desmoj.core.report.html5chart.Canvas", "desmoj.core.report.html5chart.CanvasCoordinateChart"];
            })(html5chart = report.html5chart || (report.html5chart = {}));
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Constructs a condition with the given name and parameters for trace
             * files.
             *
             * @param {desmoj.core.simulator.Model} owner
             * Model : The main model this condition is associated to
             * @param {string} name
             * java.lang.String : The name of this condition
             * @param {boolean} showInTrace
             * boolean : Flag for showing this condition in trace-files. Set
             * it to <code>true</code> if model should show up in trace,
             * <code>false</code> if model should not be shown in trace.
             * @param {Array} args
             * Object... : Arguments to pass to the condition (can be omitted)
             *
             * @class
             * @extends desmoj.core.simulator.ModelComponent
             * @author Tim Lechler
             */
            var Condition = (function (_super) {
                __extends(Condition, _super);
                function Condition(owner, name, showInTrace) {
                    var args = [];
                    for (var _i = 3; _i < arguments.length; _i++) {
                        args[_i - 3] = arguments[_i];
                    }
                    var _this = _super.call(this, owner, name, showInTrace) || this;
                    /**
                     * Stores the arguments of a Constructor-call to make a recreation
                     * of the Condition possible.
                     */
                    /*private*/ _this._arguments = null;
                    _this._argumentsPrimitive = false;
                    var types = new Array(3 + args.length);
                    types[0] = desmoj.core.simulator.Model;
                    types[1] = String;
                    types[2] = Boolean;
                    _this._arguments = new Array(3 + args.length);
                    _this._arguments[0] = owner;
                    _this._arguments[1] = name;
                    _this._arguments[2] = showInTrace;
                    _this._argumentsPrimitive = true;
                    for (var i = 0; i < args.length; i++) {
                        var type = _this.getType(args[i]);
                        _this._argumentsPrimitive = (type != null) && _this._argumentsPrimitive;
                        types[i + 3] = type;
                        _this._arguments[i + 3] = args[i];
                    }
                    ;
                    return _this;
                }
                Condition.prototype.hasPrimitiveArguments = function () {
                    return this._argumentsPrimitive;
                };
                Condition.prototype.getConstructArguments = function () {
                    return this._arguments;
                };
                /*private*/ Condition.prototype.getType = function (obj) {
                    var cls = obj.constructor;
                    return (function (o1, o2) { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(cls, Boolean) ? Boolean : (function (o1, o2) { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(cls, Number) ? Number : (function (o1, o2) { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(cls, String) ? String : (function (o1, o2) { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(cls, Number) ? Number : (function (o1, o2) { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(cls, Number) ? Number : (function (o1, o2) { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(cls, Number) ? Number : (function (o1, o2) { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(cls, Number) ? Number : (function (o1, o2) { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(cls, Number) ? Number : (function (o1, o2) { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(cls, String) ? String : null;
                };
                return Condition;
            }(desmoj.core.simulator.ModelComponent));
            simulator.Condition = Condition;
            Condition["__class"] = "desmoj.core.simulator.Condition";
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Constructs a ModelCondition with the given name and parameters for trace
             * files.
             *
             * @param {desmoj.core.simulator.Model} owner
             * Model : The main model this condition is associated to
             * @param {string} name
             * java.lang.String : The name of this condition
             * @param {boolean} showInTrace
             * boolean : Flag for showing this condition in trace-files. Set
             * it to <code>true</code> if model should show up in trace,
             * <code>false</code> if model should not be shown in trace.
             * @param {Array} args
             * Object... : Arguments to pass to the condition (can be omitted)
             *
             * @class
             * @extends desmoj.core.simulator.ModelComponent
             * @author Tim Lechler
             */
            var ModelCondition = (function (_super) {
                __extends(ModelCondition, _super);
                function ModelCondition(owner, name, showInTrace) {
                    var args = [];
                    for (var _i = 3; _i < arguments.length; _i++) {
                        args[_i - 3] = arguments[_i];
                    }
                    var _this = _super.call(this, owner, name, showInTrace) || this;
                    /**
                     * Stores the arguments of a Constructor-call to make a recreation
                     * of the Condition possible.
                     */
                    /*private*/ _this._arguments = null;
                    _this._argumentsPrimitive = false;
                    var types = new Array(3 + args.length);
                    types[0] = desmoj.core.simulator.Model;
                    types[1] = String;
                    types[2] = Boolean;
                    _this._arguments = new Array(3 + args.length);
                    _this._arguments[0] = owner;
                    _this._arguments[1] = name;
                    _this._arguments[2] = showInTrace;
                    _this._argumentsPrimitive = true;
                    for (var i = 0; i < args.length; i++) {
                        var type = _this.getType(args[i]);
                        _this._argumentsPrimitive = (type != null) && _this._argumentsPrimitive;
                        types[i + 3] = type;
                        _this._arguments[i + 3] = args[i];
                    }
                    ;
                    return _this;
                }
                ModelCondition.prototype.hasPrimitiveArguments = function () {
                    return this._argumentsPrimitive;
                };
                ModelCondition.prototype.getConstructArguments = function () {
                    return this._arguments;
                };
                /*private*/ ModelCondition.prototype.getType = function (obj) {
                    var cls = obj.constructor;
                    return (function (o1, o2) { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(cls, Boolean) ? Boolean : (function (o1, o2) { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(cls, Number) ? Number : (function (o1, o2) { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(cls, String) ? String : (function (o1, o2) { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(cls, Number) ? Number : (function (o1, o2) { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(cls, Number) ? Number : (function (o1, o2) { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(cls, Number) ? Number : (function (o1, o2) { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(cls, Number) ? Number : (function (o1, o2) { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(cls, Number) ? Number : (function (o1, o2) { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(cls, String) ? String : null;
                };
                return ModelCondition;
            }(desmoj.core.simulator.ModelComponent));
            simulator.ModelCondition = ModelCondition;
            ModelCondition["__class"] = "desmoj.core.simulator.ModelCondition";
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Creates a reportable object with all parameters required. The reportable
             * registers itself at the given model
             *
             * @param {string} name
             * java.lang.String : The name of this reportable
             * @param {desmoj.core.simulator.Model} owner
             * Model : The model this reportable is associated to
             * @param {boolean} showInReport
             * boolean : Flag for showing the report. Set it to
             * <code>true</code> if reportable should show up in report.
             * Set it to <code>false</code> if reportable should not be
             * shown in report.
             * @param {boolean} showInTrace
             * boolean : Flag for showing this reportable in trace files. Set
             * it to <code>true</code> if reportable should show up in
             * trace. Set it to <code>false</code> if reportable should not
             * be shown in trace.
             * @class
             * @extends desmoj.core.simulator.ModelComponent
             * @author Tim Lechler, modified by Chr. M&uuml;ller (TH Wildau) 28.11.2012
             */
            var Reportable = (function (_super) {
                __extends(Reportable, _super);
                function Reportable(owner, name, showInReport, showInTrace) {
                    var _this = _super.call(this, owner, name, showInTrace) || this;
                    /**
                     * schedulable (e.g. entity) corresponding to this reportable
                     * maybe null if no schedulable corresponds to this reportable
                     */
                    /*private*/ _this._correspondingSchedulable = null;
                    /**
                     * A class to instantiate a custom reporter from
                     */
                    /*private*/ _this._reporter = null;
                    /**
                     * This Reportable's Reporter
                     */
                    /*private*/ _this._myReporter = null;
                    _this._reportMode = false;
                    _this._observations = 0;
                    _this._lastReset = null;
                    _this.description = null;
                    _this._reportMode = showInReport;
                    _this._observations = 0;
                    if ((owner != null)) {
                        owner.register(_this);
                    }
                    if (owner != null && owner.getExperiment() != null && owner.getExperiment().isRunning()) {
                        _this._lastReset = _this.presentTime();
                    }
                    return _this;
                }
                /**
                 * This method provides a reporter to generate report data about this
                 * reportable. In this general implementation, a <code>StandardReporter</code>
                 * is returned. Lacking further knowledge about a specific reportable,
                 * the <code>StandardReporter</code> is only able to read out the
                 * reportable's name, number of observations and time of last reset.<br/>
                 *
                 * Thus, it is highly recommended that subclasses override this method
                 * to return an appropriate default reporter for the specific reportable
                 * object. All reportable objects in DESMO-J like <code>Accumulate</code>,
                 * <code>Tally</code>, <code>Count</code>, <code>Queue</code>, and many
                 * others provide such reporters. <br/>
                 *
                 * If you want to extend the framework with new reportable objects,
                 * provide a suitable reporter as well and override this method to return
                 * an instance of the reporter. <br/>
                 *
                 * If you just need to replace the reporter used by an existing reportable
                 * (while not requiring any changes to the reportable itself),
                 * there is no need to create a subclass of the reportable: Instead of
                 * overriding this method, just call <code>setReporter()</code> to have
                 * this reportable use a custom reporter instead of the default reporter.
                 *
                 * @return {desmoj.core.report.Reporter} desmoj.core.report.Reporter : A specific reporter for this reportable
                 */
                Reportable.prototype.createDefaultReporter = function () {
                    return new desmoj.core.report.StandardReporter(this);
                };
                /**
                 * Returns an instance of a reporter for this reportable. Note that every reportable
                 * has to provide a default reporter, see method <code>createDefaultReporter()</code>.
                 * The reporter returned by this method is such a default reporter.
                 *
                 * @return {desmoj.core.report.Reporter} desmoj.core.report.Reporter : A reporter for this reportable
                 */
                Reportable.prototype.getReporter = function () {
                    if (this._myReporter != null)
                        return this._myReporter;
                    if (this._reporter == null) {
                        this._myReporter = this.createDefaultReporter();
                        return this._myReporter;
                    }
                    this.tryInstantiatingCustomReporter();
                    return this._myReporter;
                };
                /**
                 * Attempts to create an instance of the custom Reporter for this Reportable.
                 * Since the reflection used in the original method body in Java is not transpilable by JSweet
                 * it has to be implemented in TypeScript as the value of the Replace annotation or after
                 * conversion in the JavaScript code
                 * @private
                 */
                /*private*/ Reportable.prototype.tryInstantiatingCustomReporter = function () {
                    //not yet implemented, therefore keep using default
                };
                /**
                 * Specifies a Reporter-Class to be used as reporter by this reportable.
                 * Note that such a Reporter has to provide a constructor requiring
                 * a reference to this object (i.e. the reportable to report about) as
                 * only parameter.<br/>
                 * If this method is never called, a default reporter as obtained
                 * from <code>createDefaultReporter()</code> will be used.
                 *
                 * @param {*} reporterClass the reporter's class
                 */
                Reportable.prototype.setReporter = function (reporterClass) {
                    this._reporter = reporterClass;
                };
                /**
                 * Returns the number of observations made by the reportable object.
                 *
                 * @return {number} long : The number of observations made by the reportable object.
                 */
                Reportable.prototype.getObservations = function () {
                    return this._observations;
                };
                Reportable.prototype.incrementObservations$ = function () {
                    this._observations++;
                };
                Reportable.prototype.incrementObservations$long = function (multiObservations) {
                    this._observations += multiObservations;
                };
                /**
                 * Increments the number of observations by the amount given as parameter.
                 *
                 * @param {number} multiObservations
                 * long : The number to increase the number of observations by
                 */
                Reportable.prototype.incrementObservations = function (multiObservations) {
                    if (((typeof multiObservations === 'number') || multiObservations === null)) {
                        return this.incrementObservations$long(multiObservations);
                    }
                    else if (multiObservations === undefined) {
                        return this.incrementObservations$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Checks if this reportable produces a report.
                 *
                 * @return {boolean} boolean : true if report will be produced, false otherwise
                 */
                Reportable.prototype.reportIsOn = function () {
                    return this._reportMode;
                };
                /**
                 * Switches report mode to prevent this reportable to produce reports.
                 */
                Reportable.prototype.reportOff = function () {
                    this._reportMode = false;
                };
                /**
                 * Switches report mode of this reportable on to produce a report.
                 */
                Reportable.prototype.reportOn = function () {
                    this._reportMode = true;
                };
                Reportable.prototype.reset = function (newSeed) {
                    if (newSeed === undefined) {
                        return this.reset$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                Reportable.prototype.reset$ = function () {
                    this._observations = 0;
                    this._lastReset = this.presentTime();
                };
                /**
                 * Shows the point in simulation time when the last reset of this reportable
                 * was made.
                 *
                 * @return {desmoj.core.simulator.TimeInstant} TimeInstant : The point of simulation time of the last reset.
                 */
                Reportable.prototype.resetAt = function () {
                    return this._lastReset;
                };
                /**
                 * Gets the schedulable (e.g. entity) corresponding to this reportable;
                 * may be null if no schedulable corresponds to this reportable.
                 *
                 * @return {desmoj.core.simulator.Schedulable} Schedulable : The schedulable (e.g. entity) corresponding
                 * to this reportable (may be null if no schedulable corresponds to this reportable!)
                 */
                Reportable.prototype.getCorrespondingSchedulable = function () {
                    return this._correspondingSchedulable;
                };
                /**
                 * Sets the schedulable (e.g. entity) corresponding to this Reportable.
                 * May be null if no schedulable corresponds to this reportable.
                 * If set, the schedulable must have the same model as this reportable!
                 * A Reportable needs not have a corresponding schedulable.
                 *
                 * @param {desmoj.core.simulator.Schedulable} correspondingSchedulable
                 * Schedulable : The Schedulable corresponding to this Reportable.
                 */
                Reportable.prototype.setCorrespondingSchedulable = function (correspondingSchedulable) {
                    if (this != null && this instanceof desmoj.core.simulator.Model) {
                        this.sendWarning("A Model may not have a corresponding schedulable. Method call ignored.", "Reportable.setCorrespondingSchedulable(Schedulable)", "A Model may not have a corresponding schedulable, because Model contains many corresponding schedulables.", "Do not set corresponding schedulable to a model!");
                        return;
                    }
                    if (correspondingSchedulable != null && this.getModel() !== correspondingSchedulable.getModel()) {
                        this.sendWarning("Schedulable to correspond to this Reportable must belong to the same model!", "Reportable.setCorrespondingSchedulable(Schedulable)", "Model of Reportable and corresponding schedulable must be identical.", "Do not set a corresponding schedulable to another model\'s Schedulable.");
                        return;
                    }
                    this._correspondingSchedulable = correspondingSchedulable;
                };
                /**
                 * Set an optional description of reported value. Default is null.
                 * This value is shown in description reports, only when set.
                 * @param {string} description
                 */
                Reportable.prototype.setDescription = function (description) {
                    this.description = description;
                };
                /**
                 * Get an optional description of reported value. Default is null.
                 * This value is shown in description reports, only when set.
                 * @return
                 * @return {string}
                 */
                Reportable.prototype.getDescription = function () {
                    return this.description;
                };
                return Reportable;
            }(desmoj.core.simulator.ModelComponent));
            simulator.Reportable = Reportable;
            Reportable["__class"] = "desmoj.core.simulator.Reportable";
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Constructs an empty <code>QueueListStandardFifo</code> with no reference to its
             * client QueueBased. This no-arg constructor is necessary to instantiate an
             * object of this class by calling the
             * <code>java.lang.Class.newInstance()</code> method. The reference to the
             * QueueBased object making use of this queue-functionality must be provided
             * later by calling the setQueueBased() method. The initial length is always
             * zero.
             * @class
             * @extends desmoj.core.simulator.QueueListStandard
             * @author Justin Neumann
             */
            var QueueListFifo = (function (_super) {
                __extends(QueueListFifo, _super);
                function QueueListFifo() {
                    var _this = _super.call(this) || this;
                    _this.abbreviation = "FIFO";
                    _this.clientQ = null;
                    return _this;
                }
                /**
                 * Adds a new Entity to the QueueListStandardFifo. Entities are inserted according
                 * to their priority in descending order. The highest priority Entity will
                 * always be first in the queue. Entities with same priority are inserted in
                 * FiFo order.
                 *
                 * @param {desmoj.core.simulator.Entity} e
                 * Entity : The Entity to add to the QueueListStandardFifo
                 */
                QueueListFifo.prototype.insert = function (e) {
                    if (e == null) {
                        this.sendWarning("Can not insert entity. Command ignored.", "Class: QueueListStandardFifo Method: insert(Entity e).", "The Entity reference given as parameter is a null reference.", "Be sure to only use valid references.");
                        return;
                    }
                    if (this.contains(e)) {
                        this.sendWarning("Can not insert entity. Command ignored.", "Class: QueueListStandardFifo Method: insert(Entity e).", "The Entity given as parameter is already enqueued.", "Make sure the entity is not enqueued here by calling method \'contains(Entity e)\'.");
                        return;
                    }
                    if (!this.isEmpty()) {
                        var swap = this.last();
                        while ((desmoj.core.simulator.Entity.isSmaller(swap, e))) {
                            swap = this.pred(swap);
                        }
                        ;
                        if (swap == null) {
                            /* add */ this.queuelist.splice(0, 0, e);
                            this.statisticalInsert(e);
                            e.addQueueBased(this.clientQ);
                        }
                        else {
                            this.insertAfter(e, swap);
                        }
                    }
                    else {
                        /* add */ (this.queuelist.push(e) > 0);
                        e.addQueueBased(this.clientQ);
                        this.statisticalInsert(e);
                    }
                };
                return QueueListFifo;
            }(desmoj.core.simulator.QueueListStandard));
            simulator.QueueListFifo = QueueListFifo;
            QueueListFifo["__class"] = "desmoj.core.simulator.QueueListFifo";
            QueueListFifo["__interfaces"] = ["java.lang.Iterable"];
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Constructs an empty <code>QueueListStandardFifo</code> with no reference to its
             * client QueueBased. This no-arg constructor is necessary to instantiate an
             * object of this class by calling the
             * <code>java.lang.Class.newInstance()</code> method. The reference to the
             * QueueBased object making use of this queue-functionality must be provided
             * later by calling the setQueueBased() method. The initial length is always
             * zero.
             * @class
             * @extends desmoj.core.simulator.QueueListStandard
             * @author Justin Neumann
             */
            var QueueListLifo = (function (_super) {
                __extends(QueueListLifo, _super);
                function QueueListLifo() {
                    var _this = _super.call(this) || this;
                    _this.abbreviation = "LIFO";
                    return _this;
                }
                /**
                 * Adds a new Entity to the QueueListLifo. Entities are inserted according
                 * to their priority in descending order. The highest priority Entity will
                 * always be first in the queue. Entities with same priority are inserted in
                 * LiFo order.
                 *
                 * @param {desmoj.core.simulator.Entity} e
                 * Entity : The Entity to add to the QueueListStandardLifo
                 */
                QueueListLifo.prototype.insert = function (e) {
                    if (e == null) {
                        this.sendWarning("Can not insert entity. Command ignored.", "Class: QueueListStandardFifo Method: insert(Entity e).", "The Entity reference given as parameter is a null reference.", "Be sure to only use valid references.");
                        return;
                    }
                    if (this.contains(e)) {
                        this.sendWarning("Can not insert entity. Command ignored.", "Class: QueueListStandardFifo Method: insert(Entity e).", "The Entity given as parameter is already enqueued.", "Make sure the entity is not enqueued here by calling method \'contains(Entity e)\'.");
                        return;
                    }
                    if (this.size() > 0) {
                        var swap = this.first();
                        while ((desmoj.core.simulator.Entity.isSmaller(e, swap))) {
                            swap = this.succ(swap);
                        }
                        ;
                        if (swap == null) {
                            /* add */ (this.queuelist.push(e) > 0);
                            this.statisticalInsert(e);
                            e.addQueueBased(this.clientQ);
                        }
                        else {
                            this.insertBefore(e, swap);
                        }
                    }
                    else {
                        /* add */ (this.queuelist.push(e) > 0);
                        e.addQueueBased(this.clientQ);
                        this.statisticalInsert(e);
                    }
                };
                return QueueListLifo;
            }(desmoj.core.simulator.QueueListStandard));
            simulator.QueueListLifo = QueueListLifo;
            QueueListLifo["__class"] = "desmoj.core.simulator.QueueListLifo";
            QueueListLifo["__interfaces"] = ["java.lang.Iterable"];
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Constructs an empty <code>QueueListStandardFifo</code> with no reference to its
             * client QueueBased. This no-arg constructor is necessary to instantiate an
             * object of this class by calling the
             * <code>java.lang.Class.newInstance()</code> method. The reference to the
             * QueueBased object making use of this queue-functionality must be provided
             * later by calling the setQueueBased() method. The initial length is always
             * zero.
             * @class
             * @extends desmoj.core.simulator.QueueListStandard
             * @author Johannes G&ouml;bel
             */
            var QueueListRandom = (function (_super) {
                __extends(QueueListRandom, _super);
                function QueueListRandom() {
                    var _this = _super.call(this) || this;
                    _this._positionGenerator = null;
                    _this.abbreviation = "RANDOM";
                    var random = new def.Random(0);
                    random.autoSeed();
                    _this._positionGenerator = random;
                    _this.clientQ = null;
                    return _this;
                }
                /**
                 * Adds a new Entity to the QueueListStandardFifo. The position on which
                 * the entity is inserted is randomly generated, disregarding priorities.
                 *
                 * @param {desmoj.core.simulator.Entity} e
                 * Entity : The Entity to add to the QueueListStandardFifo
                 */
                QueueListRandom.prototype.insert = function (e) {
                    if (e == null) {
                        this.sendWarning("Can not insert entity. Command ignored.", "Class: QueueListRandom Method: insert(Entity e).", "The Entity reference given as parameter is a null reference.", "Be sure to only use valid references.");
                        return;
                    }
                    if (this.contains(e)) {
                        this.sendWarning("Can not insert entity. Command ignored.", "Class: QueueListRandom Method: insert(Entity e).", "The Entity given as parameter is already enqueued.", "Make sure the entity is not enqueued here by calling method \'contains(Entity e)\'.");
                        return;
                    }
                    var position = this._positionGenerator.nextIntWithBound((this.size() + 1));
                    /* add */ this.queuelist.splice(position, 0, e);
                    e.addQueueBased(this.clientQ);
                    this.statisticalInsert(e);
                };
                /**
                 * Sets the seed of this queue list's pseudo random number generator.
                 *
                 * @param {number} newSeed
                 * long : new seed this queue list's pseudo random number generator
                 */
                QueueListRandom.prototype.setSeed = function (newSeed) {
                    this._positionGenerator.setSeed(newSeed);
                };
                return QueueListRandom;
            }(desmoj.core.simulator.QueueListStandard));
            simulator.QueueListRandom = QueueListRandom;
            QueueListRandom["__class"] = "desmoj.core.simulator.QueueListRandom";
            QueueListRandom["__interfaces"] = ["java.lang.Iterable"];
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            /**
             * Creates a DebugOut to print DebugNotes into a HTML page. By opening the
             * file, the necessary HTML tags to define a webpage are already inserted
             * into the file. The parameter given should reflect the experiment that
             * produces this file.
             *
             * @param {number} simTimeFloatingDigits
             * int : The number of floating point digits of the simulation
             * time values to be displayed
             * @param {string} format
             * @class
             * @extends desmoj.core.report.TableOutput
             * @author Tim Lechler, modified by Nicolas Knaak
             */
            var DebugFileOut = (function (_super) {
                __extends(DebugFileOut, _super);
                function DebugFileOut(simTimeFloatingDigits, format) {
                    var _this = _super.call(this, simTimeFloatingDigits, format) || this;
                    _this._lastNote = null;
                    _this._lastNote = null;
                    return _this;
                }
                /**
                 * Closes this DebugOut. Writes the final necessary HTML-tags to close a
                 * table row, the table and finish the HTML-page. Flushes and closes the
                 * FileOutputStream thereafter.
                 */
                DebugFileOut.prototype.close = function () {
                    _super.prototype.close.call(this);
                    this._lastNote = null;
                };
                DebugFileOut.prototype.open$java_lang_String = function (name) {
                    this.open$java_lang_String$java_lang_String(null, name);
                };
                DebugFileOut.prototype.open$java_lang_String$java_lang_String = function (pathname, name) {
                    _super.prototype.open$java_lang_String.call(this, this.createFileName(pathname, name, "debug"));
                    this.formatter.openTable(name + " - debug notes");
                    this.formatter.openRow();
                    this.formatter.writeHeadingCell("model");
                    this.formatter.writeHeadingCell("time");
                    this.formatter.writeHeadingCell("origin");
                    this.formatter.writeHeadingCell("debug information");
                    this.formatter.closeRow();
                };
                /**
                 * Opens a new file with the given file- and pathname for writing DebugNotes
                 * into a HTML table. If no filename is given, the default filename
                 * "DESMOJ_debugfile.html" is used. If no pathname is given the current
                 * working directory (stored as property "user.dir") is used.
                 *
                 * @param {string} name
                 * java.lang.String : The name of the file to be created
                 * @param {string} pathname
                 * java.lang.String : The file's output path
                 */
                DebugFileOut.prototype.open = function (pathname, name) {
                    if (((typeof pathname === 'string') || pathname === null) && ((typeof name === 'string') || name === null)) {
                        return this.open$java_lang_String$java_lang_String(pathname, name);
                    }
                    else if (((typeof pathname === 'string') || pathname === null) && name === undefined) {
                        return this.open$java_lang_String(pathname);
                    }
                    else
                        throw new Error('invalid overload');
                };
                DebugFileOut.prototype.receive$desmoj_core_report_Message = function (m) {
                    if (m == null)
                        return;
                    if (!(m != null && m instanceof desmoj.core.report.DebugNote))
                        return;
                    var tmp = m;
                    this.formatter.openRow();
                    if (this._lastNote == null) {
                        this.formatter.writeCell(tmp.getModelName(), 1);
                        this.formatter.writeCell(this.formatter.writeTime(tmp.getTime()), 1);
                        this.formatter.writeCell(tmp.getOrigin(), 1);
                        this.formatter.writeCell(tmp.getDescription(), 1);
                    }
                    else {
                        if ((function (o1, o2) { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(tmp.getModelName(), this._lastNote.getModelName()))
                            this.formatter.writeCell(" ", 1);
                        else
                            this.formatter.writeCell(this.formatter.writeTime(tmp.getModelName()), 1);
                        if ((function (o1, o2) { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(tmp.getTime(), this._lastNote.getTime()))
                            this.formatter.writeCell(" ", 1);
                        else
                            this.formatter.writeCell(this.formatter.writeTime(tmp.getTime()), 1);
                        if ((function (o1, o2) { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(tmp.getOrigin(), this._lastNote.getOrigin()))
                            this.formatter.writeCell(" ", 1);
                        else
                            this.formatter.writeCell(tmp.getOrigin(), 1);
                        this.formatter.writeCell(tmp.getDescription(), 1);
                    }
                    this._lastNote = tmp;
                    this.formatter.closeRow();
                };
                /**
                 * Receives a debugnote and writes its contents formatted to a HTML table
                 * into a file in the user's default directory. Note that although any type
                 * of message may be given to this method, only debugnotes will be
                 * processed. If other types of messages are given to this method, it will
                 * simply return doing nothing.
                 *
                 * @param {desmoj.core.report.Message} m
                 * Message : The DebugNote to be written to file in HTML-table
                 * format
                 */
                DebugFileOut.prototype.receive = function (m) {
                    if (((m != null && m instanceof desmoj.core.report.Message) || m === null)) {
                        return this.receive$desmoj_core_report_Message(m);
                    }
                    else if (((m != null && m instanceof desmoj.core.report.Reporter) || m === null)) {
                        return this.receive$desmoj_core_report_Reporter(m);
                    }
                    else
                        throw new Error('invalid overload');
                };
                DebugFileOut.prototype.receive$desmoj_core_report_Reporter = function (r) {
                    return;
                };
                return DebugFileOut;
            }(desmoj.core.report.TableOutput));
            report.DebugFileOut = DebugFileOut;
            DebugFileOut["__class"] = "desmoj.core.report.DebugFileOut";
            DebugFileOut["__interfaces"] = ["desmoj.core.report.MessageReceiver"];
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            /**
             * Creates an ErrorOut to print ErrorMessages into a HTML page. By opening
             * the file, the necessary HTML tags to define a webpage are already
             * inserted into the file. The name given should reflect the experiment that
             * produces this file.
             *
             * @param {number} simTimeFloatingDigits
             * int : The number of floating point digits of the simulation
             * time values to be displayed
             * @param {string} format
             * @class
             * @extends desmoj.core.report.TableOutput
             * @author Tim Lechler, modified by Nicolas Knaak
             */
            var ErrorFileOut = (function (_super) {
                __extends(ErrorFileOut, _super);
                function ErrorFileOut(simTimeFloatingDigits, format) {
                    return _super.call(this, simTimeFloatingDigits, format) || this;
                }
                /**
                 * Closes this TraceOut. Writes the final necessary HTML-tags to close a
                 * table row, the table and finish the HTML-page. Flushes and closes the
                 * FileOutputStream thereafter.
                 */
                ErrorFileOut.prototype.close = function () {
                    _super.prototype.close.call(this);
                };
                ErrorFileOut.prototype.open$java_lang_String = function (name) {
                    this.open$java_lang_String$java_lang_String(null, name);
                };
                ErrorFileOut.prototype.open$java_lang_String$java_lang_String = function (pathname, name) {
                    _super.prototype.open$java_lang_String.call(this, this.createFileName(pathname, name, "error"));
                    this.formatter.openTable(name + " - errors & warnings");
                    this.formatter.openRow();
                    this.formatter.writeHeadingCell("model");
                    this.formatter.writeHeadingCell("time");
                    this.formatter.writeHeadingCell("error");
                    this.formatter.writeHeadingCell("content");
                    this.formatter.closeRow();
                };
                /**
                 * Opens a new file with the given file- and pathname for writing
                 * ErrorMessages into a HTML table. If no String is given, the default
                 * filename "DESMOJ_errorfile.html" is used. If no pathname is given the
                 * current working directory (stored as property "user.dir") is used.
                 *
                 * @param {string} name
                 * java.lang.String : The name of the file to be created
                 * @param {string} pathname
                 * java.lang.String : The output path the file is written to
                 */
                ErrorFileOut.prototype.open = function (pathname, name) {
                    if (((typeof pathname === 'string') || pathname === null) && ((typeof name === 'string') || name === null)) {
                        return this.open$java_lang_String$java_lang_String(pathname, name);
                    }
                    else if (((typeof pathname === 'string') || pathname === null) && name === undefined) {
                        return this.open$java_lang_String(pathname);
                    }
                    else
                        throw new Error('invalid overload');
                };
                ErrorFileOut.prototype.receive$desmoj_core_report_Message = function (m) {
                    if (m == null)
                        return;
                    if (!(m != null && m instanceof desmoj.core.report.ErrorMessage))
                        return;
                    var tmp = m;
                    this.formatter.openRow();
                    this.formatter.writeCell(tmp.getModelName(), 1);
                    this.formatter.writeCell(this.formatter.writeTime(tmp.getTime()), 1);
                    this.formatter.writeCell("description", 1);
                    this.formatter.writeCell(tmp.getDescription(), 1);
                    this.formatter.closeRow();
                    this.formatter.openRow();
                    this.formatter.writeCell(" ", 1);
                    this.formatter.writeCell(" ", 1);
                    this.formatter.writeCell("location", 1);
                    this.formatter.writeCell(tmp.getLocation(), 1);
                    this.formatter.closeRow();
                    this.formatter.openRow();
                    this.formatter.writeCell(" ", 1);
                    this.formatter.writeCell(" ", 1);
                    this.formatter.writeCell("reason", 1);
                    this.formatter.writeCell(tmp.getReason(), 1);
                    this.formatter.closeRow();
                    this.formatter.openRow();
                    this.formatter.writeCell(" ", 1);
                    this.formatter.writeCell(" ", 1);
                    this.formatter.writeCell("prevention", 1);
                    this.formatter.writeCell(tmp.getPrevention(), 1);
                    this.formatter.closeRow();
                    try {
                        this.file.flush();
                    }
                    catch (ioEx) {
                        console.info("IOException thrown : " + ioEx);
                        console.info("description: Can\'t flush " + this.fileName);
                        console.info("origin     : Experiment auxiliaries");
                        console.info("location   : ErrorFileOut.receive(Message)");
                        console.info("hint       : Check access to the file and that it is not in use by some other application.");
                        console.info("The System will not be shut down. But it can not be " + "written to the file " + this.fileName + ".  The file may " + "not contain all the important data!");
                    }
                    ;
                };
                /**
                 * Receives a TraceNote and writes its contents formatted to a HTML table
                 * into a file in the user's default directory. Note that although any type
                 * of message may be given to this method, only TraceNotes will be
                 * processed. If other types of messages are given to this method, it will
                 * simply return doing nothing.
                 *
                 * @param {desmoj.core.report.Message} m
                 * Message : The TraceNote to be written to file in HTML-table
                 * format
                 */
                ErrorFileOut.prototype.receive = function (m) {
                    if (((m != null && m instanceof desmoj.core.report.Message) || m === null)) {
                        return this.receive$desmoj_core_report_Message(m);
                    }
                    else if (((m != null && m instanceof desmoj.core.report.Reporter) || m === null)) {
                        return this.receive$desmoj_core_report_Reporter(m);
                    }
                    else
                        throw new Error('invalid overload');
                };
                ErrorFileOut.prototype.receive$desmoj_core_report_Reporter = function (r) {
                    return;
                };
                return ErrorFileOut;
            }(desmoj.core.report.TableOutput));
            report.ErrorFileOut = ErrorFileOut;
            ErrorFileOut["__class"] = "desmoj.core.report.ErrorFileOut";
            ErrorFileOut["__interfaces"] = ["desmoj.core.report.MessageReceiver"];
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            /**
             * Creates a file to print reports into a HTML page. By opening the file,
             * the necessary HTML tags to define a webpage are already inserted into the
             * file. The parameter given should reflect the experiment that produces
             * this file.
             *
             * @param {number} timeFloats
             * int : The number of floating point digits of the simulation
             * time values to be displayed
             * @param {string} formatter
             * @class
             * @extends desmoj.core.report.TableOutput
             * @author Tim Lechler, modified by Nicolas Knaak
             */
            var ReportFileOut = (function (_super) {
                __extends(ReportFileOut, _super);
                function ReportFileOut(timeFloats, formatter) {
                    var _this = _super.call(this, timeFloats, formatter) || this;
                    _this.lastReporter = null;
                    _this._reportNumber = 0;
                    _this.lastReporter = null;
                    _this._reportNumber = 0;
                    return _this;
                }
                /**
                 * Closes this traceout. Writes the final necessary HTML-tags to close a
                 * table row, the table and finish the HTML-page. Flushes and closes the
                 * FileOutputStream thereafter.
                 */
                ReportFileOut.prototype.close = function () {
                    this.formatter.closeTable();
                    this.lastReporter = null;
                    _super.prototype.close.call(this);
                };
                ReportFileOut.prototype.open$java_lang_String = function (name) {
                    this.open$java_lang_String$java_lang_String(null, name);
                };
                ReportFileOut.prototype.open$java_lang_String$java_lang_String = function (pathname, name) {
                    this._reportNumber++;
                    _super.prototype.open$java_lang_String.call(this, this.createFileName(pathname, name, "report"));
                    this.formatter.writeHeading(2, name + " Report");
                };
                /**
                 * Opens a new file with the given file- and pathname for writing reports
                 * into a HTML table. If no String is given, the default filename
                 * "DESMOJ_reportfile.html" is used. If no pathname is given the current
                 * working directory (stored as property "user.dir") is used.
                 *
                 * @param {string} name
                 * java.lang.String : The name of the file to be created
                 * @param {string} pathname
                 * java.lang.String : The file's output path
                 */
                ReportFileOut.prototype.open = function (pathname, name) {
                    if (((typeof pathname === 'string') || pathname === null) && ((typeof name === 'string') || name === null)) {
                        return this.open$java_lang_String$java_lang_String(pathname, name);
                    }
                    else if (((typeof pathname === 'string') || pathname === null) && name === undefined) {
                        return this.open$java_lang_String(pathname);
                    }
                    else
                        throw new Error('invalid overload');
                };
                ReportFileOut.prototype.receive$desmoj_core_report_Message = function (m) {
                    return;
                };
                /**
                 * Messages are not handled by this reportout, so this method simply
                 * returns.
                 *
                 * @param {desmoj.core.report.Message} m
                 * Message : The message passed to this reportout
                 */
                ReportFileOut.prototype.receive = function (m) {
                    if (((m != null && m instanceof desmoj.core.report.Message) || m === null)) {
                        return this.receive$desmoj_core_report_Message(m);
                    }
                    else if (((m != null && m instanceof desmoj.core.report.Reporter) || m === null)) {
                        return this.receive$desmoj_core_report_Reporter(m);
                    }
                    else
                        throw new Error('invalid overload');
                };
                ReportFileOut.prototype.receive$desmoj_core_report_Reporter = function (r) {
                    if (r == null)
                        return;
                    var titleBuf = r.getColumnTitles();
                    var entryBuf = r.getEntries();
                    if (this.lastReporter == null) {
                        this.formatter.openTable(r.getHeading());
                        this.formatter.openRow();
                        for (var i = 0; i < r.numColumns(); i++) {
                            this.formatter.writeHeadingCell(titleBuf[i]);
                        }
                        ;
                        this.formatter.closeRow();
                        this.lastReporter = r;
                    }
                    if (desmoj.core.report.Reporter.isOtherGroup(r, this.lastReporter)) {
                        this.formatter.closeTable();
                        this.formatter.writeHorizontalRuler();
                        this.formatter.openTable(r.getHeading());
                        this.formatter.openRow();
                        for (var i = 0; i < r.numColumns(); i++) {
                            this.formatter.writeHeadingCell(titleBuf[i]);
                        }
                        ;
                        this.formatter.closeRow();
                    }
                    this.formatter.openRow();
                    for (var i = 0; i < r.numColumns(); i++) {
                        this.formatter.writeCell(entryBuf[i], 1);
                    }
                    ;
                    this.formatter.closeRow();
                    this.lastReporter = r;
                };
                return ReportFileOut;
            }(desmoj.core.report.TableOutput));
            report.ReportFileOut = ReportFileOut;
            ReportFileOut["__class"] = "desmoj.core.report.ReportFileOut";
            ReportFileOut["__interfaces"] = ["desmoj.core.report.MessageReceiver"];
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            /**
             * Creates a TraceOut to print tracemessages into a HTML page. By opening
             * the file, the necessary HTML tags to define a webpage are already
             * inserted into the file. The parameter given should reflect the experiment
             * that produces this file.
             *
             * @param {number} simTimeFloatingDigits
             * int : The number of floating point digits of the simulation
             * time values to be displayed
             * @param {string} format
             * @class
             * @extends desmoj.core.report.TableOutput
             * @author Tim Lechler, modified by Nicolas Knaak
             */
            var TraceFileOut = (function (_super) {
                __extends(TraceFileOut, _super);
                function TraceFileOut(simTimeFloatingDigits, format) {
                    var _this = _super.call(this, simTimeFloatingDigits, format) || this;
                    _this._lastNote = null;
                    _this._lastNote = null;
                    return _this;
                }
                /**
                 * Closes this TraceOut. Writes the final necessary HTML-tags to close a
                 * table row, the table and finish the HTML-page. Flushes and closes the
                 * FileOutputStream thereafter.
                 */
                TraceFileOut.prototype.close = function () {
                    this.formatter.closeTable();
                    _super.prototype.close.call(this);
                    this._lastNote = null;
                };
                TraceFileOut.prototype.open$java_lang_String = function (name) {
                    this.open$java_lang_String$java_lang_String(null, name);
                };
                TraceFileOut.prototype.open$java_lang_String$java_lang_String = function (pathname, name) {
                    _super.prototype.open$java_lang_String.call(this, this.createFileName(pathname, name, "trace"));
                    this.formatter.openTable(name + " - Trace");
                    this.formatter.openRow();
                    this.formatter.writeHeadingCell("model");
                    this.formatter.writeHeadingCell("time");
                    this.formatter.writeHeadingCell("event");
                    this.formatter.writeHeadingCell("entity");
                    this.formatter.writeHeadingCell("action(s)");
                    this.formatter.closeRow();
                };
                /**
                 * Opens a new file with the given file- and pathname for writing tracenotes
                 * into a HTML table. If no String is given, the default filename
                 * "DESMOJ_tracefile.html" is used. If no pathname is given the current
                 * working directory (stored as property "user.dir") is used.
                 *
                 * @param {string} name
                 * java.lang.String : The name of the file to be created
                 * @param {string} pathname
                 * java.lang.String: The name of the output path for the file
                 */
                TraceFileOut.prototype.open = function (pathname, name) {
                    if (((typeof pathname === 'string') || pathname === null) && ((typeof name === 'string') || name === null)) {
                        return this.open$java_lang_String$java_lang_String(pathname, name);
                    }
                    else if (((typeof pathname === 'string') || pathname === null) && name === undefined) {
                        return this.open$java_lang_String(pathname);
                    }
                    else
                        throw new Error('invalid overload');
                };
                TraceFileOut.prototype.receive$desmoj_core_report_Message = function (m) {
                    if (m == null)
                        return;
                    if (!(m != null && m instanceof desmoj.core.report.TraceNote))
                        return;
                    var tmp = m;
                    this.formatter.openRow();
                    if (this._lastNote == null) {
                        this.formatter.writeCell(tmp.getModelName(), 1);
                        this.formatter.writeCell(this.formatter.writeTime(tmp.getTime()), 1);
                        this.formatter.writeCell(tmp.getEvent(), 1);
                        this.formatter.writeCell(tmp.getEntity(), 1);
                        this.formatter.writeCell(tmp.getDescription(), 1);
                    }
                    else {
                        if ((function (o1, o2) { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(tmp.getModelName(), this._lastNote.getModelName()))
                            this.formatter.writeCell(" ", 1);
                        else
                            this.formatter.writeCell(tmp.getModelName(), 1);
                        if ((function (o1, o2) { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(tmp.getTime(), this._lastNote.getTime()))
                            this.formatter.writeCell(" ", 1);
                        else
                            this.formatter.writeCell(this.formatter.writeTime(tmp.getTime()), 1);
                        if ((function (o1, o2) { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(tmp.getEvent(), this._lastNote.getEvent()))
                            this.formatter.writeCell(" ", 1);
                        else
                            this.formatter.writeCell(tmp.getEvent(), 1);
                        if ((function (o1, o2) { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(tmp.getEntity(), this._lastNote.getEntity()))
                            this.formatter.writeCell(" ", 1);
                        else
                            this.formatter.writeCell(tmp.getEntity(), 1);
                        this.formatter.writeCell(tmp.getDescription(), 1);
                    }
                    this._lastNote = tmp;
                    this.formatter.closeRow();
                };
                /**
                 * Receives a TraceNote and writes its contents formatted to a HTML table
                 * into a file in the user's default directory. Note that although any type
                 * of message may be given to this method, only tracenotes will be
                 * processed. If other types of messages are given to this method, it will
                 * simply return doing nothing.
                 *
                 * @param {desmoj.core.report.Message} m
                 * Message : The TraceNote to be written to file in HTML-table
                 * format
                 */
                TraceFileOut.prototype.receive = function (m) {
                    if (((m != null && m instanceof desmoj.core.report.Message) || m === null)) {
                        return this.receive$desmoj_core_report_Message(m);
                    }
                    else if (((m != null && m instanceof desmoj.core.report.Reporter) || m === null)) {
                        return this.receive$desmoj_core_report_Reporter(m);
                    }
                    else
                        throw new Error('invalid overload');
                };
                TraceFileOut.prototype.receive$desmoj_core_report_Reporter = function (r) {
                    return;
                };
                return TraceFileOut;
            }(desmoj.core.report.TableOutput));
            report.TraceFileOut = TraceFileOut;
            TraceFileOut["__class"] = "desmoj.core.report.TraceFileOut";
            TraceFileOut["__interfaces"] = ["desmoj.core.report.MessageReceiver"];
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            var html5chart;
            (function (html5chart) {
                /**
                 * A chart to represent <code>Double</code> data on the y-axis of a coordinate system.
                 *
                 * @version DESMO-J, Ver. 2.5.1e copyright (c) 2017
                 * @author Johanna Djimandjaja
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License. You
                 * may obtain a copy of the License at
                 * http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS"
                 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
                 * or implied. See the License for the specific language governing
                 * permissions and limitations under the License.
                 * @param {string} canvasName
                 * @param {number} canvasHeight
                 * @param {number} canvasWidth
                 * @param {*} data
                 * @class
                 * @extends desmoj.core.report.html5chart.AbstractNumericalCoorChartCanvas
                 */
                var AbstractNumericalCoorChartCanvasDouble = (function (_super) {
                    __extends(AbstractNumericalCoorChartCanvasDouble, _super);
                    function AbstractNumericalCoorChartCanvasDouble(canvasName, canvasHeight, canvasWidth, data) {
                        return _super.call(this, canvasName, canvasHeight, canvasWidth, data) || this;
                    }
                    /**
                     * Determines the number of scales on the y-axis and the difference between each scale.
                     */
                    AbstractNumericalCoorChartCanvasDouble.prototype.determineYScale = function () {
                        var maxEntry = this.chartData.getHighestDataValue();
                        if (maxEntry <= 1) {
                            this._numOfYScale = 1;
                            this._yScale = 1.0;
                            return;
                        }
                        var hight_candidates = [1.2, 1.4, 1.5, 1.8, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0];
                        var hight_candidates_ticks = [6, 7, 6, 9, 10, 10, 6, 7, 8, 9, 10, 6, 7, 8, 9, 10];
                        var power = ((function (x) { return Math.log(x) * Math.LOG10E; })(maxEntry) | 0);
                        var candidate = 0;
                        for (candidate = 0; candidate < hight_candidates.length; candidate++) {
                            if (Math.pow(10, power) * hight_candidates[candidate] > maxEntry)
                                break;
                        }
                        ;
                        this._numOfYScale = hight_candidates_ticks[candidate];
                        this._yScale = Math.pow(10, power) * hight_candidates[candidate] / hight_candidates_ticks[candidate];
                    };
                    return AbstractNumericalCoorChartCanvasDouble;
                }(desmoj.core.report.html5chart.AbstractNumericalCoorChartCanvas));
                html5chart.AbstractNumericalCoorChartCanvasDouble = AbstractNumericalCoorChartCanvasDouble;
                AbstractNumericalCoorChartCanvasDouble["__class"] = "desmoj.core.report.html5chart.AbstractNumericalCoorChartCanvasDouble";
                AbstractNumericalCoorChartCanvasDouble["__interfaces"] = ["desmoj.core.report.html5chart.Canvas", "desmoj.core.report.html5chart.CanvasCoordinateChart"];
            })(html5chart = report.html5chart || (report.html5chart = {}));
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            var html5chart;
            (function (html5chart) {
                /**
                 * A chart to represent <code>Long</code> data on the y-axis of a coordinate system.
                 *
                 * @version DESMO-J, Ver. 2.5.1e copyright (c) 2017
                 * @author Johanna Djimandjaja
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License. You
                 * may obtain a copy of the License at
                 * http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS"
                 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
                 * or implied. See the License for the specific language governing
                 * permissions and limitations under the License.
                 * @param {string} canvasName
                 * @param {number} canvasHeight
                 * @param {number} canvasWidth
                 * @param {*} data
                 * @class
                 * @extends desmoj.core.report.html5chart.AbstractNumericalCoorChartCanvas
                 */
                var AbstractNumericalCoorChartCanvasLong = (function (_super) {
                    __extends(AbstractNumericalCoorChartCanvasLong, _super);
                    function AbstractNumericalCoorChartCanvasLong(canvasName, canvasHeight, canvasWidth, data) {
                        return _super.call(this, canvasName, canvasHeight, canvasWidth, data) || this;
                    }
                    /**
                     * Determines the number of scales on the y-axis and the difference between each scale.
                     */
                    AbstractNumericalCoorChartCanvasLong.prototype.determineYScale = function () {
                        var maxEntry = this.chartData.getHighestDataValue();
                        if (maxEntry <= 10) {
                            this._numOfYScale = maxEntry;
                            this._yScale = 1;
                            return;
                        }
                        var hight_candidates = [12, 15, 20, 25, 30, 40, 50, 60, 70, 80, 90, 100];
                        var hight_candidates_ticks = [6, 3, 10, 5, 6, 8, 10, 6, 7, 8, 9, 10];
                        var power = ((function (x) { return Math.log(x) * Math.LOG10E; })(maxEntry) | 0) - 1;
                        var base = (Math.pow(10, power) | 0);
                        var candidate = 0;
                        for (candidate = 0; candidate < hight_candidates.length; candidate++) {
                            if (base * hight_candidates[candidate] > maxEntry)
                                break;
                        }
                        ;
                        this._numOfYScale = hight_candidates_ticks[candidate];
                        this._yScale = Math.floor(((base * hight_candidates[candidate] / hight_candidates_ticks[candidate] | 0)));
                        while ((this._numOfYScale <= 5 && this._yScale % 10 === 0)) {
                            this._numOfYScale *= 2;
                            this._yScale /= 2;
                        }
                        ;
                    };
                    return AbstractNumericalCoorChartCanvasLong;
                }(desmoj.core.report.html5chart.AbstractNumericalCoorChartCanvas));
                html5chart.AbstractNumericalCoorChartCanvasLong = AbstractNumericalCoorChartCanvasLong;
                AbstractNumericalCoorChartCanvasLong["__class"] = "desmoj.core.report.html5chart.AbstractNumericalCoorChartCanvasLong";
                AbstractNumericalCoorChartCanvasLong["__interfaces"] = ["desmoj.core.report.html5chart.Canvas", "desmoj.core.report.html5chart.CanvasCoordinateChart"];
            })(html5chart = report.html5chart || (report.html5chart = {}));
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var dist;
        (function (dist) {
            /**
             * Creates a RandomDistribution object which gets its initial seed from the
             * experiment's seedgenerator. The
             * <code>LinearCongruentialRandomGenerator</code> is used as the underlying
             * uniform pseudo random number generator for all pseudo random distribution
             * .
             *
             * @param {desmoj.core.simulator.Model} owner
             * Model : The distribution's owner
             * @param {string} name
             * java.lang.String : The distribution's name
             * @param {boolean} showInReport
             * boolean : Flag to show distribution in report
             * @param {boolean} showInTrace
             * boolean : Flag to show distribution in trace
             * @class
             * @extends desmoj.core.simulator.Reportable
             * @author Tim Lechler
             */
            var Distribution = (function (_super) {
                __extends(Distribution, _super);
                function Distribution(owner, name, showInReport, showInTrace) {
                    var _this = _super.call(this, owner, name, showInReport, showInTrace) || this;
                    _this.randomGenerator = null;
                    _this.antithetic = false;
                    _this.initialSeed = 0;
                    _this.nonNegative = false;
                    if (_this.randomGenerator == null) {
                        try {
                            var rgc = owner.getExperiment().getDistributionManager().getRandomNumberGenerator();
                            _this.randomGenerator = new rgc();
                        }
                        catch (__e) {
                            if (__e != null && (__e["__classes"] && __e["__classes"].indexOf("java.lang.InstantiationException") >= 0)) {
                                var e = __e;
                                _this.randomGenerator = new desmoj.core.dist.LinearCongruentialRandomGenerator();
                            }
                            if (__e != null && (__e["__classes"] && __e["__classes"].indexOf("java.lang.IllegalAccessException") >= 0)) {
                                var e = __e;
                                _this.randomGenerator = new desmoj.core.dist.LinearCongruentialRandomGenerator();
                            }
                        }
                        ;
                    }
                    owner.getExperiment().getDistributionManager().register(_this);
                    if (owner.getExperiment().isRunning()) {
                        _this.randomGenerator.setSeed(_this.initialSeed);
                    }
                    return _this;
                }
                /**
                 * Changes the underlying random generator to the one given as a parameter.
                 * Custom random generators have to implement the
                 * desmoj.dist.UniormRandomGenerator interface. Note that changing the
                 * underlying random generator forces a reset, since a new generator might
                 * produce a completely different stream of pseudo random numbers that won't
                 * enable us to reproduce the stream of numbers probably delivered by the
                 * previously used generator.
                 *
                 * @param {*} randomGenerator
                 * java.util.Random : the random generator used for creating
                 * distributions
                 */
                Distribution.prototype.changeRandomGenerator = function (randomGenerator) {
                    this.randomGenerator = randomGenerator;
                    this.reset();
                };
                /**
                 * Creates the default reporter associated with this distribution. The basic
                 * <code>DistributionReporter</code> returned as a default implementation of
                 * this method simply reports the distribution's name, number of
                 * observations (samples given), seed and point of simulation time of the
                 * last reset.
                 *
                 * @return {desmoj.core.report.Reporter} Reportable : The reporter associated with this distribution
                 * @see desmoj.core.report.DistributionReporter
                 */
                Distribution.prototype.createDefaultReporter = function () {
                    return new desmoj.core.report.DistributionReporter(this);
                };
                /**
                 * Returns the seed value since last reset.
                 *
                 * @return {number} long : The initial seed value
                 */
                Distribution.prototype.getInitialSeed = function () {
                    return this.initialSeed;
                };
                /**
                 * Tells if this distribution can return negative samples.
                 *
                 * @return {boolean} boolean : If <code>true</code> it returns positive samples only
                 */
                Distribution.prototype.getNonNegative = function () {
                    return this.nonNegative;
                };
                /**
                 * Returns the number of Samples given by this distribution. The number of
                 * samples is increased whenever the sample() method is called. It is based
                 * on the random numbers of the distribution, not on the number of random
                 * numbers produced by the underlying random generator, since some
                 * distributions use algorithms consuming more than one uniformly
                 * distributed random number to produce one sample following the desired
                 * distribution.
                 *
                 * @return {number} long : the number of samples given to clients
                 */
                Distribution.prototype.getNumSamples = function () {
                    return this.getObservations();
                };
                /**
                 * Returns the current status for antithetic random number generation in
                 * this distribution.
                 *
                 * @return {boolean} boolean : The status of antithetic pseudo random number
                 * generation
                 * @see desmoj.core.dist.Distribution#setAntithetic
                 */
                Distribution.prototype.isAntithetic = function () {
                    return this.antithetic;
                };
                Distribution.prototype.reset$ = function () {
                    if (this.randomGenerator == null) {
                        try {
                            var rgc = this.getModel().getExperiment().getDistributionManager().getRandomNumberGenerator();
                            this.randomGenerator = new rgc();
                        }
                        catch (__e) {
                            if (__e != null && (__e["__classes"] && __e["__classes"].indexOf("java.lang.InstantiationException") >= 0)) {
                                var e = __e;
                                this.randomGenerator = new desmoj.core.dist.LinearCongruentialRandomGenerator();
                            }
                            if (__e != null && (__e["__classes"] && __e["__classes"].indexOf("java.lang.IllegalAccessException") >= 0)) {
                                var e = __e;
                                this.randomGenerator = new desmoj.core.dist.LinearCongruentialRandomGenerator();
                            }
                        }
                        ;
                    }
                    this.randomGenerator.setSeed(this.initialSeed);
                    _super.prototype.reset.call(this);
                };
                Distribution.prototype.reset$long = function (newSeed) {
                    this.randomGenerator.setSeed(newSeed);
                    this.initialSeed = newSeed;
                    _super.prototype.reset.call(this);
                };
                /**
                 * Resets the pseudo random generator's seed to the value passed, the number
                 * of samples given to zero and sets antithetic to false for this
                 * distribution. Acts the same as a call of method <code>reset()</code> and
                 * a consecutive call to <code>setSeed(long)</code>.
                 *
                 * @param {number} newSeed
                 * long : new seed to be used by underlying random number
                 * generator after reset
                 */
                Distribution.prototype.reset = function (newSeed) {
                    if (((typeof newSeed === 'number') || newSeed === null)) {
                        return this.reset$long(newSeed);
                    }
                    else if (newSeed === undefined) {
                        return this.reset$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Switches this distribution to produce antithetic samples. To obtain
                 * antithetic random numbers, call this method with the parameter
                 * <code>true</code>. Antithetic random numbers are used to minimize the
                 * standard deviation of a series of simulation runs. The results of a run
                 * with normal random numbers has to be standardized with the results of a
                 * run using antithetic random numbers, thus doubling the number of samples
                 * needed, but also lowering the standard deviation of the results of that
                 * simulation. See [Page91, p.139].
                 *
                 * @param {boolean} newAntiStatus
                 * boolean : Parameter <code>true</code> switches antithetic mode
                 * on, <code>false</code> switches antithetic mode off
                 */
                Distribution.prototype.setAntithetic = function (newAntiStatus) {
                    this.antithetic = newAntiStatus;
                    this.reset();
                };
                /**
                 * Sets the nonNegative switch to the given value. If nonNegative is set to
                 * <code>true</code> the distribution returns positive samples only,
                 * otherwise it also produces negative samples, if possible.
                 *
                 * @param {boolean} newValue
                 * boolean : If <code>true</code> the distribution is set to
                 * return positive samples only, otherwise it also produces
                 * negative samples, if possible.
                 */
                Distribution.prototype.setNonNegative = function (newValue) {
                    this.nonNegative = newValue;
                };
                /**
                 * Sets the underlying pseudo random number generator's seed to the value
                 * given. The seed controls the starting value of the random generators and
                 * all following generated pseudo random numbers. Resetting the seed between
                 * two simulation runs will let you use identical streams of random numbers.
                 * That will enable you to compare different strategies within your model
                 * based on the same random number stream produced by the random generator.
                 *
                 * @param {number} newSeed
                 * long : new seed used by underlying pseudo random number
                 * generator
                 */
                Distribution.prototype.setSeed = function (newSeed) {
                    this.randomGenerator.setSeed(newSeed);
                    this.initialSeed = newSeed;
                    this.reset();
                };
                /**
                 * Generates the trace output of each sample. This method is called by
                 * sample().
                 *
                 * @param {string} sample
                 * String : The last sample, converted to a String
                 */
                Distribution.prototype.traceLastSample = function (sample) {
                    if (this.currentlySendTraceNotes())
                        this.sendTraceNote("samples " + sample + " from " + this.getName());
                };
                return Distribution;
            }(desmoj.core.simulator.Reportable));
            dist.Distribution = Distribution;
            Distribution["__class"] = "desmoj.core.dist.Distribution";
        })(dist = core.dist || (core.dist = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            /**
             * Creates a simulation run reporter for the given model.
             *
             * @param {desmoj.core.simulator.Model} model
             * Model : The model to report about.
             * @class
             * @extends desmoj.core.report.TableReporter
             * @author Tim Lechler, Johannes G&ouml;bel
             */
            var SimulationRunReporter = (function (_super) {
                __extends(SimulationRunReporter, _super);
                function SimulationRunReporter(model) {
                    var _this = _super.call(this, model, "Simulation Run") || this;
                    _this.startedAtSystemMillis = 0;
                    _this.startedAtSystemMillis = def.System.currentTimeMillis();
                    _this.groupID = 2000000000;
                    _this.__numRows = 5;
                    _this.__numColumns = 2;
                    _this.columns = ["Property", "Content"];
                    _this.groupHeading = "";
                    return _this;
                }
                /**
                 * Returns the output of the SimulationRunReporter.
                 *
                 * @return {Array} String[][] : The simulation data to be written into the report.
                 */
                SimulationRunReporter.prototype.getEntryTable = function () {
                    var endAtSystemMillis = def.System.currentTimeMillis();
                    var days_tot = 0;
                    var hours_tot = 0;
                    var minutes_tot = 0;
                    var seconds_tot = 0;
                    var elapsed_tot = (((endAtSystemMillis - this.startedAtSystemMillis) | 0) / 1000 | 0);
                    seconds_tot = elapsed_tot % 60;
                    elapsed_tot /= 60;
                    minutes_tot = elapsed_tot % 60;
                    elapsed_tot /= 60;
                    hours_tot = elapsed_tot % 24;
                    elapsed_tot /= 24;
                    days_tot = elapsed_tot;
                    var duration_tot = (days_tot > 0 ? days_tot + " day" + (days_tot > 1 ? "s " : " ") : "") + hours_tot + ":" + minutes_tot + ":" + seconds_tot;
                    this.entryTable = (function (dims) { var allocate = function (dims) { if (dims.length == 0) {
                        return undefined;
                    }
                    else {
                        var array = [];
                        for (var i = 0; i < dims[0]; i++) {
                            array.push(allocate(dims.slice(1)));
                        }
                        return array;
                    } }; return allocate(dims); })([this.__numRows, this.__numColumns]);
                    var m = this.source;
                    this.entryTable[0][0] = "Simulation duration";
                    this.entryTable[0][1] = "Experiment run from " + desmoj.core.simulator.TimeOperations.getStartTime() + " until " + m.presentTime() + ".";
                    this.entryTable[1][0] = "Computation duration (HH:MM:SS)";
                    this.entryTable[1][1] = duration_tot;
                    this.entryTable[2][0] = "Resets";
                    this.entryTable[2][1] = desmoj.core.simulator.TimeInstant.isAfter(m.resetAt(), desmoj.core.simulator.TimeOperations.getStartTime()) ? "Last reset at " + m.resetAt() + "." : "No resets during the experiment run.";
                    this.entryTable[3][0] = "Seed";
                    this.entryTable[3][1] = ('' + (this.getModel().getExperiment().getDistributionManager().getSeed()));
                    this.entryTable[4][0] = "Errors";
                    this.entryTable[4][1] = m.getExperiment().hasError() ? "Attention: At least one error or warning has occurred. See error output for details." : "No errors or warnings have occurred.";
                    return this.entryTable;
                };
                return SimulationRunReporter;
            }(desmoj.core.report.TableReporter));
            report.SimulationRunReporter = SimulationRunReporter;
            SimulationRunReporter["__class"] = "desmoj.core.report.SimulationRunReporter";
            (function (SimulationRunReporter) {
                /**
                 * An inner class providing the simulation report.
                 * @param {desmoj.core.simulator.Model} model
                 * @class
                 * @extends desmoj.core.simulator.Reportable
                 */
                var SimulationRunReporterProvider = (function (_super) {
                    __extends(SimulationRunReporterProvider, _super);
                    function SimulationRunReporterProvider(model) {
                        var _this = _super.call(this, model, "SimulationrunReportProvider", true, false) || this;
                        _this.r = null;
                        _this.r = new desmoj.core.report.SimulationRunReporter(model);
                        return _this;
                    }
                    SimulationRunReporterProvider.prototype.createDefaultReporter = function () {
                        return this.r;
                    };
                    return SimulationRunReporterProvider;
                }(desmoj.core.simulator.Reportable));
                SimulationRunReporter.SimulationRunReporterProvider = SimulationRunReporterProvider;
                SimulationRunReporterProvider["__class"] = "desmoj.core.report.SimulationRunReporter.SimulationRunReporterProvider";
            })(SimulationRunReporter = report.SimulationRunReporter || (report.SimulationRunReporter = {}));
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Constructs a model, with the given name and parameters for report and
             * trace files.
             *
             * @param {string} name
             * java.lang.String : The name of this model
             * @param {desmoj.core.simulator.Model} owner
             * Model : The main model this model is associated to
             * @param {boolean} showInTrace
             * boolean : Flag for showing this model in trace-files. Set it
             * to <code>true</code> if model should show up in trace,
             * <code>false</code> if model should not be shown in trace.
             * @param {boolean} showInReport
             * @class
             * @extends desmoj.core.simulator.Reportable
             * @author Tim Lechler
             */
            var Model = (function (_super) {
                __extends(Model, _super);
                function Model(owner, name, showInReport, showInTrace) {
                    var _this = _super.call(this, owner, name, showInReport, showInTrace) || this;
                    _this._myExperiment = null;
                    _this._entityMap = null;
                    _this.__isMainModel = false;
                    _this._numberOfEntitiesCreated = 0;
                    _this._subModels = null;
                    _this._reportables = null;
                    _this._paramManager = null;
                    _this._subModels = ([]);
                    _this._reportables = ([]);
                    if (owner != null) {
                        _this.__isMainModel = false;
                        owner.registerSubModel(_this);
                    }
                    else {
                        _this.__isMainModel = true;
                    }
                    _this._paramManager = new desmoj.core.simulator.ParameterManager();
                    _this._numberOfEntitiesCreated = 0;
                    _this._entityMap = ({});
                    return _this;
                }
                /**
                 * Checks the given modelcomponent for compatibility. Needed exclusively
                 * when submodels are present that want to share modelcomponents between
                 * them. The standard implementation only checks if the modelcomponent
                 * <code>other</code> belongs to <code>this</code> model. For use with
                 * multiple models, the user has to specify which other models are
                 * compatible to this model by overloading this method.
                 *
                 * @return {boolean} boolean : Returns <code>true</code> if the given modelcomponent
                 * is compatible to this model, <code>false</code> otherwise.
                 * @param {desmoj.core.simulator.ModelComponent} other
                 * ModelComponent : The modelcomponent that needs to be checked
                 * for compatibility to this model.
                 */
                Model.prototype.checkCompatibility = function (other) {
                    return (this === other.getModel());
                };
                /**
                 * Connects this model to an experiment. The given experiment must not
                 * already be connected to some other model. Otherwise an errormessage will
                 * be given and the experiment will be stopped. Since a model that is not
                 * yet connected has no access to the experiment's messaging subsystem,
                 * @param {desmoj.core.simulator.Experiment} exp
                 */
                Model.prototype.connectToExperiment = function (exp) {
                    if (exp == null) {
                        this.sendWarning("Can not connect to a <code>null</code> Experiment! Command ignored.", "Model : " + this.getName() + " Method: void connectToExperiment" + "(Experiment exp)", "The experiment reference passed is a null reference!", "Make sure to use valid references only.");
                        return;
                    }
                    if (!this.isMainModel()) {
                        this.sendWarning("Can not connect to Experiment " + exp.getName() + "! " + "Command ignored.", "Model : " + this.getName() + " Method: void connectToExperiment" + "(Experiment exp)", "The model to be connected is already submodel to model : " + this.getModel().getName(), "Only ,main models are allowed to be connected to an experiment");
                        return;
                    }
                    if (exp.isConnected()) {
                        this.sendWarning("Can not connect to Experiment " + exp.getName() + "! " + "Command ignored.", "Model : " + this.getName() + " Method: void connectToExperiment" + "(Experiment exp)", "The experiment to connect to is itself already connected " + "to model : " + exp.getModel(), "Only one main model can be connected to an experiment at a time.");
                        return;
                    }
                    if (this._myExperiment != null) {
                        this.sendWarning("Can not connect to Experiment " + exp.getName() + "! " + "Command ignored.", "Model : " + this.getName() + " Method: void connectToExperiment" + "(Experiment exp)", "The model is already connected to Experiment : " + this._myExperiment.getName() + "!", "A model can only be connected to just one Experiment.");
                        return;
                    }
                    this._myExperiment = exp;
                    this._myExperiment.registerModel(this);
                    if (!(this._subModels.length == 0)) {
                        for (var index789 = 0; index789 < this._subModels.length; index789++) {
                            var m = this._subModels[index789];
                            {
                                m.setConnectedExperiment(exp);
                            }
                        }
                    }
                    this.init();
                    this.doSubmodelInit();
                    this.reset();
                };
                /**
                 * Creates the default reporter associated with this model. The default
                 * reporter returned by this method just prints the model's description as
                 * implemented in method <code>description()</code> and appends the
                 * simulation time of the last reset. If the user's model offers more
                 * information, create a special class derived from class
                 * <code>desmoj.report.ModelReporter</code> to extract and present that
                 * extra information.
                 *
                 * @return {desmoj.core.report.ModelReporter} Reportable : The reporter associated with this model
                 */
                Model.prototype.createDefaultReporter = function () {
                    return new desmoj.core.report.ModelReporter(this);
                };
                /**
                 * Calls the <code>init()</code> method of all registered
                 * submodels of the current model. Subsequently calls the
                 * <code>init()</code> method of all registered submodels
                 * of every submodel.
                 */
                Model.prototype.doSubmodelInit = function () {
                    if (!this.hasSubModels())
                        return;
                    else {
                        for (var index790 = 0; index790 < this._subModels.length; index790++) {
                            var m = this._subModels[index790];
                            {
                                m.init();
                                m.doSubmodelInit();
                            }
                        }
                    }
                };
                /**
                 * Calls the <code>doInitialSchedules()</code> method of all registered
                 * submodels of the current model. Subsequently calls the
                 * <code>doSubmodelSchedules()</code> method of all registered submodels
                 * of every submodel.
                 */
                Model.prototype.doSubmodelSchedules = function () {
                    if (!this.hasSubModels())
                        return;
                    else {
                        for (var index791 = 0; index791 < this._subModels.length; index791++) {
                            var m = this._subModels[index791];
                            {
                                m.doInitialSchedules();
                                m.doSubmodelSchedules();
                            }
                        }
                    }
                };
                /**
                 * Returns the entity to the belonging identifier.
                 * @return {desmoj.core.simulator.Entity} Entity : The class will return the
                 * <code>Entity</code> or null if no such exists.
                 * @param {number} ident
                 */
                Model.prototype.getEntity = function (ident) {
                    return (function (m, k) { if (m.entries == null)
                        m.entries = []; for (var i = 0; i < m.entries.length; i++)
                        if (m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) {
                            return m.entries[i].value;
                        } return null; })(this._entityMap, ident);
                };
                /**
                 * Returns a list of this model's entities. The order of the list is unspecified.
                 *
                 * @param {boolean} includeSubmodels
                 * boolean : Do include (true) or exclude (false) submodels' entities in the list.
                 *
                 * @return {desmoj.core.simulator.Entity[]} List<Entity> : The class will return a list of all existing objects of
                 * <code>Entity</code>.
                 */
                Model.prototype.getEntities = function (includeSubmodels) {
                    var list = ([]);
                    /* addAll */ (function (l1, l2) { return l1.push.apply(l1, l2); })(list, /* values */ (function (m) { var r = []; if (m.entries == null)
                        m.entries = []; for (var i = 0; i < m.entries.length; i++)
                        r.push(m.entries[i].value); return r; })(this._entityMap));
                    if (includeSubmodels) {
                        for (var index792 = 0; index792 < this._subModels.length; index792++) {
                            var submodel = this._subModels[index792];
                            {
                                /* addAll */ (function (l1, l2) { return l1.push.apply(l1, l2); })(list, submodel.getEntities(true));
                            }
                        }
                    }
                    return list;
                };
                /**
                 * Returns the experiment that is connected to this model or
                 * <code>null</code> if the model is not yet connected to an experiment.
                 *
                 * @return {desmoj.core.simulator.Experiment} Experiment : The experiment that this model is connected to or
                 * <code>null</code> if no connection is established
                 */
                Model.prototype.getExperiment = function () {
                    if (this.isMainModel()) {
                        return this._myExperiment;
                    }
                    else {
                        return this.getModel().getExperiment();
                    }
                };
                /**
                 * Returns a copy of the dynamic list containing all reportable
                 * components of this model.
                 *
                 * @return {desmoj.core.simulator.Reportable[]} reportables : A list containing all reportable
                 * components of this model.
                 */
                Model.prototype.getReportables = function () {
                    return (this._reportables.slice(0));
                };
                /**
                 * Returns the Model's viewpoint of the ParameterManager
                 *
                 * @return {*} ModelParameterManager : The ParameterManager
                 */
                Model.prototype.getParameterManager = function () {
                    return this._paramManager;
                };
                /**
                 * Shows, if there are submodels registered with this model.
                 *
                 * @return {boolean} boolean : True, if there is at least one submodel registered at
                 * this Model, flase if there are no submodels
                 */
                Model.prototype.hasSubModels = function () {
                    return !(this._subModels.length == 0);
                };
                Model.prototype.init$ = function () { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                Model.prototype.init$desmoj_core_simulator_ModelOptions = function (options) {
                    this.init();
                    options.setOptions(this);
                };
                /**
                 * Initializes the model by calling method <code>init()</code> to set up
                 * all model related components as specified in that method. After
                 * initializing the model, the given ModelOption's <code>setOption()</code>
                 * method is called with this model as parameter. This enables the user to
                 * specify different model parameter settings for different experiments. It
                 * even allows automated parameter variation to give a small but handy aid
                 * for model optimization. Implement the ModelOptions to set the parameters
                 * for your model. Make sure to react properly on the ModelOptions given.
                 * Note that specifiying ModelOptions is up to the user.
                 *
                 * @param {*} options
                 * ModelOptions : The parameter settings for this model
                 */
                Model.prototype.init = function (options) {
                    if (((options != null && (options["__interfaces"] != null && options["__interfaces"].indexOf("desmoj.core.simulator.ModelOptions") >= 0 || options.constructor != null && options.constructor["__interfaces"] != null && options.constructor["__interfaces"].indexOf("desmoj.core.simulator.ModelOptions") >= 0)) || options === null)) {
                        return this.init$desmoj_core_simulator_ModelOptions(options);
                    }
                    else if (options === undefined) {
                        return this.init$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Shows if this model has already been connected to an experiment.
                 *
                 * @return {boolean} boolean : Is <code>true</code>, if model is connected to an
                 * experiment, <code>false</code> otherwise
                 */
                Model.prototype.isConnected = function () {
                    return (this._myExperiment != null);
                };
                /**
                 * Shows if this model is a main model and thus is not submodel of other
                 * models.
                 *
                 * @return {boolean} boolean : Returns <code>true</code> if the model is a main
                 * model, <code>false</code> if it is a submodel of other models
                 */
                Model.prototype.isMainModel = function () {
                    return this.__isMainModel;
                };
                /**
                 * Shows if this model is submodel to another model and thus is not the main
                 * models.
                 *
                 * @return {boolean} boolean : Returns <code>true</code> if the model is a submodel
                 * of other models, <code>false</code> if it is a main model
                 */
                Model.prototype.isSubModel = function () {
                    return !this.__isMainModel;
                };
                /**
                 * Links an entity with an unique identification number.
                 *
                 * @param {desmoj.core.simulator.Entity} e
                 * Entity : The new Entity to link with an unique identification number.
                 *
                 * @return {number} long : Unique identification number.
                 */
                Model.prototype.linkWithIdentNumber = function (e) {
                    this._numberOfEntitiesCreated++;
                    /* put */ (function (m, k, v) { if (m.entries == null)
                        m.entries = []; for (var i = 0; i < m.entries.length; i++)
                        if (m.entries[i].key.equals != null && m.entries[i].key.equals(k) || m.entries[i].key === k) {
                            m.entries[i].value = v;
                            return;
                        } m.entries.push({ key: k, value: v, getKey: function () { return this.key; }, getValue: function () { return this.value; } }); })(this._entityMap, this._numberOfEntitiesCreated, e);
                    return this._numberOfEntitiesCreated;
                };
                /**
                 * Registers a reportable at this model. Reports can only be drawn, if the
                 * reportbale is registered at his model.
                 *
                 * @param {desmoj.core.simulator.Reportable} r
                 * desmoj.core.simulator.Reportable : The reportable to be registered
                 */
                Model.prototype.register = function (r) {
                    if (r == null)
                        return;
                    else
                        (this._reportables.push(r) > 0);
                };
                /**
                 * Registers another model as submodel of this model.
                 *
                 * @param {desmoj.core.simulator.Model} subModel
                 * Model : The model to be registerd as a submodel
                 */
                Model.prototype.registerSubModel = function (subModel) {
                    if (subModel == null) {
                        this.sendWarning("Can\'t register Submodel!", "Model : " + this.getName() + " Method: registerSubModel(Model " + "subModel)", "The SubModel given as parameter is a null reference.", "Be sure to have a valid SubModel reference before calling this method.");
                        return;
                    }
                    /* add */ (this._subModels.push(subModel) > 0);
                };
                /**
                 * Produces a report about the model and all its related modelcomponents and
                 * submodels. It registers the model's reporter and all other reporters at
                 * the experiment's reportmanager to produce the report output. The
                 * reporters are ordered into the reportmanager returned with this model's
                 * reporter first, followed by all reportable's reporters. After this
                 * section, all submodel's reporters are inserted according to the order
                 * they were attached to this model. Each submodel's section is sorted using
                 * the criteria above. Thus all reporters a re separated by model to prevent
                 * confusion.
                 *
                 * @return {desmoj.core.report.Reporter[]} Enumeration : The Enumeration carrying all reporters available
                 * from this model
                 */
                Model.prototype.report = function () {
                    var repMan = new desmoj.core.report.ReportManager(this.getName() + "_ReportManager");
                    repMan.register(this.createDefaultReporter());
                    for (var index793 = 0; index793 < this._reportables.length; index793++) {
                        var r = this._reportables[index793];
                        {
                            if (r.reportIsOn())
                                repMan.register(r.getReporter());
                        }
                    }
                    var subReporters;
                    for (var index794 = 0; index794 < this._subModels.length; index794++) {
                        var m = this._subModels[index794];
                        {
                            subReporters = m.report();
                            for (var index795 = 0; index795 < subReporters.length; index795++) {
                                var r = subReporters[index795];
                                {
                                    repMan.addLast(r);
                                }
                            }
                        }
                    }
                    return repMan.elements();
                };
                Model.prototype.reset = function (newSeed) {
                    if (newSeed === undefined) {
                        return this.reset$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                Model.prototype.reset$ = function () {
                    _super.prototype.reset.call(this);
                    if ((this._reportables.length == 0))
                        return;
                    else {
                        for (var index796 = 0; index796 < this._reportables.length; index796++) {
                            var r = this._reportables[index796];
                            {
                                r.reset();
                            }
                        }
                    }
                    if ((this._subModels.length == 0))
                        return;
                    else {
                        for (var index797 = 0; index797 < this._subModels.length; index797++) {
                            var m = this._subModels[index797];
                            {
                                m.reset();
                            }
                        }
                    }
                };
                /**
                 * Connects submodels to the experiment given. This method is called by the
                 * main model, when submodels register themselves at the main model.
                 *
                 * @param {desmoj.core.simulator.Experiment} e
                 * desmoj.Experiment : The experiment to connect this model to
                 */
                Model.prototype.setConnectedExperiment = function (e) {
                    if (e == null) {
                        this.sendWarning("Can not connect to experiment! Command ignored.", "Model : " + this.getName() + " Method: " + "void setConnectedExperiment (Experiment e)", "The given Esperiment parameter contained a null reference", "Be sure to always give valid parameters.");
                        return;
                    }
                    if (this.isSubModel()) {
                        this._myExperiment = e;
                        return;
                    }
                    else {
                        this.sendWarning("Can not connect to experiment! Command ignored.", "Model : " + this.getName() + " Method: void " + "method setConnectedExperiment" + "(Experiment e)", "This model is not a submodel.", "Only submodels can be connected to an experiment using this method.");
                        return;
                    }
                };
                /**
                 * Sets the current model to be the main model by setting the
                 * <code>owner</code> reference to itself.
                 */
                Model.prototype.setMain = function () {
                    this.setOwner(this);
                };
                return Model;
            }(desmoj.core.simulator.Reportable));
            simulator.Model = Model;
            Model["__class"] = "desmoj.core.simulator.Model";
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Creates a QueueBased object and initializes all statistical counters. If this standard constructor is used a queue with Fifo sort order and no
             * limited capacity will be created.
             *
             * @param {desmoj.core.simulator.Model} owner
             * desmoj.Model : The model it belongs to
             * @param {string} name
             * java.lang.String : The name for this QueueBased object
             * @param {boolean} showInReport
             * boolean : Flag if values are shown in report
             * @param {boolean} showInTrace
             * boolean : Flag if QueueBased writes trace messages
             * @class
             * @extends desmoj.core.simulator.Reportable
             * @author Tim Lechler
             */
            var QueueBased = (function (_super) {
                __extends(QueueBased, _super);
                function QueueBased(owner, name, showInReport, showInTrace) {
                    var _this = _super.call(this, owner, name, showInReport, showInTrace) || this;
                    /**
                     * intern Reference to the administration code
                     */
                    /*private*/ _this.subjectAdministration = (new desmoj.core.observer.SubjectAdministration());
                    /**
                     * Represents the maximum number of entities in the queue (default is unlimited capacity).
                     */
                    _this.queueLimit = Number.MAX_VALUE;
                    _this._currentLength = 0;
                    _this._qImpWarnings = false;
                    _this._minimumLength = 0;
                    _this._maximumLength = 0;
                    _this._zeros = 0;
                    _this._wSumLength = 0;
                    _this._wSumSquareLength = 0;
                    _this._lastAcc = null;
                    _this._minimumLengthAt = null;
                    _this._maximumLengthAt = null;
                    _this._maximumWaitTime = null;
                    _this._maximumWaitTimeAt = null;
                    _this._sumWaitTime = null;
                    _this._sumSquareWaitTime = 0;
                    _this._currentLength = 0;
                    _this._lastAcc = _this.presentTime();
                    _this._minimumLength = _this._currentLength;
                    _this._maximumLength = _this._currentLength;
                    _this._zeros = 0;
                    _this._wSumSquareLength = _this._wSumLength = _this._sumSquareWaitTime = 0.0;
                    _this._sumWaitTime = _this._maximumWaitTime = new desmoj.core.simulator.TimeSpan(0);
                    _this._maximumWaitTimeAt = _this._minimumLengthAt = _this._maximumLengthAt = _this.presentTime();
                    _this._qImpWarnings = false;
                    return _this;
                }
                /**
                 * Updates the statistics when a new element is inserted into the underlying queue. Note that this method must always be called whenever an
                 * insertion is made. If class <code>QueueList</code> is used in combination with a QueueBased, this method gets called automatically whenever a
                 * new Entity is inserted.
                 *
                 * @see QueueList
                 * @see QueueListFifo
                 * @see QueueListLifo
                 */
                QueueBased.prototype.addItem = function () {
                    this.updateStatistics();
                    this._currentLength++;
                    if (this._currentLength > this._maximumLength) {
                        this._maximumLength = this._currentLength;
                        this._maximumLengthAt = this.presentTime();
                    }
                    this.notifyObservers$desmoj_core_simulator_QueueBased$desmoj_core_simulator_QueueBased_QueueAction(this, desmoj.core.simulator.QueueBased.QueueAction.ITEM_ADDED);
                };
                QueueBased.prototype.addObserver = function (observer) {
                    this.subjectAdministration.addObserver(observer);
                };
                /**
                 * Returns the average length of the underlying queue since the last reset. Current length of that queue will be returned, if the time span since
                 * the last reset is smaller than the smallest distinguishable timespan epsilon.
                 *
                 * @return {number} double : The average queue length since last reset or current length of queue if no distinguishable periode of time has passed
                 */
                QueueBased.prototype.averageLength = function () {
                    var now = this.presentTime();
                    var deltaTime = desmoj.core.simulator.TimeOperations.diff$desmoj_core_simulator_TimeInstant$desmoj_core_simulator_TimeInstant(now, this.resetAt());
                    if (desmoj.core.simulator.TimeSpan.isShorter(deltaTime, desmoj.core.simulator.TimeOperations.getEpsilonSpan())) {
                        return this._currentLength;
                    }
                    var avgLength = (this._wSumLength + (this._currentLength * desmoj.core.simulator.TimeOperations.diff$desmoj_core_simulator_TimeInstant$desmoj_core_simulator_TimeInstant(now, this._lastAcc).getTimeInEpsilon())) / deltaTime.getTimeInEpsilon();
                    var rndAvgLength = desmoj.core.statistic.StatisticObject.round(avgLength);
                    return rndAvgLength;
                };
                /**
                 * Returns the average waiting time of all objects who have exited the queue. Value is valid for the time span since the last reset. Returns 0
                 * (zero) if no objects have exited the queue after the last reset.
                 *
                 * @return {desmoj.core.simulator.TimeSpan} TimeSpan : Average waiting time of all objects since last reset or 0 if no objects have exited the queue
                 */
                QueueBased.prototype.averageWaitTime = function () {
                    var obs = this.getObservations();
                    if (obs > 0) {
                        var avgWaitTime = desmoj.core.simulator.TimeOperations.divide$desmoj_core_simulator_TimeSpan$double(this._sumWaitTime, obs);
                        return avgWaitTime;
                    }
                    else {
                        return new desmoj.core.simulator.TimeSpan(0);
                    }
                };
                /**
                 * Updates the statistics when a new element is exiting the underlying queue. Note that this method must always be called whenever an object is
                 * taken from the queue. The simulation time parameter given provides the statistics with the information about the point of time the exiting
                 * object had enterd this queue. This is needed to calculate the waiting times. If a QueueBased is used in conjunction with class queuelist, this
                 * method is automatically called whenever an entity is taken from the queuelist to keep track of
                 *
                 * @param {desmoj.core.simulator.TimeInstant} entryTime
                 * TimeInstant : Point of simulation time that the object now exiting the QueueBased had entered it
                 */
                QueueBased.prototype.deleteItem = function (entryTime) {
                    this.updateStatistics();
                    var now = this.presentTime();
                    var waitTime = desmoj.core.simulator.TimeOperations.diff$desmoj_core_simulator_TimeInstant$desmoj_core_simulator_TimeInstant(now, entryTime);
                    this._sumWaitTime = desmoj.core.simulator.TimeOperations.add$desmoj_core_simulator_TimeSpan$desmoj_core_simulator_TimeSpan(this._sumWaitTime, waitTime);
                    this._sumSquareWaitTime += waitTime.getTimeInEpsilon() * waitTime.getTimeInEpsilon();
                    if (desmoj.core.simulator.TimeSpan.isLonger(waitTime, this._maximumWaitTime)) {
                        this._maximumWaitTime = waitTime;
                        this._maximumWaitTimeAt = now;
                    }
                    if (desmoj.core.simulator.TimeSpan.isEqual(waitTime, new desmoj.core.simulator.TimeSpan(0))) {
                        this._zeros++;
                    }
                    if (this._currentLength <= 0) {
                        this.sendWarning("Inconsistent Qeueue length", "QueueBased : " + this.getName() + " Method: void activateAfter(TimeSpan dt)", "Error in Statistic operations of Queues", "Report information to DESMO-J designer Tim Lechler via eMail : 1lechler@informatik.uni-hamburg.de");
                        return;
                    }
                    this._currentLength--;
                    if (this._currentLength < this._minimumLength) {
                        this._minimumLength = this._currentLength;
                    }
                    this.incrementObservations();
                    this.notifyObservers$desmoj_core_simulator_QueueBased$desmoj_core_simulator_QueueBased_QueueAction(this, desmoj.core.simulator.QueueBased.QueueAction.ITEM_DELETED);
                };
                QueueBased.prototype.deleteObserver = function (observer) {
                    this.subjectAdministration.deleteObserver(observer);
                };
                /**
                 * Returns the maximum possible number of entities in the underlying queue.
                 *
                 * @return {number} int : the maximum number of entities in the queue.
                 */
                QueueBased.prototype.getQueueLimit = function () {
                    return this.queueLimit;
                };
                /**
                 * Returns the current length of the underlying queue.
                 *
                 * @return {number} int : The current queue length, zero if empty.
                 */
                QueueBased.prototype.length = function () {
                    return this._currentLength;
                };
                /**
                 * Returns the maximum length of the underlying queue since the last reset.
                 *
                 * @return {number} int : The maximum queue length since last reset
                 */
                QueueBased.prototype.maxLength = function () {
                    return this._maximumLength;
                };
                /**
                 * Returns the point of simulation time with the maximum number of objects waiting inside the underlying queue. The value is valid for the period
                 * since the last reset.
                 *
                 * @return {desmoj.core.simulator.TimeInstant} desmoj.TimeInstant : Point of time with maximum queue length since last reset
                 */
                QueueBased.prototype.maxLengthAt = function () {
                    return this._maximumLengthAt;
                };
                /**
                 * Returns the maximum duration in simulation time that an object has spent waiting inside the underlying queue. The value is valid for the period
                 * since the last reset.
                 *
                 * @return {desmoj.core.simulator.TimeSpan} desmoj.TimeSpan : Longest waiting time of an object in the queue since last reset
                 */
                QueueBased.prototype.maxWaitTime = function () {
                    return this._maximumWaitTime;
                };
                /**
                 * Returns the point of simulation time when the object with the maximum waiting time exited the underlying queue. The value is valid for the
                 * period since the last reset.
                 *
                 * @return {desmoj.core.simulator.TimeInstant} desmoj.TimeInstant : The point of simulation time when the object with the maximum waiting time exited the queue
                 */
                QueueBased.prototype.maxWaitTimeAt = function () {
                    return this._maximumWaitTimeAt;
                };
                /**
                 * Returns the minimumn length of the underlying queue since the last reset.
                 *
                 * @return {number} int : The minimum queue length since last reset
                 */
                QueueBased.prototype.minLength = function () {
                    return this._minimumLength;
                };
                /**
                 * Returns the point of simulation time with the minimum number of objects waiting inside the underlying queue. The value is valid for the period
                 * since the last reset.
                 *
                 * @return {desmoj.core.simulator.TimeInstant} desmoj.TimeInstant : Point of time with minimum queue length since last reset
                 */
                QueueBased.prototype.minLengthAt = function () {
                    return this._minimumLengthAt;
                };
                QueueBased.prototype.notifyObservers$desmoj_core_simulator_QueueBased$desmoj_core_simulator_QueueBased_QueueAction = function (subject, eventObject) {
                    this.subjectAdministration.notifyObservers(subject, eventObject);
                };
                QueueBased.prototype.notifyObservers = function (subject, eventObject) {
                    if (((subject != null && subject instanceof desmoj.core.simulator.QueueBased) || subject === null) && ((typeof eventObject === 'number') || eventObject === null)) {
                        return this.notifyObservers$desmoj_core_simulator_QueueBased$desmoj_core_simulator_QueueBased_QueueAction(subject, eventObject);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns a boolean flag telling if the underlying queue implementation should issue own warnings or not. The warnings from the queue
                 * implementation (<code>QueueList</code>) are needed for debugging purposes.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if the underlying queue implementation should issue warnings, <code>false</code> otherwise
                 */
                QueueBased.prototype.qImpWarn = function () {
                    return this._qImpWarnings;
                };
                QueueBased.prototype.reset = function (newSeed) {
                    if (newSeed === undefined) {
                        return this.reset$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                QueueBased.prototype.reset$ = function () {
                    _super.prototype.reset.call(this);
                    this._lastAcc = this.presentTime();
                    this._minimumLength = this._currentLength;
                    this._maximumLength = this._currentLength;
                    this._zeros = 0;
                    this._wSumLength = this._wSumSquareLength = this._sumSquareWaitTime = 0.0;
                    this._sumWaitTime = this._maximumWaitTime = new desmoj.core.simulator.TimeSpan(0);
                    this._maximumWaitTimeAt = this._minimumLengthAt = this._maximumLengthAt = this.presentTime();
                };
                /**
                 * Method switches on warnings issued from the underlying queue implementation if parameter given is <code>true</code>. Warnings are suppressed if
                 * <code>false</code> is given. This method is used for internal debugging only.
                 *
                 * @param {boolean} warnFlag
                 * boolean :<code>true</code> switches warnings on, <code>false</code> switches warnings off
                 */
                QueueBased.prototype.setQueueImpWarning = function (warnFlag) {
                    this._qImpWarnings = warnFlag;
                };
                /**
                 * Returns the standard deviation of the queue's length. Value is weighted over time.
                 *
                 * @return {number} double : The standard deviation for the queue's length weighted over time
                 */
                QueueBased.prototype.stdDevLength = function () {
                    var now = this.presentTime();
                    var deltaTime = desmoj.core.simulator.TimeOperations.diff$desmoj_core_simulator_TimeInstant$desmoj_core_simulator_TimeInstant(now, this.resetAt());
                    if (desmoj.core.simulator.TimeSpan.isShorter(deltaTime, desmoj.core.simulator.TimeOperations.getEpsilonSpan())) {
                        return QueueBased.UNDEFINED;
                    }
                    else {
                        var len = this._currentLength;
                        var mean = this.averageLength();
                        var spanSinceLastAcess = desmoj.core.simulator.TimeOperations.diff$desmoj_core_simulator_TimeInstant$desmoj_core_simulator_TimeInstant(now, this._lastAcc);
                        return Math.sqrt(Math.abs((this._wSumSquareLength + (len * len * spanSinceLastAcess.getTimeInEpsilon())) / deltaTime.getTimeInEpsilon() - (mean * mean)));
                    }
                };
                /**
                 * Returns the standard deviation of the queue's objects waiting times.
                 *
                 * @return {desmoj.core.simulator.TimeSpan} double : The standard deviation for the queue's objects waiting times
                 */
                QueueBased.prototype.stdDevWaitTime = function () {
                    if (this.getObservations() > 0) {
                        var mean = this.averageWaitTime().getTimeInEpsilon();
                        var obs = this.getObservations();
                        return new desmoj.core.simulator.TimeSpan(Math.sqrt(Math.abs(((obs * this._sumSquareWaitTime) - (mean * mean)) / (obs * (obs - 1.0)))), desmoj.core.simulator.TimeOperations.getEpsilon());
                    }
                    else {
                        return new desmoj.core.simulator.TimeSpan(0);
                    }
                };
                /**
                 * Updates the parts of the statistics used by both addItem and deleteItem.
                 */
                QueueBased.prototype.updateStatistics = function () {
                    var now = this.presentTime();
                    var deltaTime = desmoj.core.simulator.TimeOperations.diff$desmoj_core_simulator_TimeInstant$desmoj_core_simulator_TimeInstant(now, this._lastAcc);
                    this._wSumLength += this._currentLength * deltaTime.getTimeInEpsilon();
                    this._wSumSquareLength += this._currentLength * this._currentLength * deltaTime.getTimeInEpsilon();
                    this._lastAcc = now;
                };
                /**
                 * Returns the number of objects that have passed through the queue without spending time waiting.
                 *
                 * @return {number} long : The number of elements who have passed the queue without waiting
                 */
                QueueBased.prototype.zeroWaits = function () {
                    return this._zeros;
                };
                return QueueBased;
            }(desmoj.core.simulator.Reportable));
            /**
             * Represents the value returned if for a given statistics no valid value can be returned.
             */
            QueueBased.UNDEFINED = -1;
            /**
             * Defining a constant for the FIFO (First In First Out) service discipline of the underlying queue: An Entity inserted into the queue is removed
             * after all entities already enqueued with the same priority.
             */
            QueueBased.FIFO = 0;
            /**
             * Defining a constant for the LIFO (Last In First Out) service discipline of the underlying queue: An Entity inserted into the queue is removed
             * before all entities already enqueued with the same priority.
             */
            QueueBased.LIFO = 1;
            /**
             * Defining a constant for the random service discipline of the underlying queue: An Entity inserted into the queue may be removed before or after
             * any other Entity with the same priority.
             */
            QueueBased.RANDOM = 2;
            simulator.QueueBased = QueueBased;
            QueueBased["__class"] = "desmoj.core.simulator.QueueBased";
            QueueBased["__interfaces"] = ["desmoj.core.observer.Subject"];
            (function (QueueBased) {
                /**
                 *
                 * Enum to representing the actions of adding and removing an item to/from the queue. This enum is usesed
                 *
                 * @author Malte Unkrig
                 *
                 * @enum
                 * @property {desmoj.core.simulator.QueueBased.QueueAction} ITEM_ADDED
                 * @property {desmoj.core.simulator.QueueBased.QueueAction} ITEM_DELETED
                 * @class
                 */
                var QueueAction;
                (function (QueueAction) {
                    QueueAction[QueueAction["ITEM_ADDED"] = 0] = "ITEM_ADDED";
                    QueueAction[QueueAction["ITEM_DELETED"] = 1] = "ITEM_DELETED";
                })(QueueAction = QueueBased.QueueAction || (QueueBased.QueueAction = {}));
            })(QueueBased = simulator.QueueBased || (simulator.QueueBased = {}));
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Constructs a Schedulable object with the given name. Note that to
             * identify the multiple objects that can be created of one type of
             * Schedulable, each has a unique number added to its name as a suffix. The
             * numbers represent the amount of objects being created with the same name.
             *
             * @param {string} name
             * java.lang.String : The name of the new Schedulable object
             * @param {desmoj.core.simulator.Model} owner
             * Model : The owner of this Schedulable object
             * @param {boolean} showInTrace
             * @class
             * @extends desmoj.core.simulator.ModelComponent
             * @author Tim Lechler
             */
            var Schedulable = (function (_super) {
                __extends(Schedulable, _super);
                function Schedulable(owner, name, showInTrace) {
                    var _this = _super.call(this, owner, owner.getExperiment().getNameCatalog().registeredName(name), showInTrace) || this;
                    /**
                     * Reportable (e.g. entity) corresponding to this Schedulable
                     * maybe null if no Reportable corresponds to this Schedulable
                     */
                    /*private*/ _this._correspondingReportable = null;
                    _this._schedule = null;
                    _this._schedule = ([]);
                    return _this;
                }
                /**
                 * Removes all events scheduled for this entity from the event-list.
                 * The Entity will not become active until scheduled again.
                 */
                Schedulable.prototype.cancel = function () {
                    if (!this.isScheduled()) {
                        this.sendWarning("Can\'t cancel Schedulable! Command ignored.", "Schedulable : " + this.getName() + " Method: void cancel()", "The Schedulable to be canceled is not scheduled.", "Use method isSchedule() to test if the Schedulable is scheduled and thus can be canceled or not.");
                        return;
                    }
                    while ((!(this._schedule.length == 0))) {
                        var firstNote = this._schedule[0];
                        if (this.currentlySendTraceNotes()) {
                            var time = firstNote.getTime();
                            if (this === this.current()) {
                                if (time === this.presentTime())
                                    this.sendTraceNote("cancels scheduled Event " + firstNote.getEvent() + " for itself, which was scheduled now");
                                else
                                    this.sendTraceNote("cancels scheduled Event " + firstNote.getEvent() + " for itself, which was scheduled at " + time);
                            }
                            else {
                                if (time === this.presentTime())
                                    this.sendTraceNote("cancels scheduled Event " + firstNote.getEvent() + " for " + this.getName() + ", which was scheduled now");
                                else
                                    this.sendTraceNote("cancels scheduled Event " + firstNote.getEvent() + " for " + this.getName() + ", which was scheduled at " + time);
                            }
                        }
                        this.getModel().getExperiment().getScheduler().evList.remove(firstNote);
                    }
                    ;
                };
                /**
                 * Returns a list of EventNote associated to this Entity object. If the
                 * Entity object is not currently scheduled, <code>null</code> will be
                 * returned. Remind that all different Event classes can be included.
                 *
                 * @return {desmoj.core.simulator.EventNote[]} List<EventNote> : The event-notes associated to the entity or
                 * <code>null</code> if Entity is not currently scheduled
                 */
                Schedulable.prototype.getEventNotes = function () {
                    return this._schedule;
                };
                /**
                 * Shows if this Schedulable is the currently active object.
                 *
                 * @return {boolean} boolean :<code>true</code> if this Schedulable is the currently
                 * active, <code>false</code> otherwise
                 */
                Schedulable.prototype.isCurrent = function () {
                    return (function (o1, o2) { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(this, this.getModel().getExperiment().getScheduler().getCurrentSchedulable());
                };
                /**
                 * Tests if this entity has already been scheduled.
                 *
                 * @return {boolean} boolean :<code>true</code> if already scheduled,
                 * <code>false</code> otherwise
                 */
                Schedulable.prototype.isScheduled = function () {
                    return (!(this._schedule.length == 0));
                };
                /**
                 * Removes an event-note from the internal list
                 *
                 * * @param note
                 * EventNote : The <code>EventNote to be removed</code>
                 * @param {desmoj.core.simulator.EventNote} note
                 */
                Schedulable.prototype.removeEventNote = function (note) {
                    /* remove */ (function (a) { return a.splice(a.indexOf(note), 1); })(this._schedule);
                };
                /**
                 * Allows to rename a Schedulable object while keeping its internally added
                 * serial number to keep track of the individual object. Note that invalid
                 * string parameters will result in renaming the Schedulable to 'unnamed'.
                 *
                 * @param {string} newName
                 * java.lang.String : The Schedulable's new name
                 */
                Schedulable.prototype.rename = function (newName) {
                    _super.prototype.rename.call(this, this.getModel().getExperiment().getNameCatalog().registeredName(newName));
                };
                Schedulable.prototype.reSchedule$desmoj_core_simulator_TimeSpan = function (dt) {
                    if (dt == null) {
                        this.sendWarning("Can\'t reSchedule Schedulable! Command ingnored.", "Schedulable : " + this.getName() + " Method: reSchedule(TimeSpan dt)", "The simulation time given as parameter is a null reference.", "Be sure to have a valid TimeSpan reference before calling this method.");
                        return;
                    }
                    if (!this.isScheduled()) {
                        this.sendWarning("Can\'t reSchedule Schedulable! Command ingnored.", "Schedulable : " + this.getName() + " Method: reSchedule(TimeSpan dt)", "The Schedulable is not scheduled, thus unable to be reScheduled..", "Be sure that the Schedulable is currently scheduled before calling this method.");
                        return;
                    }
                    var newNote = null;
                    var oldNotes = (this._schedule.slice(0));
                    var newNotes = ([]);
                    for (var index798 = 0; index798 < oldNotes.length; index798++) {
                        var oldNote = oldNotes[index798];
                        {
                            newNote = oldNote.copy(this.current());
                            newNote.setTime(desmoj.core.simulator.TimeOperations.add$desmoj_core_simulator_TimeInstant$desmoj_core_simulator_TimeSpan(oldNote.getTime(), dt));
                            /* add */ (newNotes.push(newNote) > 0);
                            this.getModel().getExperiment().getScheduler().evList.remove(oldNote);
                            if (this.currentlySendTraceNotes()) {
                                var timeOld = oldNote.getTime();
                                var timeNew = newNote.getTime();
                                if (this === this.current()) {
                                    if (timeOld === this.presentTime())
                                        this.sendTraceNote("reschedules " + newNote.getEvent() + " for itself, which was scheduled now, to " + timeNew);
                                    else
                                        this.sendTraceNote("reschedules " + newNote.getEvent() + " for itself, which was scheduled at " + timeOld + ", to " + timeNew);
                                }
                                else {
                                    if (timeOld === this.presentTime())
                                        this.sendTraceNote("reschedules " + newNote.getEvent() + " for " + this.getName() + ", which was scheduled now, to " + timeNew);
                                    else
                                        this.sendTraceNote("reschedules " + newNote.getEvent() + " for " + this.getName() + ", which was scheduled at " + timeOld + ", to " + timeNew);
                                }
                            }
                        }
                    }
                    for (var index799 = 0; index799 < newNotes.length; index799++) {
                        var ev = newNotes[index799];
                        {
                            this.getModel().getExperiment().getScheduler().evList.insert(ev);
                        }
                    }
                };
                /**
                 * Re-schedules the Schedulable by shifting all EventNote by a specified <code>
                 * TimeSpan</code>.
                 *
                 * @param {desmoj.core.simulator.TimeSpan} dt
                 * TimeSpan : The offset to the current simulation time at which
                 * this Schedulable is to be re-scheduled
                 */
                Schedulable.prototype.reSchedule = function (dt) {
                    if (((dt != null && dt instanceof desmoj.core.simulator.TimeSpan) || dt === null)) {
                        return this.reSchedule$desmoj_core_simulator_TimeSpan(dt);
                    }
                    else if (((dt != null && dt instanceof desmoj.core.simulator.TimeInstant) || dt === null)) {
                        return this.reSchedule$desmoj_core_simulator_TimeInstant(dt);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Schedulable.prototype.reSchedule$desmoj_core_simulator_TimeInstant = function (time) {
                    if (time == null) {
                        this.sendWarning("Can\'t reSchedule enitty! Command ingnored.", "Entity : " + this.getName() + " Method: reSchedule(TimeInstant time)", "The simulation time given as parameter is a null reference.", "Be sure to have a valid TimeSpan reference before calling this method.");
                        return;
                    }
                    if (!this.isScheduled()) {
                        this.sendWarning("Can\'t reSchedule Schedulable! Command ingnored.", "Entity : " + this.getName() + " Method: reSchedule(TimeInstant time)", "The Entity is not scheduled, thus unable to be reScheduled.", "Be sure that the entity is currently scheduled before calling this method.");
                        return;
                    }
                    if (this._schedule.length > 1) {
                        this.sendWarning("Can\'t reSchedule Entity! Command ingnored.", "Entity : " + this.getName() + " Method: reSchedule(TimeInstant time)", "The Entity is scheduled more then once, thus unable to be reScheduled.", "Be sure that the entity is only scheduled oncebefore calling this method.");
                        return;
                    }
                    if (desmoj.core.simulator.TimeInstant.isBefore(time, this.presentTime())) {
                        this.sendWarning("Can\'t reschedule Entity at given time! Command ignored.", "Entity : " + this.getName() + " Method: reSchedule(TimeInstant time)", "The instant given is in the past.", "To reschedule an entity, use a TimeInstant no earlier than the present time. The present time can be obtained using the presentTime() method");
                        return;
                    }
                    if (this.currentlySendTraceNotes()) {
                        if (this === this.current()) {
                            if (time === this.presentTime())
                                this.sendTraceNote("reschedules itself now");
                            else
                                this.sendTraceNote("reschedules itself at " + time);
                        }
                        else {
                            if (time === this.presentTime())
                                this.sendTraceNote("reschedules \'" + this.getName() + "\' now");
                            else
                                this.sendTraceNote("reschedules \'" + this.getName() + "\' at " + time);
                        }
                    }
                    this.getModel().getExperiment().getScheduler().reScheduleNoPreempt$desmoj_core_simulator_Schedulable$desmoj_core_simulator_TimeInstant(this, time);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("reschedules on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                /**
                 * Returns the next point of time this entity is scheduled.
                 *
                 * @return {desmoj.core.simulator.TimeInstant} TimeInstant : The point of simulation time the next Entity
                 * is schedule or <code>null</code> otherwise
                 */
                Schedulable.prototype.scheduledNext = function () {
                    if (!this.isScheduled()) {
                        return null;
                    }
                    else {
                        return this._schedule[0].getTime();
                    }
                };
                /**
                 * Adds an event-note to the Schedulable.
                 * @param {desmoj.core.simulator.EventNote} note
                 */
                Schedulable.prototype.addEventNote = function (note) {
                    if (!(this._schedule.indexOf((note)) >= 0)) {
                        /* add */ (this._schedule.push(note) > 0);
                        /* sort */ this._schedule.sort();
                    }
                };
                /**
                 * Creates and returns a copy of this Schedulable.
                 * Note that subclasses have to implement the interface
                 * <code>java.lang.Cloneable</code> to actually use this method as
                 * otherwise, a <code>CloneNotSupportedException</code> will be thrown.
                 *
                 * @return {desmoj.core.simulator.Schedulable} Schedulable : A copy of this Schedulable.
                 */
                Schedulable.prototype.clone = function () {
                    var _this = this;
                    var c = (function (o) { if (_super.prototype.clone != undefined) {
                        return _super.prototype.clone.call(_this);
                    }
                    else {
                        var clone = Object.create(o);
                        for (var p in o) {
                            if (o.hasOwnProperty(p))
                                clone[p] = o[p];
                        }
                        return clone;
                    } })(this);
                    var nc = this.getModel().getExperiment().getNameCatalog();
                    c.rename(nc.getNameWithoutSuffix(this.getName()));
                    c._schedule = ([]);
                    return c;
                };
                /**
                 * Allows to allocate a <code>Reporter</code> to this <code>Schedulable</code>.
                 * Bypassing the usual approach of each <code>ModelComponent</code> either being
                 * a <code>Schedulable</code> or a <code>Reportable</code>, this allocation
                 * permits generating report output about a <code>ModelComponent</code> that is
                 * also used for scheduling. Internally, a dummy <code>Reportable</code> is generated,
                 * strictly speaking (hidden from the user) is the true <code>Reportable</code>
                 * to report about.
                 *
                 * @param r
                 * Reporter : The offset to the current simulation time at which
                 * this Schedulable is to be re-scheduled.
                 * Must have a constructor accepting a <code>Schedulable</code>
                 * as only (!) parameter.
                 * @param {boolean} showInReport
                 * boolean : Flag for showing the report. Set it to
                 * <code>true</code> if reportable should show up in report.
                 * Set it to <code>false</code> if reportable should not be
                 * shown in report.
                 * @param {boolean} showInTrace
                 * boolean : Flag for showing this reportable in trace files. Set
                 * it to <code>true</code> if reportable should show up in
                 * trace. Set it to <code>false</code> if reportable should not
                 * be shown in trace.
                 * @param {*} reporterClass
                 */
                Schedulable.prototype.assignReporter = function (reporterClass, showInReport, showInTrace) {
                    var d = new Schedulable.DummyReportable(this, this.getModel(), reporterClass, showInReport, showInTrace);
                    this.setCorrespondingReportable(d);
                    d.setCorrespondingSchedulable(this);
                };
                /**
                 * Gets the Reportable corresponding to this Schedulable;
                 * may be null if no Reportable corresponds to this Schedulable.
                 *
                 * @return {desmoj.core.simulator.Reportable} Reportable : The Reportable corresponding
                 * to this Schedulable (may be null if no Reportable corresponds to this Schedulable!)
                 */
                Schedulable.prototype.getCorrespondingReportable = function () {
                    return this._correspondingReportable;
                };
                /**
                 * Sets the Reportable (e.g. entity) corresponding to this Schedulable.
                 * May be null if no Reportable corresponds to this Schedulable.
                 * If set, the Reportable must have the same model as this Schedulable!
                 * A Schedulable needs not have a corresponding Reportable.
                 *
                 * @param {desmoj.core.simulator.Reportable} correspondingReportable
                 * Reportable : The Reportable corresponding to this Schedulable.
                 */
                Schedulable.prototype.setCorrespondingReportable = function (correspondingReportable) {
                    if (correspondingReportable != null && this.getModel() !== correspondingReportable.getModel()) {
                        this.sendWarning("Reportable to correspond to this Schedulable must belong to the same model!", "Schedulable.setCorrespondingReportable(Reportable)", "Model of Schedulable and corresponding Reportable must be identical.", "Do not set a corresponding schedulable to another model\'s Reportable.");
                        return;
                    }
                    this._correspondingReportable = correspondingReportable;
                };
                return Schedulable;
            }(desmoj.core.simulator.ModelComponent));
            simulator.Schedulable = Schedulable;
            Schedulable["__class"] = "desmoj.core.simulator.Schedulable";
            (function (Schedulable) {
                /**
                 * Helper object to be able to report about this Schedulable.
                 * @param {desmoj.core.simulator.Model} owner
                 * @param {*} reporterClass
                 * @param {boolean} showInReport
                 * @param {boolean} showInTrace
                 * @class
                 * @extends desmoj.core.simulator.Reportable
                 */
                var DummyReportable = (function (_super) {
                    __extends(DummyReportable, _super);
                    function DummyReportable(__parent, owner, reporterClass, showInReport, showInTrace) {
                        var _this = _super.call(this, owner, "DummyReporter", showInReport, showInTrace) || this;
                        _this.__parent = __parent;
                        _this.reporterClass = null;
                        _this.reporterClass = reporterClass;
                        return _this;
                    }
                    DummyReportable.prototype.createDefaultReporter = function () {
                        return this.createDefaultReporter();
                    };
                    return DummyReportable;
                }(desmoj.core.simulator.Reportable));
                Schedulable.DummyReportable = DummyReportable;
                DummyReportable["__class"] = "desmoj.core.simulator.Schedulable.DummyReportable";
            })(Schedulable = simulator.Schedulable || (simulator.Schedulable = {}));
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var statistic;
        (function (statistic) {
            /**
             * Constructor for a StatisticObject, preliminarily without a unit assigned
             *
             * @param {desmoj.core.simulator.Model} ownerModel
             * Model : The model this StatisticObject is associated to.
             * @param {string} name
             * java.lang.String : The name of this StatisticObject
             * @param {boolean} showInReport
             * boolean : Flag for showing the report about this
             * StatisticObject.
             * @param {boolean} showInTrace
             * boolean : Flag for showing this StatisticObject in trace
             * files.
             * @class
             * @extends desmoj.core.simulator.Reportable
             * @author Soenke Claassen
             */
            var StatisticObject = (function (_super) {
                __extends(StatisticObject, _super);
                function StatisticObject(ownerModel, name, showInReport, showInTrace) {
                    var _this = _super.call(this, ownerModel, name, showInReport, showInTrace) || this;
                    _this.unit = null;
                    return _this;
                }
                StatisticObject.UNDEFINED_$LI$ = function () { if (StatisticObject.UNDEFINED == null)
                    StatisticObject.UNDEFINED = -1.0; return StatisticObject.UNDEFINED; };
                ;
                StatisticObject.PRECISION_$LI$ = function () { if (StatisticObject.PRECISION == null)
                    StatisticObject.PRECISION = Math.pow(10.0, StatisticObject.FRACTION_DIGITS); return StatisticObject.PRECISION; };
                ;
                /**
                 * Converts an <code>Object</code> to a <code>double</code> -value. If
                 * the given object is not an instance of a number wrapper class a warning
                 * is produced and the UNDEFINED-value (-1.0) is returned. <br>
                 * So the <code>StatisticObject</code> can be notified by a
                 * <code>ValueSupplier</code> with the
                 * <code>notifyStatistics(Object arg)</code> method, where the value is
                 * passed as an object in this method.
                 *
                 * @return {number} double : The double value the given object is converted to.
                 * @param {*} obj
                 * Object : The Object which will be converted to a double value.
                 */
                StatisticObject.prototype.convertToDouble = function (obj) {
                    if (obj == null) {
                        this.sendWarning("Attempt to convert a null pointer to a double value. Zero (0.0) is returned!", "StatisticObject: " + this.getName() + " Method: double convertToDouble" + "(Object obj)", "A null pointer can not be converted to a double value. Zero is assumed and will be returned.", "Make sure not to pass a null pointer where an Object is expected.");
                        return 0.0;
                    }
                    if (typeof obj === 'number') {
                        return obj;
                    }
                    if (typeof obj === 'number') {
                        return obj;
                    }
                    if (typeof obj === 'number') {
                        return obj;
                    }
                    if (typeof obj === 'number') {
                        return obj;
                    }
                    if (typeof obj === 'number') {
                        return obj;
                    }
                    if (typeof obj === 'number') {
                        return obj;
                    }
                    this.sendWarning("Attempt to convert an object which is not a number wrapper class to a double value. The UNDEFINED value (-1.0) is returned!", "StatisticObject: " + this.getName() + " Method: double convertToDouble" + "(Object obj)", "The given Object is an instance of the class: " + obj.constructor.toString() + ". This can not be converted to a double.", "Make sure to use a number wrapper class for numeric values.");
                    return StatisticObject.UNDEFINED_$LI$();
                };
                /**
                 * Leaves a message in the trace that this StatisticObject has been updated.
                 */
                StatisticObject.prototype.traceUpdate = function () {
                    if (this.currentlySendTraceNotes()) {
                        this.sendTraceNote("updates " + this.getQuotedName());
                    }
                };
                /**
                 * Rounds a double value with repect to the <code>PRECISION</code>.
                 *
                 * @return {number} double : The rounded value.
                 * @param {number} d
                 * double : The value to be rounded
                 */
                StatisticObject.round = function (d) {
                    return (function (d) { if (d === Number.NaN) {
                        return d;
                    }
                    else if (Number.POSITIVE_INFINITY === d || Number.NEGATIVE_INFINITY === d) {
                        return d;
                    }
                    else if (d == 0) {
                        return d;
                    }
                    else {
                        return Math.round(d);
                    } })(StatisticObject.PRECISION_$LI$() * d) / StatisticObject.PRECISION_$LI$();
                };
                /**
                 * Set an optional unit of reported value. Default is null.
                 * This value is shown in description reports.
                 * @param {string} unit
                 */
                StatisticObject.prototype.setUnit = function (unit) {
                    this.unit = unit;
                };
                /**
                 * Get an optional unit of reported value. Default is null.
                 * This value is shown in description reports.
                 * @return {string} String : The optional unit
                 */
                StatisticObject.prototype.getUnit = function () {
                    return this.unit;
                };
                /**
                 * Textually wraps the output of <code>getUnit()</code>, adding
                 * brackets and displaying "none" if case unit is <code>null</code>.
                 * @return
                 * @return {string}
                 */
                StatisticObject.prototype.getUnitText = function () {
                    var unit = this.getUnit();
                    if (unit == null || unit.length === 0)
                        return "none";
                    else
                        return "[" + unit + "]";
                };
                return StatisticObject;
            }(desmoj.core.simulator.Reportable));
            /**
             * The number of digits after the decimal point which will be displayed for
             * the numbers in the reports. A precision of more than that is obsolete.
             */
            StatisticObject.FRACTION_DIGITS = 5.0;
            statistic.StatisticObject = StatisticObject;
            StatisticObject["__class"] = "desmoj.core.statistic.StatisticObject";
            StatisticObject["__interfaces"] = ["java.util.Observer"];
        })(statistic = core.statistic || (core.statistic = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            /**
             * Create a new HTMLDebugOutput class
             *
             * @param {number} simTimeFloatingDigits
             * int: The number of floating point digits of the simulation
             * time values to be displayed
             * @class
             * @extends desmoj.core.report.DebugFileOut
             * @author Gunnar Kiesel
             */
            var HTMLDebugOutput = (function (_super) {
                __extends(HTMLDebugOutput, _super);
                function HTMLDebugOutput(simTimeFloatingDigits) {
                    var _this = this;
                    if (((typeof simTimeFloatingDigits === 'number') || simTimeFloatingDigits === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        _this = _super.call(this, simTimeFloatingDigits, "desmoj.core.report.HTMLTableFormatter") || this;
                    }
                    else if (simTimeFloatingDigits === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        _this = _super.call(this, 1, "desmoj.core.report.HTMLTableFormatter") || this;
                    }
                    else
                        throw new Error('invalid overload');
                    return _this;
                }
                /**
                 * set the time of the current output
                 *
                 * @param {number} timeFloats
                 * int: time of the curent output
                 */
                HTMLDebugOutput.prototype.setTimeFloats = function (timeFloats) {
                    this.formatter.setTimePrecision(timeFloats);
                };
                /**
                 * returns the file appendix for this output type *
                 * @return {string}
                 */
                HTMLDebugOutput.prototype.getAppendix = function () {
                    return ".html";
                };
                return HTMLDebugOutput;
            }(desmoj.core.report.DebugFileOut));
            report.HTMLDebugOutput = HTMLDebugOutput;
            HTMLDebugOutput["__class"] = "desmoj.core.report.HTMLDebugOutput";
            HTMLDebugOutput["__interfaces"] = ["desmoj.core.report.OutputType", "desmoj.core.report.MessageReceiver"];
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            /**
             * Create a new HTMLErrorOutput class
             *
             * @param {number} simTimeFloatingDigits
             * int: The number of floating point digits of the simulation
             * time values to be displayed
             * @class
             * @extends desmoj.core.report.ErrorFileOut
             * @author Gunnar Kiesel
             */
            var HTMLErrorOutput = (function (_super) {
                __extends(HTMLErrorOutput, _super);
                function HTMLErrorOutput(simTimeFloatingDigits) {
                    var _this = this;
                    if (((typeof simTimeFloatingDigits === 'number') || simTimeFloatingDigits === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        _this = _super.call(this, simTimeFloatingDigits, "desmoj.core.report.HTMLTableFormatter") || this;
                    }
                    else if (simTimeFloatingDigits === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        _this = _super.call(this, 1, "desmoj.core.report.HTMLTableFormatter") || this;
                    }
                    else
                        throw new Error('invalid overload');
                    return _this;
                }
                /**
                 * set the time of the current output
                 *
                 * @param {number} timeFloats
                 * int: time of the curent output
                 */
                HTMLErrorOutput.prototype.setTimeFloats = function (timeFloats) {
                    this.formatter.setTimePrecision(timeFloats);
                };
                /**
                 * returns the file appendix for this output type *
                 * @return {string}
                 */
                HTMLErrorOutput.prototype.getAppendix = function () {
                    return ".html";
                };
                return HTMLErrorOutput;
            }(desmoj.core.report.ErrorFileOut));
            report.HTMLErrorOutput = HTMLErrorOutput;
            HTMLErrorOutput["__class"] = "desmoj.core.report.HTMLErrorOutput";
            HTMLErrorOutput["__interfaces"] = ["desmoj.core.report.OutputType", "desmoj.core.report.MessageReceiver"];
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            /**
             * Creates a file to print reports into a HTML page. By opening the file,
             * the necessary HTML tags to define a webpage are already inserted into the
             * file. The parameter given should reflect the experiment that produces
             * this file.
             *
             * @param {number} simTimeFloatingDigits
             * int : The number of floating point digits of the simulation
             * time values to be displayed
             * @param {string} formatter
             * @class
             * @extends desmoj.core.report.ReportFileOut
             * @author of ReportFileOut class : Tim Lechler, modified by Soenke Claassen and
             */
            var ReportMultRowsFileOut = (function (_super) {
                __extends(ReportMultRowsFileOut, _super);
                function ReportMultRowsFileOut(simTimeFloatingDigits, formatter) {
                    var _this = _super.call(this, simTimeFloatingDigits, formatter) || this;
                    _this._timeSeriesCanvas = null;
                    _this._timeSeriesCanvas = ({});
                    return _this;
                }
                ReportMultRowsFileOut.prototype.receive$desmoj_core_report_Reporter = function (r) {
                    if (r == null)
                        return;
                    var titleBuf = r.getColumnTitles();
                    var entryBuf = r.getEntries();
                    if (this.lastReporter == null) {
                        this.formatter.openTable(r.getHeading());
                        this.formatter.openRow();
                        for (var i = 0; i < r.numColumns(); i++) {
                            this.formatter.writeHeadingCell(titleBuf[i]);
                        }
                        ;
                        this.formatter.closeRow();
                        this.lastReporter = r;
                    }
                    else {
                        if (r.isContinuingReporter() && this.lastReporter.isContinuingReporter() && desmoj.core.report.Reporter.isSameGroup(r, this.lastReporter)) {
                            this.formatter.closeTable();
                            this.formatter.openTable(" ");
                            this.formatter.openRow();
                            for (var i = 0; i < r.numColumns(); i++) {
                                this.formatter.writeHeadingCell(titleBuf[i]);
                            }
                            ;
                            this.formatter.closeRow();
                        }
                    }
                    if (desmoj.core.report.Reporter.isOtherGroup(r, this.lastReporter) && !(r != null && r instanceof desmoj.core.report.TableReporter)) {
                        this.formatter.closeTable();
                        this.formatter.writeHorizontalRuler();
                        this.formatter.openTable(r.getHeading());
                        this.formatter.openRow();
                        for (var i = 0; i < r.numColumns(); i++) {
                            this.formatter.writeHeadingCell(titleBuf[i]);
                        }
                        ;
                        if ((this.formatter != null && this.formatter instanceof desmoj.core.report.HTMLTableChartFormatter) && r.makeAdditionalColorEntryIfHTMLColorChartIsGenerated()) {
                            this.formatter.writeHeadingCell("Color");
                        }
                        this.formatter.closeRow();
                    }
                    if (r.isTwoRowReporter()) {
                        if (this.formatter != null && this.formatter instanceof desmoj.core.report.AbstractTableFormatter) {
                            this.formatter.openRow$desmoj_core_report_Reporter(r);
                        }
                        else {
                            this.formatter.openRow();
                        }
                        for (var i = 0; i < r.numColumns(); i++) {
                            this.formatter.writeCell(entryBuf[i], 1);
                        }
                        ;
                        this.formatter.closeRow();
                        if (this.formatter != null && this.formatter instanceof desmoj.core.report.AbstractTableFormatter) {
                            this.formatter.openRow$desmoj_core_report_Reporter(r);
                        }
                        else {
                            this.formatter.openRow();
                        }
                        for (var i = r.numColumns(); i < (r.numColumns() * 2); i++) {
                            this.formatter.writeCell(entryBuf[i], 1);
                        }
                        ;
                        this.formatter.closeRow();
                        if (r.getNumOfSlaveQueues() > 0) {
                            var numberSlaveQueues = r.getNumOfSlaveQueues();
                            for (var j = 1; j < numberSlaveQueues; j++) {
                                if (this.formatter != null && this.formatter instanceof desmoj.core.report.AbstractTableFormatter) {
                                    this.formatter.openRow$desmoj_core_report_Reporter(r);
                                }
                                else {
                                    this.formatter.openRow();
                                }
                                for (var i = (r.numColumns() * (j + 1)); i < (r.numColumns() * (j + 2)); i++) {
                                    this.formatter.writeCell(entryBuf[i], 1);
                                }
                                ;
                                this.formatter.closeRow();
                            }
                            ;
                        }
                        else {
                            var rows = (entryBuf.length / r.__numColumns | 0);
                            for (var row = 2; row < rows; row++) {
                                var empty = true;
                                for (var i = row * r.numColumns(); i < r.numColumns() * (row + 1); i++) {
                                    if (entryBuf[i] != null && entryBuf[i].length > 0) {
                                        empty = false;
                                        break;
                                    }
                                }
                                ;
                                if (empty)
                                    continue;
                                if (this.formatter != null && this.formatter instanceof desmoj.core.report.AbstractTableFormatter) {
                                    this.formatter.openRow$desmoj_core_report_Reporter(r);
                                }
                                else {
                                    this.formatter.openRow();
                                }
                                for (var i = row * r.numColumns(); i < r.numColumns() * (row + 1); i++) {
                                    this.formatter.writeCell(entryBuf[i], 1);
                                }
                                ;
                                this.formatter.closeRow();
                            }
                            ;
                        }
                    }
                    else if (!(r != null && r instanceof desmoj.core.report.TableReporter)) {
                        if (this.formatter != null && this.formatter instanceof desmoj.core.report.AbstractTableFormatter) {
                            this.formatter.openRow$desmoj_core_report_Reporter(r);
                        }
                        else {
                            this.formatter.openRow();
                        }
                        for (var i = 0; i < r.numColumns(); i++) {
                            this.formatter.writeCell(entryBuf[i], 1);
                        }
                        ;
                        this.formatter.closeRow();
                    }
                    if (r.getDescription() != null && r.getDescription().length > 0) {
                        if (this.formatter != null && this.formatter instanceof desmoj.core.report.AbstractTableFormatter) {
                            this.formatter.openRow$desmoj_core_report_Reporter(r);
                        }
                        else {
                            this.formatter.openRow();
                        }
                        if (ReportMultRowsFileOut.__offsetDescriptionsOneColumn) {
                            this.formatter.writeCell("", 1);
                            this.formatter.writeCell(r.getDescription(), r.numColumns() - 1);
                        }
                        else {
                            this.formatter.writeCell(r.getDescription(), r.numColumns());
                        }
                        this.formatter.closeRow();
                    }
                    if (r != null && r instanceof desmoj.core.report.TableReporter)
                        this.writeTableReporter(r, titleBuf);
                    this.lastReporter = r;
                };
                /**
                 * Receives a reporter and writes its contents formatted to a HTML table
                 * into a file in the user's default directory. In case of a ModelReporter
                 * it writes the model's information into the file. After writing the model
                 * data, all reportables registered with the ModelReporter are asked for a
                 * reporter and those are also written to the report file. After processing
                 * the Reportables, the registered subModels are asked to produce their
                 * reporters which in turn are recursively sent to this method until no
                 * other submodels are available.
                 *
                 * @param {desmoj.core.report.Reporter} r
                 * Reporter : The Reporter to be processed
                 */
                ReportMultRowsFileOut.prototype.receive = function (r) {
                    if (((r != null && r instanceof desmoj.core.report.Reporter) || r === null)) {
                        return this.receive$desmoj_core_report_Reporter(r);
                    }
                    else if (((r != null && r instanceof desmoj.core.report.Message) || r === null)) {
                        _super.prototype.receive.call(this, r);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Writes a table reporter
                 * @param {desmoj.core.report.TableReporter} tr
                 * @param {Array} titleBuf
                 * @private
                 */
                /*private*/ ReportMultRowsFileOut.prototype.writeTableReporter = function (tr, titleBuf) {
                    var cols = tr.numColumns();
                    var rows = tr.numRows();
                    var entryTable = tr.getEntryTable();
                    if (this.formatter.tableIsOpen())
                        this.formatter.closeTable();
                    this.formatter.writeHorizontalRuler();
                    this.formatter.openTable(tr.getTitle());
                    var header = tr.getHeader();
                    if (header != null) {
                        for (var i = 0; i < header.length; i++) {
                            this.formatter.openRow();
                            for (var j = 0; j < header[i].length; j++) {
                                this.formatter.writeCell(header[i][j], 1);
                            }
                            ;
                            this.formatter.closeRow();
                        }
                        ;
                        this.formatter.openRow();
                        this.formatter.writeCell("___", 1);
                        this.formatter.closeRow();
                    }
                    this.formatter.openRow();
                    for (var i = 0; i < cols; i++) {
                        this.formatter.writeHeadingCell(titleBuf[i]);
                    }
                    ;
                    this.formatter.closeRow();
                    this.formatter.openRow();
                    this.formatter.closeRow();
                    for (var i = 0; i < rows; i++) {
                        this.formatter.openRow();
                        for (var j = 0; j < cols; j++) {
                            this.formatter.writeCell(entryTable[i][j], 1);
                        }
                        ;
                        this.formatter.closeRow();
                    }
                    ;
                    this.formatter.closeTable();
                };
                /**
                 * Set report output such that nested Reporter descriptions
                 * are offset by one column, thus improving readability at the expense
                 * of space.
                 */
                ReportMultRowsFileOut.offsetDescriptionsOneColumn = function () {
                    ReportMultRowsFileOut.__offsetDescriptionsOneColumn = true;
                };
                return ReportMultRowsFileOut;
            }(desmoj.core.report.ReportFileOut));
            /**
             * Flag to shift nested reporter descriptions one column if set to
             * <code>true</code>.
             */
            ReportMultRowsFileOut.__offsetDescriptionsOneColumn = false;
            report.ReportMultRowsFileOut = ReportMultRowsFileOut;
            ReportMultRowsFileOut["__class"] = "desmoj.core.report.ReportMultRowsFileOut";
            ReportMultRowsFileOut["__interfaces"] = ["desmoj.core.report.MessageReceiver"];
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            /**
             * Create a new HTMLTraceOutput class
             *
             * @param {number} simTimeFloatingDigits
             * int: The number of floating point digits of the simulation
             * time values to be displayed
             * @class
             * @extends desmoj.core.report.TraceFileOut
             * @author Gunnar Kiesel
             */
            var HTMLTraceOutput = (function (_super) {
                __extends(HTMLTraceOutput, _super);
                function HTMLTraceOutput(simTimeFloatingDigits) {
                    var _this = this;
                    if (((typeof simTimeFloatingDigits === 'number') || simTimeFloatingDigits === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        _this = _super.call(this, simTimeFloatingDigits, "desmoj.core.report.HTMLTableFormatter") || this;
                    }
                    else if (simTimeFloatingDigits === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        _this = _super.call(this, 1, "desmoj.core.report.HTMLTableFormatter") || this;
                    }
                    else
                        throw new Error('invalid overload');
                    return _this;
                }
                /**
                 * set the time of the current output
                 *
                 * @param {number} timeFloats
                 * int: time of the curent output
                 */
                HTMLTraceOutput.prototype.setTimeFloats = function (timeFloats) {
                    this.formatter.setTimePrecision(timeFloats);
                };
                /**
                 * returns the file appendix for this output type *
                 * @return {string}
                 */
                HTMLTraceOutput.prototype.getAppendix = function () {
                    return ".html";
                };
                return HTMLTraceOutput;
            }(desmoj.core.report.TraceFileOut));
            report.HTMLTraceOutput = HTMLTraceOutput;
            HTMLTraceOutput["__class"] = "desmoj.core.report.HTMLTraceOutput";
            HTMLTraceOutput["__interfaces"] = ["desmoj.core.report.OutputType", "desmoj.core.report.MessageReceiver"];
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            var html5chart;
            (function (html5chart) {
                /**
                 * Create a Canvas for TextHistogram.
                 *
                 * @param {string} canvasName
                 * The name of the canvas.
                 * @param {number} canvasHeight
                 * The height of the canvas.
                 * @param {number} canvasWidth
                 * The width of the canvas.
                 * @param data
                 * The data of the TextHistogram to be displayed in this canvas.
                 * @param data
                 * Text at the x-axis
                 * @param {desmoj.core.report.html5chart.ChartDataHistogramDouble} textHistData
                 * @param {string} xText
                 * @class
                 * @extends desmoj.core.report.html5chart.AbstractNumericalCoorChartCanvasDouble
                 * @author Johanna Djimandjaja
                 */
                var CanvasHistogramDouble = (function (_super) {
                    __extends(CanvasHistogramDouble, _super);
                    function CanvasHistogramDouble(canvasName, canvasHeight, canvasWidth, textHistData, xText) {
                        var _this = _super.call(this, canvasName, canvasHeight, canvasWidth, textHistData) || this;
                        /**
                         * The title for the x-Axis
                         */
                        /*private*/ _this._xAxisTitle = "";
                        /**
                         * The title for the y-Axis
                         */
                        /*private*/ _this._yAxisTtile = "n";
                        _this._xAxisTitle = xText;
                        return _this;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    CanvasHistogramDouble.prototype.getNumOfXScale = function () {
                        return 0;
                    };
                    /**
                     *
                     * @return {number}
                     */
                    CanvasHistogramDouble.prototype.getXScale = function () {
                        return 0.0;
                    };
                    /**
                     *
                     * @return {number}
                     */
                    CanvasHistogramDouble.prototype.getStartXScale = function () {
                        return 0.0;
                    };
                    /**
                     *
                     * @return {string}
                     */
                    CanvasHistogramDouble.prototype.getXAxisTitle = function () {
                        return this._xAxisTitle;
                    };
                    /**
                     *
                     * @return {string}
                     */
                    CanvasHistogramDouble.prototype.getYAxisTitle = function () {
                        return this._yAxisTtile;
                    };
                    /**
                     * Returns the value of the data at a specified index.
                     *
                     * @param {number} index
                     * The index of the data.
                     *
                     * @return
                     * Double :
                     * @return {number}
                     */
                    CanvasHistogramDouble.prototype.getDataValue = function (index) {
                        if (index < 0 || index > this.getNumOfData()) {
                            return 0.0;
                        }
                        return this.chartData.getDataValue(index);
                    };
                    /**
                     * Returns the observed text at the given index.
                     * @param {number} index
                     * int : The index of the String asked for
                     * @return
                     * String : The observed text at the given index
                     * @return {string}
                     */
                    CanvasHistogramDouble.prototype.getText = function (index) {
                        var thCartData = this.chartData;
                        if (index < 0 || index >= this.getNumOfData())
                            return "";
                        else
                            return thCartData.getObservedString(index);
                    };
                    return CanvasHistogramDouble;
                }(desmoj.core.report.html5chart.AbstractNumericalCoorChartCanvasDouble));
                html5chart.CanvasHistogramDouble = CanvasHistogramDouble;
                CanvasHistogramDouble["__class"] = "desmoj.core.report.html5chart.CanvasHistogramDouble";
                CanvasHistogramDouble["__interfaces"] = ["desmoj.core.report.html5chart.Canvas", "desmoj.core.report.html5chart.CanvasCoordinateChart"];
            })(html5chart = report.html5chart || (report.html5chart = {}));
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            var html5chart;
            (function (html5chart) {
                /**
                 * Create a Canvas for TextHistogram.
                 *
                 * @param {string} canvasName
                 * The name of the canvas.
                 * @param {number} canvasHeight
                 * The height of the canvas.
                 * @param {number} canvasWidth
                 * The width of the canvas.
                 * @param data
                 * The data of the TextHistogram to be displayed in this canvas.
                 * @param data
                 * Text at the x-axis
                 * @param {desmoj.core.report.html5chart.ChartDataHistogramLong} textHistData
                 * @param {string} xText
                 * @class
                 * @extends desmoj.core.report.html5chart.AbstractNumericalCoorChartCanvasLong
                 * @author Johanna Djimandjaja
                 */
                var CanvasHistogramLong = (function (_super) {
                    __extends(CanvasHistogramLong, _super);
                    function CanvasHistogramLong(canvasName, canvasHeight, canvasWidth, textHistData, xText) {
                        var _this = _super.call(this, canvasName, canvasHeight, canvasWidth, textHistData) || this;
                        /**
                         * The title for the x-Axis
                         */
                        /*private*/ _this._xAxisTitle = "";
                        /**
                         * The title for the y-Axis
                         */
                        /*private*/ _this._yAxisTtile = "n";
                        _this._xAxisTitle = xText;
                        return _this;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    CanvasHistogramLong.prototype.getNumOfXScale = function () {
                        return 0;
                    };
                    /**
                     *
                     * @return {number}
                     */
                    CanvasHistogramLong.prototype.getXScale = function () {
                        return 0;
                    };
                    /**
                     *
                     * @return {number}
                     */
                    CanvasHistogramLong.prototype.getStartXScale = function () {
                        return 0;
                    };
                    /**
                     *
                     * @return {string}
                     */
                    CanvasHistogramLong.prototype.getXAxisTitle = function () {
                        return this._xAxisTitle;
                    };
                    /**
                     *
                     * @return {string}
                     */
                    CanvasHistogramLong.prototype.getYAxisTitle = function () {
                        return this._yAxisTtile;
                    };
                    /**
                     * Returns the value of the data at a specified index.
                     *
                     * @param {number} index
                     * The index of the data.
                     *
                     * @return
                     * Long :
                     * @return {number}
                     */
                    CanvasHistogramLong.prototype.getDataValue = function (index) {
                        if (index < 0 || index >= this.getNumOfData()) {
                            return 0;
                        }
                        return this.chartData.getDataValue(index);
                    };
                    /**
                     * Returns the observed text at the given index.
                     * @param {number} index
                     * int : The index of the String asked for
                     * @return
                     * String : The observed text at the given index
                     * @return {string}
                     */
                    CanvasHistogramLong.prototype.getText = function (index) {
                        var thCartData = this.chartData;
                        if (index < 0 || index >= this.getNumOfData())
                            return "";
                        else
                            return thCartData.getObservedString(index);
                    };
                    return CanvasHistogramLong;
                }(desmoj.core.report.html5chart.AbstractNumericalCoorChartCanvasLong));
                html5chart.CanvasHistogramLong = CanvasHistogramLong;
                CanvasHistogramLong["__class"] = "desmoj.core.report.html5chart.CanvasHistogramLong";
                CanvasHistogramLong["__interfaces"] = ["desmoj.core.report.html5chart.Canvas", "desmoj.core.report.html5chart.CanvasCoordinateChart"];
            })(html5chart = report.html5chart || (report.html5chart = {}));
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var dist;
        (function (dist) {
            /**
             * Base class for all distributions that produce numbers.
             *
             * @version DESMO-J, Ver. 2.5.1e copyright (c) 2017
             * @author Tim Lechler
             *
             * Licensed under the Apache License, Version 2.0 (the "License"); you
             * may not use this file except in compliance with the License. You may
             * obtain a copy of the License at
             * http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
             * implied. See the License for the specific language governing
             * permissions and limitations under the License.
             *
             * @param {desmoj.core.simulator.Model} owner
             * @param {string} name
             * @param {boolean} showInReport
             * @param {boolean} showInTrace
             * @class
             * @extends desmoj.core.dist.Distribution
             */
            var NumericalDist = (function (_super) {
                __extends(NumericalDist, _super);
                function NumericalDist(owner, name, showInReport, showInTrace) {
                    return _super.call(this, owner, name, showInReport, showInTrace) || this;
                }
                /**
                 * Method to return the specific sample as a value of type N.
                 * Default implementation calls <code>getInverseCumulativeProbability()</code>,
                 * to which a random number from <code>randomGenerator</code> is passed.
                 * Subclasses may need to refine this method if <code>getInverseCumulativeProbability()</code>
                 * is not implemented as the distribution does not support inverse transformation.
                 *
                 * @return {number} N : The sample of type N to be drawn from this distribution
                 */
                NumericalDist.prototype.sample = function () {
                    this.incrementObservations();
                    var sample;
                    var attempts = 0;
                    do {
                        sample = this.antithetic ? this.getInverseOfCumulativeProbabilityFunction(1 - this.randomGenerator.nextDouble()) : this.getInverseOfCumulativeProbabilityFunction(this.randomGenerator.nextDouble());
                        attempts++;
                    } while ((this.nonNegative && def.NumberValueHelper.doubleValue(sample) < 0 && attempts < 100));
                    if (this.nonNegative && def.NumberValueHelper.doubleValue(sample) < 0) {
                        this.sendWarning("NumericalDist that was set non-negative faild to sample a non-negative value.Returning a negative result.", "NumericalDist: " + this.getName() + " Method: public void sample()", "100 Attempts of sampling the distribution yielded a negative value.", "Make sure the range of the NumericalDist is at least partially non-negative.");
                    }
                    if (this.currentlySendTraceNotes()) {
                        this.sendTraceNote("samples " + sample + " from " + this);
                    }
                    if (this.currentlySendDebugNotes())
                        this.traceLastSample(sample + "");
                    console.info("Sample: " + sample.toString());
                    return sample;
                };
                NumericalDist.prototype.sampleTimeSpan$ = function () {
                    if (!this.getModel().isConnected()) {
                        this.sendWarning("Failed to sample a TimeSpan. Returning TimeSpan(0) instead.", "NumericalDist: " + this.getName() + " Method: TimeSpan sampleTimeSpan()", "Model not yet connected to an experiment, thus reference time unit and random number seeds not yet set.", "Make sure your model is connected to an experiment before this method is called.");
                        return new desmoj.core.simulator.TimeSpan(0);
                    }
                    var sample = this.sample();
                    if (def.NumberValueHelper.doubleValue(sample) < 0) {
                        this.sendWarning("Failed to sample a TimeSpan. Returning TimeSpan(0) instead.", "NumericalDist: " + this.getName() + " Method: TimeSpan sampleTimeSpan()", "The distribution returned a negative sample (" + def.NumberValueHelper.doubleValue(sample) + ").", "Make sure to sample TimeSpans from non-negative distributions only.");
                        return new desmoj.core.simulator.TimeSpan(0);
                    }
                    if ((typeof sample === 'number') || (typeof sample === 'number')) {
                        return new desmoj.core.simulator.TimeSpan(def.NumberValueHelper.doubleValue(sample));
                    }
                    else {
                        return new desmoj.core.simulator.TimeSpan(def.NumberValueHelper.longValue(sample));
                    }
                };
                NumericalDist.prototype.sampleTimeSpan$def_TimeUnit = function (unit) {
                    if (unit == null) {
                        throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t create TimeSpan object! Simulation aborted.", "NumericalDist: " + this.getName() + " Method: TimeSpan sampleTimeSpan(TimeUnit unit)", "Time unit passed is null", "Make sure to pass a non-null time unit.", null)));
                    }
                    if (!this.getModel().isConnected()) {
                        this.sendWarning("Failed to sample a TimeSpan. Returning TimeSpan(0) instead.", "NumericalDist: " + this.getName() + " Method: TimeSpan sampleTimeSpan(TimeUnit unit)", "Model not yet connected to an experiment, thus random number seeds not yet set.", "Make sure your model is connected to an experiment before this method is called.");
                        return new desmoj.core.simulator.TimeSpan(0);
                    }
                    var sample = this.sample();
                    if (def.NumberValueHelper.doubleValue(sample) < 0) {
                        this.sendWarning("Failed to sample a TimeSpan. Returning TimeSpan(0) instead.", "NumericalDist: " + this.getName() + " Method: TimeSpan sampleTimeSpan(TimeUnit unit)", "The distribution returned a negative sample (" + def.NumberValueHelper.doubleValue(sample) + ").", "Make sure to sample TimeSpans from non-negative distributions only.");
                        return new desmoj.core.simulator.TimeSpan(0);
                    }
                    if ((typeof sample === 'number') || (typeof sample === 'number')) {
                        return new desmoj.core.simulator.TimeSpan(def.NumberValueHelper.doubleValue(sample), unit);
                    }
                    else {
                        return new desmoj.core.simulator.TimeSpan(def.NumberValueHelper.longValue(sample), unit);
                    }
                };
                /**
                 * Convenience method to sample a period of random length by creating a
                 * <code>TimeSpan</code> whose length is determined by sampling this
                 * distribution (time unit given explicitly as parameter), thus replacing
                 * the pattern <code>new TimeSpan(distribution.sample(), unit)</code>.
                 *
                 * @param {def.TimeUnit} unit
                 * TimeUnit: the TimeUnit to assign to the sampled value
                 *
                 * @return {desmoj.core.simulator.TimeSpan} TimeSpan : The TimeSpan sampled from this distribution
                 */
                NumericalDist.prototype.sampleTimeSpan = function (unit) {
                    if (((typeof unit === 'number') || unit === null)) {
                        return this.sampleTimeSpan$def_TimeUnit(unit);
                    }
                    else if (unit === undefined) {
                        return this.sampleTimeSpan$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Convenience method to return the distribution's sample as <code>Object</code>.
                 * For type safety, method <code>sample()</code> should be preferred. However,
                 * this method is useful for environments requiring a non-genetic access point
                 * to obtain samples from any distribution.
                 *
                 * @return {*} Object : A sample from this this distribution wrapped as <code>Object</code>.
                 */
                NumericalDist.prototype.sampleObject = function () {
                    return this.sample();
                };
                return NumericalDist;
            }(desmoj.core.dist.Distribution));
            dist.NumericalDist = NumericalDist;
            NumericalDist["__class"] = "desmoj.core.dist.NumericalDist";
        })(dist = core.dist || (core.dist = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
var demos;
(function (demos) {
    var eventsexample;
    (function (eventsexample) {
        /**
         * EventsExample constructor.
         *
         * Creates a new EventsExample model via calling
         * the constructor of the superclass.
         *
         * @param {desmoj.core.simulator.Model} owner the model this model is part of (set to <tt>null</tt> when there is no such model)
         * @param {string} modelName this model's name
         * @param {boolean} showInReport flag to indicate if this model shall produce output to the report file
         * @param {boolean} showInTrace flag to indicate if this model shall produce output to the trace file
         * @class
         * @extends desmoj.core.simulator.Model
         * @author Olaf Neidhardt, Ruth Meyer
         */
        var EventsExample = (function (_super) {
            __extends(EventsExample, _super);
            function EventsExample(owner, modelName, showInReport, showInTrace) {
                var _this = _super.call(this, owner, modelName, showInReport, showInTrace) || this;
                _this.truckArrivalTime = null;
                _this.serviceTime = null;
                _this.truckQueue = null;
                _this.idleVCQueue = null;
                return _this;
            }
            /**
             * Returns a description of the model to be used in the report.
             * @return {string} model description as a string
             */
            EventsExample.prototype.modelDescription = function () {
                return "This model describes a queueing system located at a container terminal. Trucks will arrive and require the loading of a container. A van carrier (VC) is on duty and will head off to find the required container in the storage. It will then load the container onto the truck. Afterwards, the truck leaves the terminal. In case the VC is busy, the truck waits for its turn on the parking-lot. If the VC is idle, it waits on its own parking spot for the truck to come.";
            };
            /**
             * Activates dynamic model components (events).
             *
             * This method is used to place all events or processes on the
             * internal event list of the simulator which are necessary to start
             * the simulation.
             *
             * In this case, the truck generator event will have to be
             * created and scheduled for the start time of the simulation.
             */
            EventsExample.prototype.doInitialSchedules = function () {
                var truckGenerator = new demos.eventsexample.TruckGeneratorEvent(this, "TruckGenerator", true);
                truckGenerator.schedule$desmoj_core_simulator_TimeSpan(new desmoj.core.simulator.TimeSpan(0));
            };
            EventsExample.prototype.init = function (options) {
                if (((options != null && (options["__interfaces"] != null && options["__interfaces"].indexOf("desmoj.core.simulator.ModelOptions") >= 0 || options.constructor != null && options.constructor["__interfaces"] != null && options.constructor["__interfaces"].indexOf("desmoj.core.simulator.ModelOptions") >= 0)) || options === null)) {
                    _super.prototype.init.call(this, options);
                }
                else if (options === undefined) {
                    return this.init$();
                }
                else
                    throw new Error('invalid overload');
            };
            EventsExample.prototype.init$ = function () {
                this.serviceTime = new desmoj.core.dist.ContDistUniform(this, "ServiceTimeStream", 3.0, 7.0, true, false);
                this.truckArrivalTime = new desmoj.core.dist.ContDistExponential(this, "TruckArrivalTimeStream", 3.0, true, false);
                this.truckArrivalTime.setNonNegative(true);
                this.truckQueue = (new desmoj.core.simulator.Queue(this, "Truck Queue", true, true));
                this.idleVCQueue = (new desmoj.core.simulator.Queue(this, "idle VC Queue", true, true));
                var VC;
                for (var i = 0; i < EventsExample.NUM_VC; i++) {
                    VC = new demos.eventsexample.VanCarrier(this, "VanCarrier", true);
                    this.idleVCQueue.insert(VC);
                }
                ;
            };
            /**
             * Returns a sample of the random stream used to determine the
             * time needed to fetch the container for a truck from the
             * storage area and the time the VC needs to load it onto the truck.
             *
             * @return {number} double a serviceTime sample
             */
            EventsExample.prototype.getServiceTime = function () {
                return this.serviceTime.sample();
            };
            /**
             * Returns a sample of the random stream used to determine
             * the next truck arrival time.
             *
             * @return {number} double a truckArrivalTime sample
             */
            EventsExample.prototype.getTruckArrivalTime = function () {
                return this.truckArrivalTime.sample();
            };
            /**
             * Runs the model.
             *
             * In DESMO-J used to
             * - instantiate the experiment
             * - instantiate the model
             * - connect the model to the experiment
             * - steer length of simulation and outputs
             * - set the ending criterion (normally the time)
             * - start the simulation
             * - initiate reporting
             * - clean up the experiment
             *
             * @param {Array} args is an array of command-line arguments (will be ignored here)
             */
            EventsExample.main = function (args) {
                var model = new EventsExample(null, "EventsExample", true, true);
                var exp = new desmoj.core.simulator.Experiment("EventExampleExperiment", def.TimeUnit.SECONDS, def.TimeUnit.MINUTES, null);
                model.connectToExperiment(exp);
                exp.setShowProgressBar(false);
                exp.stop$desmoj_core_simulator_TimeInstant(new desmoj.core.simulator.TimeInstant(1500, def.TimeUnit.MINUTES));
                exp.tracePeriod(new desmoj.core.simulator.TimeInstant(0), new desmoj.core.simulator.TimeInstant(100, def.TimeUnit.MINUTES));
                exp.debugPeriod(new desmoj.core.simulator.TimeInstant(0), new desmoj.core.simulator.TimeInstant(50, def.TimeUnit.MINUTES));
                exp.start();
                exp.report();
                exp.finish();
            };
            return EventsExample;
        }(desmoj.core.simulator.Model));
        /**
         * model parameter: the number of van carriers
         */
        EventsExample.NUM_VC = 2;
        eventsexample.EventsExample = EventsExample;
        EventsExample["__class"] = "demos.eventsexample.EventsExample";
    })(eventsexample = demos.eventsexample || (demos.eventsexample = {}));
})(demos || (demos = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Constructs a simple priority based waiting-queue for entities, the kind
             * of queue sort order and the capacity of the queue can be chosen.
             * Note that since SimProcesses are derived from Entities, they can be
             * queued inside this queue, too.
             * <p>
             * Queues can be sorted as follows:<ul>
             * <li><code>QueueBased.FIFO</code> sorts entities by their priority,
             * highest priority first. Entities with the same priority are
             * enqueued based on &quot;first in, first out&quot;.</li>
             * <li><code>QueueBased.LIFO</code> also sorts entities by their priority,
             * highest priority first. However, entities with the same priority are
             * enqueued based on &quot;last in, first out&quot;.</li>
             * <li><code>QueueBased.Random</code> assigns a random position to each
             * entity entering the queue, disregarding priority.</li>
             * </ul>
             * <p>
             * The usage of the generic version <code>Queue&lt;Type&gt;</code> where
             * <code>Type</code> is derived from <code>Entity</code> is recommended
             * for type safety. Using the raw type <code>Queue</code> yields a queue
             * in which any <code>Entity</code> can be enqueued, typically requiring
             * type casting on accessing entities enqueued.
             *
             * @param {desmoj.core.simulator.Model} owner
             * Model : The model this queue is associated to
             * @param {string} name
             * java.lang.String : The queue's name
             * @param {number} sortOrder
             * int : determines the sort order of the underlying queue
             * implementation. Choose a constant from <code>QueueBased</code>:
             * <code>QueueBased.FIFO</code>, <code>QueueBased.LIFO</code> or
             * QueueBased.Random.
             * @param {number} qCapacity
             * int : The capacity of the Queue, that is how many entities can
             * be enqueued. Zero (0) can be used as shortcut for
             * for a capacity of <code>Integer.MAX_VALUE</code> = 2,147,483,647,
             * which should approximate an infinite queue sufficiently well
             * for most purposes.
             * @param {boolean} showInReport
             * boolean : Flag if queue should produce a report
             * @param {boolean} showInTrace
             * boolean : Flag for queue to produce trace messages
             * @class
             * @extends desmoj.core.simulator.QueueBased
             * @author Tim Lechler
             */
            var Queue = (function (_super) {
                __extends(Queue, _super);
                function Queue(owner, name, sortOrder, qCapacity, showInReport, showInTrace) {
                    var _this = this;
                    if (((owner != null && owner instanceof desmoj.core.simulator.Model) || owner === null) && ((typeof name === 'string') || name === null) && ((typeof sortOrder === 'number') || sortOrder === null) && ((typeof qCapacity === 'number') || qCapacity === null) && ((typeof showInReport === 'boolean') || showInReport === null) && ((typeof showInTrace === 'boolean') || showInTrace === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        _this = _super.call(this, owner, name, showInReport, showInTrace) || this;
                        _this._ql = null;
                        _this._refused = 0;
                        _this._ql = null;
                        _this._refused = 0;
                        (function () {
                            _this.reset();
                            switch ((sortOrder)) {
                                case desmoj.core.simulator.QueueBased.FIFO:
                                    _this._ql = (new desmoj.core.simulator.QueueListFifo());
                                    break;
                                case desmoj.core.simulator.QueueBased.LIFO:
                                    _this._ql = (new desmoj.core.simulator.QueueListLifo());
                                    break;
                                case desmoj.core.simulator.QueueBased.RANDOM:
                                    _this._ql = (new desmoj.core.simulator.QueueListRandom());
                                    break;
                                default:
                                    _this.sendWarning("The given sortOrder parameter " + sortOrder + " is not valid! " + "A queue with Fifo sort order will be created.", "Queue : " + _this.getName() + " Constructor: Queue(Model owner, String name, " + "int sortOrder, long qCapacity, boolean showInReport, " + "boolean showInTrace)", "A valid positive integer number must be provided to determine the sort order of the queue.", "Make sure to provide a valid positive integer number by using the constants in the class QueueBased, like QueueBased.FIFO, QueueBased.LIFO or QueueBased.RANDOM.");
                                    _this._ql = (new desmoj.core.simulator.QueueListFifo());
                            }
                            _this._ql.setQueueBased(_this);
                            _this.queueLimit = qCapacity;
                            if (qCapacity < 0) {
                                _this.sendWarning("The given capacity of the queue is negative! A queue with maximum capacity (2,147,483,647) will be created instead.", "Queue : " + _this.getName() + " Constructor: Queue(Model owner, String name, " + "int sortOrder, long qCapacity, boolean showInReport, " + "boolean showInTrace)", "A negative capacity for a queue does not make sense.", "Make sure to provide a valid positive capacity for the queue.");
                                _this.queueLimit = Number.MAX_VALUE;
                            }
                            if (qCapacity === 0) {
                                _this.queueLimit = Number.MAX_VALUE;
                            }
                        })();
                    }
                    else if (((owner != null && owner instanceof desmoj.core.simulator.Model) || owner === null) && ((typeof name === 'string') || name === null) && ((typeof sortOrder === 'boolean') || sortOrder === null) && ((typeof qCapacity === 'boolean') || qCapacity === null) && showInReport === undefined && showInTrace === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        var showInReport_1 = __args[2];
                        var showInTrace_2 = __args[3];
                        _this = _super.call(this, owner, name, showInReport_1, showInTrace_2) || this;
                        _this._ql = null;
                        _this._refused = 0;
                        _this._ql = null;
                        _this._refused = 0;
                        (function () {
                            _this.reset();
                            _this._ql = (new desmoj.core.simulator.QueueListFifo());
                            _this._ql.setQueueBased(_this);
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                    return _this;
                }
                /**
                 * Returns a special queue reporter to produce a report about this queue.
                 *
                 * @return {desmoj.core.report.Reporter} desmoj.core.report.Reporter : The reporter for this queue
                 */
                Queue.prototype.createDefaultReporter = function () {
                    return new desmoj.core.report.QueueReporter(this);
                };
                Queue.prototype.first$ = function () {
                    return this._ql.first();
                };
                Queue.prototype.first$desmoj_core_simulator_Condition = function (c) {
                    if (c == null) {
                        this.sendWarning("Can not return first entity fulfilling the condition!", "Queue : " + this.getName() + " Method: void first(Condition c)", "The Condition \'c\' given as parameter is a null reference!", "Check to always have valid references when querying Queues.");
                        return null;
                    }
                    if (this._ql.isEmpty())
                        return null;
                    for (var tmp = this._ql.first(); tmp != null; tmp = this._ql.succ(tmp)) {
                        if (c.check(tmp))
                            return tmp;
                    }
                    ;
                    return null;
                };
                /**
                 * Returns the first entity queued in this queue that fulfills the given
                 * condition. The queue is searched from front to end and the first entity
                 * that returns <code>true</code> when the condition is applied to it is
                 * returned by this method. If no Entity fulfills the given condition or the
                 * queue is empty, <code>null</code> will be returned.
                 *
                 * @return {desmoj.core.simulator.Entity} E : The first entity queued in this queue applying to
                 * the given condition or <code>null</code>
                 * @param {desmoj.core.simulator.Condition} c
                 * Condition : The condition that the entity returned must fulfill
                 */
                Queue.prototype.first = function (c) {
                    if (((c != null && c instanceof desmoj.core.simulator.Condition) || c === null)) {
                        return this.first$desmoj_core_simulator_Condition(c);
                    }
                    else if (c === undefined) {
                        return this.first$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns <code>true</code> if the given <code>Entity</code> is
                 * contained in the queue; <code>false</code> otherwise.
                 *
                 * @return {boolean} boolean : <code>True</code> if the given
                 * <code>Entity</code> is contained in the queue;
                 * <code>false</code> otherwise.
                 * @param {desmoj.core.simulator.Entity} e
                 * E : The <code>Entity</code> we are looking for
                 * in the queue.
                 */
                Queue.prototype.contains = function (e) {
                    return this._ql.contains(e);
                };
                /**
                 * Returns the current length of the Queue.
                 *
                 * @return {number} int : The number of entities enqueued.
                 */
                Queue.prototype.size = function () {
                    return this._ql.size();
                };
                Queue.prototype.get$desmoj_core_simulator_Entity = function (e) {
                    return this._ql.get(e);
                };
                /**
                 * Returns the queue index of a given <code>Entity</code>.
                 *
                 * @return {number} int :The position of the entity as an <code>int</code>.
                 * Returns -1 if no such position exists.
                 * @param {desmoj.core.simulator.Entity} e
                 */
                Queue.prototype.get = function (e) {
                    if (((e != null) || e === null)) {
                        return this.get$desmoj_core_simulator_Entity(e);
                    }
                    else if (((typeof e === 'number') || e === null)) {
                        return this.get$int(e);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Queue.prototype.get$int = function (index) {
                    return this._ql.get$int(index);
                };
                /**
                 * Returns the implemented queueing discipline of the underlying queue as a
                 * String, so it can be displayed in the report.
                 *
                 * @return {string} String : The String indicating the queueing discipline.
                 */
                Queue.prototype.getQueueStrategy = function () {
                    return this._ql.getAbbreviation();
                };
                /**
                 * Returns the number of entities refused to be enqueued in the queue.
                 *
                 * @return {number} long : The number of entities refused to be enqueued in the
                 * queue.
                 */
                Queue.prototype.getRefused = function () {
                    return this._refused;
                };
                /**
                 * Enters a new Entity into the queue. If the capacity of the queue is full,
                 * the entity will not be enqueued and <code>false</code> will be
                 * returned. The Entity will be stored in the queue until method
                 * <code>remove(Entity e)</code> is called with this specific Entity.
                 * Entities inside the queue are ordered according to their priority. Higher
                 * priorities are sorted in front of lower priorities. Entities with same
                 * priority are orderer according to the specified strategy. The first
                 * Entity inside the queue will always be the one with the highest priority.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if insertion was successful,
                 * <code>false</code> otherwise (i.e. capacity limit is reached).
                 * @param {desmoj.core.simulator.Entity} e
                 * E : The Entity to be added to the queue.
                 */
                Queue.prototype.insert = function (e) {
                    if (e == null) {
                        this.sendWarning("Can not insert entity into Queue! Command ignored.", "Queue : " + this.getName() + " Method: boolean insert(E e)", "The Entity \'e\' given as parameter is a null reference!", "Check to always have valid references when enqueueing Entities");
                        return false;
                    }
                    if (!this.isModelCompatible(e)) {
                        this.sendWarning("Can not insert entity into Queue! Command ignored.", "Queue : " + this.getName() + " Method: boolean insert" + "(E e)", "The Entity \'e\' (" + e.getQuotedName() + ") given as parameter is not compatible to " + "the model this queue belongs to!", "Check if your submodels are allowed to mingle with other model\'s components.");
                        return false;
                    }
                    if (this.queueLimit <= this.length()) {
                        if (this.currentlySendDebugNotes()) {
                            this.sendDebugNote("refuses to insert " + e.getQuotedName() + " because the " + "capacity limit is reached. Queue:<br>" + this._ql.toString());
                        }
                        if (this.currentlySendTraceNotes()) {
                            this.sendTraceNote("is refused to be enqueued in " + this.getQuotedName() + "because the capacity limit (" + this.getQueueLimit() + ") of this queue is " + "reached");
                        }
                        this._refused++;
                        return false;
                    }
                    this._ql.insert(e);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("inserts " + e.getQuotedName() + " in the queue:<br>" + this._ql.toString());
                    }
                    if (this.currentlySendTraceNotes()) {
                        if (e === this.currentEntity() && this.currentEntityAll().length === 1) {
                            this.sendTraceNote("inserts itself into " + this.getQuotedName());
                        }
                        else {
                            this.sendTraceNote("inserts " + e.getName() + " into " + this.getQuotedName());
                        }
                    }
                    return true;
                };
                /**
                 * Enters a new Entity into the queue and places it after the given Entity.
                 * If the capacity of the queue is full, the entity will not be enqueued and
                 * <code>false</code> will be returned. Make sure that the entity given as
                 * reference is already queued inside the queue, else the entity will not be
                 * enqueued and <code>false</code> will be returned. The Entity will be
                 * stored in the queue until method <code>remove(Entity e)</code> is
                 * called with this specific Entity.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if insertion was successful,
                 * <code>false</code> otherwise (i.e. capacity limit is reached).
                 * @param {desmoj.core.simulator.Entity} e
                 * E : The Entity to be added to the queue
                 * @param {desmoj.core.simulator.Entity} after
                 * E : The Entity after which the entity e is to be inserted
                 */
                Queue.prototype.insertAfter = function (e, after) {
                    if (e == null) {
                        this.sendWarning("Can not insert entity into Queue! Command ignored.", "Queue : " + this.getName() + " Method: boolean insertAfter(E e, E after)", "The Entity \'e\' given as parameter is a null reference!", "Check to always have valid references when enqueueing Entities");
                        return false;
                    }
                    if (after == null) {
                        this.sendWarning("Can not insert entity into Queue! Command ignored.", "Queue : " + this.getName() + " Method: boolean insertAfter(E e, E after)", "The Entity \'after\' given as parameter is a null reference!", "Check to always have valid references when enqueueing Entities");
                        return false;
                    }
                    if (!this.isModelCompatible(e)) {
                        this.sendWarning("Can not insert entity into Queue! Command ignored.", "Queue : " + this.getName() + " Method: boolean insertAfter" + "(E e, E after)", "The Entity \'e\' (" + e.getQuotedName() + ") given as parameter is not compatible to " + "the model this queue belongs to!", "Check if your submodels are allowed to mingle with other model\'s components.");
                        return false;
                    }
                    if (this.queueLimit <= this.length()) {
                        if (this.currentlySendDebugNotes()) {
                            this.sendDebugNote("refuses to insert " + e.getQuotedName() + " because the " + "capacity limit is reached. Queue:<br>" + this._ql.toString());
                        }
                        if (this.currentlySendTraceNotes()) {
                            this.sendTraceNote("is refused to be enqueued in " + this.getQuotedName() + "because the capacity limit (" + this.getQueueLimit() + ") of this queue is " + "reached");
                        }
                        this._refused++;
                        return false;
                    }
                    var successful = this._ql.insertAfter(e, after);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("inserts " + e.getQuotedName() + " after " + after.getQuotedName() + "<br>" + this._ql.toString());
                    }
                    if (this.currentlySendTraceNotes()) {
                        if (e === this.currentEntity() && this.currentEntityAll().length === 1) {
                            this.sendTraceNote("inserts itself into " + this.getQuotedName() + " after " + after.getName());
                        }
                        else {
                            this.sendTraceNote("inserts " + e.getName() + " into " + this.getQuotedName() + " after " + after.getName());
                        }
                    }
                    return successful;
                };
                /**
                 * Enters a new Entity into the queue and places it in front of the given
                 * Entity. If the capacity of the queue is full, the entity will not be
                 * enqueued and <code>false</code> will be returned. Make sure that the
                 * Entity given as reference is already queued inside the queue, else the
                 * Entity will not be queued and <code>false</code> will be returned. The
                 * Entity will be stored in the queue until method
                 * <code>remove(Entity e)</code> is called with this specific Entity.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if insertion was successful,
                 * <code>false</code> otherwise (i.e. capacity limit is reached).
                 * @param {desmoj.core.simulator.Entity} e
                 * E : The Entity to be added to the queue
                 * @param {desmoj.core.simulator.Entity} before
                 * E : The Entity before which the entity e is to be
                 * inserted
                 */
                Queue.prototype.insertBefore = function (e, before) {
                    if (e == null) {
                        this.sendWarning("Can not insert entity into Queue! Command ignored.", "Queue : " + this.getName() + " Method: boolean insertBefore(E e, " + "Entity before)", "The Entity \'e\' given as parameter is a null reference!", "Check to always have valid references when enqueueing Entities");
                        return false;
                    }
                    if (before == null) {
                        this.sendWarning("Can not insert entity into Queue! Command ignored.", "Queue : " + this.getName() + " Method: boolean insertBefore(E e, " + "Entity before)", "The Entity \'before\' given as parameter is a null reference!", "Check to always have valid references when enqueueing Entities");
                        return false;
                    }
                    if (!this.isModelCompatible(e)) {
                        this.sendWarning("Can not insert entity into Queue! Command ignored.", "Queue : " + this.getName() + " Method: boolean insertBefore" + "(E e, Entity before)", "The Entity \'e\' (" + e.getQuotedName() + ") given as parameter is not compatible to " + "the model this queue belongs to!", "Check if your submodels are allowed to mingle with other model\'s components.");
                        return false;
                    }
                    if (this.queueLimit <= this.length()) {
                        if (this.currentlySendDebugNotes()) {
                            this.sendDebugNote("refuses to insert " + e.getQuotedName() + " because the " + "capacity limit is reached. Queue:<br>" + this._ql.toString());
                        }
                        if (this.currentlySendTraceNotes()) {
                            this.sendTraceNote("is refused to be enqueued in " + this.getQuotedName() + "because the capacity limit (" + this.getQueueLimit() + ") of this queue is " + "reached");
                        }
                        this._refused++;
                        return false;
                    }
                    var successful = this._ql.insertBefore(e, before);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("inserts " + e.getQuotedName() + " before " + before.getQuotedName() + "<br>" + this._ql.toString());
                    }
                    if (this.currentlySendTraceNotes()) {
                        if (e === this.currentEntity() && this.currentEntityAll().length === 1) {
                            this.sendTraceNote("inserts itself into " + this.getQuotedName() + " before " + before.getName());
                        }
                        else {
                            this.sendTraceNote("inserts " + e.getName() + " into " + this.getQuotedName() + " before " + before.getName());
                        }
                    }
                    return successful;
                };
                /**
                 * Returns a boolean value indicating if the queue is empty or if any number
                 * of entities is currently enqueued in it.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if the Queue is empty,
                 * <code>false</code> otherwise
                 */
                Queue.prototype.isEmpty = function () {
                    return this._ql.isEmpty();
                };
                Queue.prototype.last$ = function () {
                    return this._ql.last();
                };
                Queue.prototype.last$desmoj_core_simulator_Condition = function (c) {
                    if (c == null) {
                        this.sendWarning("Can not insert entity!", "Queue : " + this.getName() + " Method: Entity last(Condition c)", "The Condition -c- given as parameter is a null reference!", "Check to always have valid references when querying Queues.");
                        return null;
                    }
                    if (this._ql.isEmpty())
                        return null;
                    for (var tmp = this._ql.last(); tmp != null; tmp = this._ql.pred(tmp)) {
                        if (c.check(tmp))
                            return tmp;
                    }
                    ;
                    return null;
                };
                /**
                 * Returns the last Entity queued in this queue that fulfills the given
                 * condition. The queue is searched from end to front and the first entity
                 * that returns <code>true</code> when the condition is applied to it is
                 * returned. If no Entity fulfills the given condition or the queue is
                 * empty, <code>null</code> will be returned.
                 *
                 * @return {desmoj.core.simulator.Entity} E : The last Entity queued in this queue applying to
                 * the given condition or <code>null</code>
                 * @param {desmoj.core.simulator.Condition} c
                 * Condition : The condition that the entity returned must fulfill
                 */
                Queue.prototype.last = function (c) {
                    if (((c != null && c instanceof desmoj.core.simulator.Condition) || c === null)) {
                        return this.last$desmoj_core_simulator_Condition(c);
                    }
                    else if (c === undefined) {
                        return this.last$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                Queue.prototype.pred$desmoj_core_simulator_Entity = function (e) {
                    if (e == null) {
                        this.sendWarning("Can not find predecessor of Entity in Queue!", "Queue : " + this.getName() + " Method: Entity pred(E e)", "The Entity \'e\' given as parameter is a null reference!", "Check to always have valid references when querying for Entities");
                        return null;
                    }
                    return this._ql.pred(e);
                };
                Queue.prototype.pred$desmoj_core_simulator_Entity$desmoj_core_simulator_Condition = function (e, c) {
                    if (e == null) {
                        this.sendWarning("Can not find predecessor of Entity in Queue!", "Queue : " + this.getName() + " Method: Entity pred(E e, Condition c)", "The Entity \'e\' given as parameter is a null reference!", "Check to always have valid references when querying for Entities");
                        return null;
                    }
                    if (c == null) {
                        this.sendWarning("Can not return previous Entity fulfilling the condition!", "Queue : " + this.getName() + " Method: Entity pred(E e, Condition c)", "The Condition \'c\' given as parameter is a null reference!", "Check to always have valid references when querying Queues.");
                        return null;
                    }
                    for (var tmp = this.pred(e); tmp != null; tmp = this.pred(tmp)) {
                        if (c.check(tmp))
                            return tmp;
                    }
                    ;
                    return null;
                };
                /**
                 * Returns the entity enqueued before the given Entity in the queue that
                 * also fulfills the condition given. If the given Entity is not
                 * contained in this queue or is at the first position thus having no
                 * possible predecessor, <code>null</code> is returned. If no other Entity
                 * before the given one fulfills the condition, <code>null</code> is
                 * returned, too.
                 *
                 * @return {desmoj.core.simulator.Entity} E : The Entity before the given Entity in the queue
                 * fulfilling the condition or <code>null</code>.
                 * @param {desmoj.core.simulator.Entity} e
                 * E : An Entity in the queue
                 * @param {desmoj.core.simulator.Condition} c
                 * Condition : The condition that the preceeding Entity has to
                 * fulfill
                 */
                Queue.prototype.pred = function (e, c) {
                    if (((e != null) || e === null) && ((c != null && c instanceof desmoj.core.simulator.Condition) || c === null)) {
                        return this.pred$desmoj_core_simulator_Entity$desmoj_core_simulator_Condition(e, c);
                    }
                    else if (((e != null) || e === null) && c === undefined) {
                        return this.pred$desmoj_core_simulator_Entity(e);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Queue.prototype.remove$desmoj_core_simulator_Entity = function (e) {
                    if (e == null) {
                        this.sendWarning("Can not remove Entity from Queue!", "Queue : " + this.getName() + " Method:  void remove(Entity e)", "The Entity \'e\' given as parameter is a null reference!", "Check to always have valid references when removing Entities");
                        return;
                    }
                    if (!this._ql.remove(e)) {
                        this.sendWarning("Can not remove Entity from Queue!", "Queue : " + this.getName() + " Method:  void remove(Entity e)", "The Entity \'e\' (" + e.getQuotedName() + ") given as parameter is not enqueued in this " + "queue!", "Make sure the entity is inside the queue you want it to be removed.");
                        return;
                    }
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("remove " + e.getQuotedName() + "<br>" + this._ql.toString());
                    }
                    if (this.currentlySendTraceNotes()) {
                        if (e === this.currentEntity() && this.currentEntityAll().length === 1) {
                            this.sendTraceNote("removes itself from " + this.getQuotedName());
                        }
                        else {
                            this.sendTraceNote("removes " + e.getQuotedName() + " from " + this.getQuotedName());
                        }
                    }
                };
                /**
                 * Removes the given Entity from the Queue. If the given Entity is not in
                 * the Queue, a warning will be issued but nothing else will be changed.
                 *
                 * @param {desmoj.core.simulator.Entity} e
                 * Entity : The Entity to be removed
                 */
                Queue.prototype.remove = function (e) {
                    if (((e != null && e instanceof desmoj.core.simulator.Entity) || e === null)) {
                        return this.remove$desmoj_core_simulator_Entity(e);
                    }
                    else if (((typeof e === 'number') || e === null)) {
                        return this.remove$int(e);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the waiting time of an entity present in the queue.
                 * If the entity given is not queued, <code>null</code> will be returned.
                 *
                 * @param {desmoj.core.simulator.Entity} e
                 * Entity : The entity whose waiting time is looked for
                 *
                 * @return {desmoj.core.simulator.TimeSpan} TimeSpan : The waiting time of the entity or <code>null</code>.
                 */
                Queue.prototype.getCurrentWaitTime = function (e) {
                    if (e == null) {
                        this.sendWarning("Cannot query waiting time!", "Queue : " + this.getName() + " Method:  void getCurrentWaitTime(Entity e)", "The Entity \'e\' given as parameter is a null reference!", "Check to always have valid references when queryingwaiting durations");
                        return null;
                    }
                    var i = (function (m, k) { if (m.entries == null)
                        m.entries = []; for (var i_2 = 0; i_2 < m.entries.length; i_2++)
                        if (m.entries[i_2].key.equals != null && m.entries[i_2].key.equals(k) || m.entries[i_2].key === k) {
                            return m.entries[i_2].value;
                        } return null; })(this._ql.timemap, e);
                    if (i == null) {
                        this.sendWarning("Cannot query waiting time!", "Queue : " + this.getName() + " Method:  void getCurrentWaitTime(Entity e)", "The Entity \'e\' (" + e.getQuotedName() + ") given as parameter is not enqueued in this " + "queue!", "Make sure the entity is inside the queue you want it to be queried.");
                        return null;
                    }
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("remove " + e.getQuotedName() + "<br>" + this._ql.toString());
                    }
                    return desmoj.core.simulator.TimeOperations.diff$desmoj_core_simulator_TimeInstant$desmoj_core_simulator_TimeInstant(this.presentTime(), i);
                };
                /**
                 * Removes all entities from the Queue. Has no effect on empty queues.
                 */
                Queue.prototype.removeAll = function () {
                    while ((!this.isEmpty())) {
                        this.removeFirst();
                    }
                    ;
                };
                Queue.prototype.removeFirst$ = function () {
                    var first = this.first();
                    if (first != null) {
                        this._ql.remove(first);
                        if (this.currentlySendTraceNotes()) {
                            if (first === this.currentEntity() && this.currentEntityAll().length === 1) {
                                this.sendTraceNote("removes itself from " + this.getQuotedName());
                            }
                            else {
                                this.sendTraceNote("removes " + first.getQuotedName() + " from " + this.getQuotedName());
                            }
                        }
                    }
                    return first;
                };
                Queue.prototype.removeFirst$desmoj_core_simulator_Condition = function (c) {
                    if (c == null) {
                        this.sendWarning("Can not remove the first entity fulfilling a condition!", "Queue : " + this.getName() + " Method: void removeFirst(Condition c)", "The Condition \'c\' given as parameter is a null reference!", "Check to always have valid references when querying Queues.");
                        return null;
                    }
                    var first = this.first$desmoj_core_simulator_Condition(c);
                    if (first != null) {
                        this._ql.remove(first);
                        if (this.currentlySendTraceNotes()) {
                            if (first === this.currentEntity() && this.currentEntityAll().length === 1) {
                                this.sendTraceNote("removes itself from " + this.getQuotedName());
                            }
                            else {
                                this.sendTraceNote("removes " + first.getQuotedName() + " from " + this.getQuotedName());
                            }
                        }
                    }
                    return first;
                };
                /**
                 * Removes the first entity from the queue that fulfills the given
                 * condition. Also provides a reference to this entity.
                 * If the queue does not contain an entity that fulfills the condition
                 * (e.g. if the queue is empty), <code>null</code> is returned.
                 *
                 * @param {desmoj.core.simulator.Condition} c
                 * Condition : The condition that the entity returned must fulfill
                 *
                 * @return {desmoj.core.simulator.Entity} E : The first entity in this queue fulfilling the condition, which
                 * has been removed from the queue. <code>Null</code> in case no entity
                 * fulfills the condition.
                 */
                Queue.prototype.removeFirst = function (c) {
                    if (((c != null && c instanceof desmoj.core.simulator.Condition) || c === null)) {
                        return this.removeFirst$desmoj_core_simulator_Condition(c);
                    }
                    else if (c === undefined) {
                        return this.removeFirst$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                Queue.prototype.removeLast$ = function () {
                    var last = this.last();
                    if (last != null) {
                        this._ql.remove(last);
                        if (this.currentlySendTraceNotes()) {
                            if (last === this.currentEntity() && this.currentEntityAll().length === 1) {
                                this.sendTraceNote("removes itself from " + this.getQuotedName());
                            }
                            else {
                                this.sendTraceNote("removes " + last.getQuotedName() + " from " + this.getQuotedName());
                            }
                        }
                    }
                    return last;
                };
                Queue.prototype.removeLast$desmoj_core_simulator_Condition = function (c) {
                    if (c == null) {
                        this.sendWarning("Can not remove the last entity fulfilling a condition!", "Queue : " + this.getName() + " Method: void removeLast(Condition c)", "The Condition \'c\' given as parameter is a null reference!", "Check to always have valid references when querying Queues.");
                        return null;
                    }
                    var last = this.last$desmoj_core_simulator_Condition(c);
                    if (last != null) {
                        this._ql.remove(last);
                        if (this.currentlySendTraceNotes()) {
                            if (last === this.currentEntity() && this.currentEntityAll().length === 1) {
                                this.sendTraceNote("removes itself from " + this.getQuotedName());
                            }
                            else {
                                this.sendTraceNote("removes " + last.getQuotedName() + " from " + this.getQuotedName());
                            }
                        }
                    }
                    return last;
                };
                /**
                 * Removes the last entity from the queue that fulfills to the given
                 * condition, determined by traversing the queue from last to first until
                 * an entity fulfilling the condition is found. Also provides a reference
                 * to this entity. If the queue does not contain an entity that fulfills
                 * the condition (e.g. if the queue is empty), <code>null</code> is returned.
                 *
                 * @param {desmoj.core.simulator.Condition} c
                 * Condition : The condition that the entity returned must fulfill
                 *
                 * @return {desmoj.core.simulator.Entity} E : The last entity in this queue fulfilling the condition, which
                 * has been removed from the queue. <code>Null</code> in case no entity
                 * fulfills the condition.
                 */
                Queue.prototype.removeLast = function (c) {
                    if (((c != null && c instanceof desmoj.core.simulator.Condition) || c === null)) {
                        return this.removeLast$desmoj_core_simulator_Condition(c);
                    }
                    else if (c === undefined) {
                        return this.removeLast$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                Queue.prototype.remove$int = function (index) {
                    if (index < 0 || index >= this.length())
                        return false;
                    var e = this.get$int(index);
                    if (e == null) {
                        return false;
                    }
                    else {
                        this.remove$desmoj_core_simulator_Entity(e);
                        return true;
                    }
                };
                Queue.prototype.reset = function (newSeed) {
                    if (newSeed === undefined) {
                        return this.reset$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                Queue.prototype.reset$ = function () {
                    _super.prototype.reset.call(this);
                    this._refused = 0;
                };
                /**
                 * Sets the sort order of this Queue to a new value and makes this
                 * Queue use another <code>QueueList</code> with the specified
                 * queueing discipline. Please choose a constant from
                 * <code>QueueBased</code> (<code>QueueBased.FIFO</code>,
                 * <code>QueueBased.FIFO</code> or <code>QueueBased.Random</code>)
                 * The sort order of a Queue can only be changed if the queue is empty.
                 *
                 * @param {number} sortOrder
                 * int : determines the sort order of the underlying
                 * <code>QueueList</code> implementation (<code>QueueBased.FIFO</code>,
                 * <code>QueueBased.FIFO</code> or <code>QueueBased.Random</code>)
                 */
                Queue.prototype.setQueueStrategy = function (sortOrder) {
                    if (!this.isEmpty()) {
                        this.sendWarning("The Queue for which the queueing discipline should be changed is not empty. The queueing discipline will remain unchanged!", /* getName */ (function (c) { return c["__class"] ? c["__class"] : c["name"]; })(this.constructor) + ": " + this.getQuotedName() + ", Method: " + "void setQueueStrategy(int sortOrder)", "The Queue already contains some entities ordered according a certain order.", "Make sure to change the sort order only for an empty ProcessQueue.");
                        return;
                    }
                    switch ((sortOrder)) {
                        case desmoj.core.simulator.QueueBased.FIFO:
                            this._ql = (new desmoj.core.simulator.QueueListFifo());
                            break;
                        case desmoj.core.simulator.QueueBased.LIFO:
                            this._ql = (new desmoj.core.simulator.QueueListLifo());
                            break;
                        case desmoj.core.simulator.QueueBased.RANDOM:
                            this._ql = (new desmoj.core.simulator.QueueListRandom());
                            break;
                        default:
                            this.sendWarning("The given sortOrder parameter is negative or too big! The sort order of the ProcessQueue will remain unchanged!", /* getName */ (function (c) { return c["__class"] ? c["__class"] : c["name"]; })(this.constructor) + ": " + this.getQuotedName() + ", Method: " + "void setQueueStrategy(int sortOrder)", "A valid positive integer number must be provided to determine the sort order of the queue.", "Make sure to provide a valid positive integer number by using the constants in the class QueueBased, like QueueBased.FIFO, QueueBased.LIFO or QueueBased.RANDOM.");
                            return;
                    }
                    this._ql.setQueueBased(this);
                };
                Queue.prototype.succ$desmoj_core_simulator_Entity = function (e) {
                    if (e == null) {
                        this.sendWarning("Can not find successor of Entity in Queue!", "Queue : " + this.getName() + " Method: Entity succ(E e)", "The Entity \'e\' given as parameter is a null reference!", "Check to always have valid references when querying for Entities");
                        return null;
                    }
                    return this._ql.succ(e);
                };
                Queue.prototype.succ$desmoj_core_simulator_Entity$desmoj_core_simulator_Condition = function (e, c) {
                    if (e == null) {
                        this.sendWarning("Can not find predecessor of Entity in Queue!", "Queue : " + this.getName() + " Method: Entity succ(E e, Condition c)", "The Entity \'e\' given as parameter is a null reference!", "Check to always have valid references when querying for Entities");
                        return null;
                    }
                    if (c == null) {
                        this.sendWarning("Can not return previous Entity fulfilling the condition!", "Queue : " + this.getName() + " Method: Entity succ(E e, Condition c)", "The Condition \'c\' given as parameter is a null reference!", "Check to always have valid references when querying Queues.");
                        return null;
                    }
                    for (var tmp = this.succ(e); tmp != null; tmp = this.succ(tmp)) {
                        if (c.check(tmp))
                            return tmp;
                    }
                    ;
                    return null;
                };
                /**
                 * Returns the entity enqueued after the given Entity in the queue that also
                 * fulfills the condition given. If the given Entity is not contained in
                 * this queue or is at the last position thus having no possible successor,
                 * <code>null</code> is returned. If no other Entity after the given one
                 * fulfills the condition, <code>null</code> is returned, too.
                 *
                 * @return {desmoj.core.simulator.Entity} E : The Entity after the given Entity in the queue
                 * fulfilling the condition or <code>null</code>.
                 * @param {desmoj.core.simulator.Entity} e
                 * E : An Entity in the queue
                 * @param {desmoj.core.simulator.Condition} c
                 * Condition : The condition that the succeeding Entity has to
                 * fulfill
                 */
                Queue.prototype.succ = function (e, c) {
                    if (((e != null) || e === null) && ((c != null && c instanceof desmoj.core.simulator.Condition) || c === null)) {
                        return this.succ$desmoj_core_simulator_Entity$desmoj_core_simulator_Condition(e, c);
                    }
                    else if (((e != null) || e === null) && c === undefined) {
                        return this.succ$desmoj_core_simulator_Entity(e);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Returns the underlying queue implementation, providing access to the
                 * QueueList implementation, e.g. to add PropertyChangeListeners.
                 *
                 * @return {desmoj.core.simulator.QueueList} QueueList : The underlying queue implementation of this Queue.
                 */
                Queue.prototype.getQueueList = function () {
                    return this._ql;
                };
                /**
                 * Sets the seed of the underlying queue list's pseudo random number generator.
                 * Useful for queues with random sort order only; to other queues, calling
                 * this method has no effect, resulting in a warning.
                 *
                 * @param {number} newSeed
                 * long : new seed of the underlying queue list's pseudo
                 * random number generator
                 */
                Queue.prototype.setSeed = function (newSeed) {
                    if (this._ql != null && this._ql instanceof desmoj.core.simulator.QueueListRandom) {
                        this._ql.setSeed(newSeed);
                    }
                    else {
                        this.sendWarning("Cannot set seed of queue!", "Queue : " + this.getName() + " Method: setSeed(long newSeed)", "The queue does not randomize entries.", "Make sure to call setSeed(long newSeed) on queues with <tt>sortOrder == QueueBased.RANDOM</tt> only.");
                    }
                };
                /**
                 * Returns an iterator over the entities enqueued.
                 *
                 * @return {*} java.lang.Iterator&lt;E&gt; : An iterator over the entities enqueued.
                 */
                Queue.prototype.iterator = function () {
                    return new Queue.QueueIterator(this, this);
                };
                return Queue;
            }(desmoj.core.simulator.QueueBased));
            simulator.Queue = Queue;
            Queue["__class"] = "desmoj.core.simulator.Queue";
            Queue["__interfaces"] = ["desmoj.core.observer.Subject", "java.lang.Iterable"];
            (function (Queue) {
                /**
                 * Private queue iterator, e.g. required for processing all queue elements in a
                 * for-each-loop.
                 * @param {desmoj.core.simulator.Queue} clientQ
                 * @class
                 */
                var QueueIterator = (function () {
                    function QueueIterator(__parent, clientQ) {
                        this.__parent = __parent;
                        this.clientQ = null;
                        this.__next = null;
                        this.lastReturned = null;
                        this.clientQ = clientQ;
                        this.__next = clientQ.first();
                        this.lastReturned = null;
                    }
                    QueueIterator.prototype.hasNext = function () {
                        return this.__next != null;
                    };
                    QueueIterator.prototype.next = function () {
                        this.lastReturned = this.__next;
                        this.__next = this.clientQ.succ(this.__next);
                        return this.lastReturned;
                    };
                    QueueIterator.prototype.remove = function () {
                        this.clientQ.remove$desmoj_core_simulator_Entity(this.lastReturned);
                    };
                    return QueueIterator;
                }());
                Queue.QueueIterator = QueueIterator;
                QueueIterator["__class"] = "desmoj.core.simulator.Queue.QueueIterator";
                QueueIterator["__interfaces"] = ["java.util.Iterator"];
            })(Queue = simulator.Queue || (simulator.Queue = {}));
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Represents the superclass for all entities of a model. Entities are supposed
             * to be scheduled together with a compatible event at a certain point of
             * simulation time or relative to another event in present or future simulation
             * time.
             * <p>
             * Entities typically encapsulate all information about a model entity
             * relevant to the modeller. Events can manipulate these informations when the
             * scheduled point of simulation time is reached and thus change the state of
             * the model. When modelling different types of entities you need to derive
             * different classes from this superclass. Each carrying the specific
             * information to represent its counterpart in the system modelled. Thus a
             * simulation of e.g. a factory would require both machines and material to be
             * subclasses of class <code>Entity</code>. They can act on each other by
             * scheduling themselves or other Entities with the appropriate events. To use
             * more than one entity of one type, create multiple instances of the same
             * <code>Entity</code> class.
             * For better identification, all instances created from a subclass of class
             * <code>NamedObject</code> (just as <code>Entity</code> is) get an individual
             * identification number as a suffix to their name so there is no need to name
             * each individual differently yourself.
             * <p>
             * Entities can carry a queuing priority that can be modified after the entity
             * has been instantiated, applied for inserting Entities into any kind of Queues:
             * The entity's priority determines it's position inside the queue on entering
             * it. Although within a model all attributes of an entity could be made public
             * it is advisable to support data hiding by providing methods for accessing the
             * internal attributes, as always in oo-design.
             *
             * @see Event
             * @see SimProcess
             * @see NamedObject
             *
             * @version DESMO-J, Ver. 2.5.1e copyright (c) 2017
             * @author Tim Lechler, modified by Justin Neumann
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License. You
             * may obtain a copy of the License at
             * http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS"
             * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
             * or implied. See the License for the specific language governing
             * permissions and limitations under the License.
             * @param {desmoj.core.simulator.Model} owner
             * @param {string} name
             * @param {boolean} showInTrace
             * @class
             * @extends desmoj.core.simulator.Schedulable
             */
            var Entity = (function (_super) {
                __extends(Entity, _super);
                function Entity(owner, name, showInTrace) {
                    var _this = _super.call(this, owner, name, showInTrace) || this;
                    _this._myQueuingPriority = 0;
                    _this._myQueues = null;
                    _this._identNumber = 0;
                    _this._myQueuingPriority = 0;
                    _this._myQueues = ([]);
                    _this._identNumber = owner.linkWithIdentNumber(_this);
                    return _this;
                }
                /**
                 * Returns a list of events associated to this Entity object. If the
                 * Entity object is not currently scheduled, an empty list will be
                 * returned. Remind that all different Event classes can be included.
                 *
                 * @return {desmoj.core.simulator.EventAbstract[]} List<EventAbstract> : The events associated to the entity
                 */
                Entity.prototype.getScheduledEvents = function () {
                    var list = ([]);
                    for (var index800 = 0; index800 < this._schedule.length; index800++) {
                        var note = this._schedule[index800];
                        {
                            /* add */ (list.push(note.getEvent()) > 0);
                        }
                    }
                    return list;
                };
                /**
                 * Returns the entity's identification number.
                 *
                 * @return {number} Long : The entity's identification number
                 */
                Entity.prototype.getIdentNumber = function () {
                    return this._identNumber;
                };
                /**
                 * Returns the entity's queuing priority. Default priority of an entity is zero.
                 * Higher priorities are positive, lower priorities negative.
                 *
                 * @return {number} int : The entity's priority
                 */
                Entity.prototype.getQueueingPriority = function () {
                    return this._myQueuingPriority;
                };
                /**
                 * Returns a list of queues and other <code>QueueBased</code> objects where this <code>Entity</code> is queued.
                 *
                 * @return {desmoj.core.simulator.QueueBased[]} List<QueueBased> : The <code>QueueBased</code>s containing this entity; may be empty if entity is not queued.
                 */
                Entity.prototype.getQueues = function () {
                    return (this._myQueues.slice(0));
                };
                /**
                 * Tests if this <code>Entity</code> queued in a at least one queue or other <code>QueueBased</code>.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if this Entity is queued in at least one queue or other <code>QueueBased</code>,
                 * <code>false</code> otherwise.
                 */
                Entity.prototype.isQueued = function () {
                    return !(this._myQueues.length == 0);
                };
                /**
                 * Checks if the two entities have the same priority. Note that this is a
                 * static method available through calling the entity's class i.e.
                 * <code>Entity.isEqual(a,b)</code> where <code>a</code> and <code>b</code>
                 * are valid Entity objects.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if <code>a</code> has the same
                 * priority as <code>b</code>,<code>/false</code> otherwise
                 * @param {desmoj.core.simulator.Entity} a
                 * Entity : First comparand entity
                 * @param {desmoj.core.simulator.Entity} b
                 * Entity : Second comparand entity
                 */
                Entity.isEqual = function (a, b) {
                    if (a == null || b == null) {
                        return false;
                    }
                    return (a.getQueueingPriority() === b.getQueueingPriority());
                };
                /**
                 * Checks if the first of the two entities has a higher priority than the
                 * second. Note that this is a static method available through calling the
                 * entity's class i.e. <code>Entity.isLarger(a,b)</code> where a and b are
                 * valid Entity objects.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if <code>a</code> has a larger
                 * priority than <code>b</code>,<code>/false</code> otherwise
                 * @param {desmoj.core.simulator.Entity} a
                 * Entity : First comparand entity
                 * @param {desmoj.core.simulator.Entity} b
                 * Entity : Second comparand entity
                 */
                Entity.isLarger = function (a, b) {
                    if (a == null || b == null) {
                        return false;
                    }
                    return (a.getQueueingPriority() > b.getQueueingPriority());
                };
                /**
                 * Checks if the first of the two entities has higher or same priority than
                 * the second. Note that this is a static method available through calling
                 * the entity's class i.e. <code>Entity.isLargerOrEqual(a,b)</code> where a
                 * and b are valid Entity objects.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if <code>a</code> has a larger or
                 * equal priority than <code>b</code>,<code>/false</code> otherwise
                 * @param {desmoj.core.simulator.Entity} a
                 * Entity : First comparand entity
                 * @param {desmoj.core.simulator.Entity} b
                 * Entity : Second comparand entity
                 */
                Entity.isLargerOrEqual = function (a, b) {
                    if (a == null || b == null) {
                        return false;
                    }
                    return (a.getQueueingPriority() >= b.getQueueingPriority());
                };
                /**
                 * Checks if the first of the two entities have different priorities. Note
                 * that this is a static method available through calling the entity's class
                 * i.e. <code>Entity.isNotEqual(a,b)</code> where a and b are valid Entity
                 * objects.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if <code>a</code> has a different
                 * priority than <code>b</code>,<code>/false</code> otherwise
                 * @param {desmoj.core.simulator.Entity} a
                 * Entity : First comparand entity
                 * @param {desmoj.core.simulator.Entity} b
                 * Entity : Second comparand entity
                 */
                Entity.isNotEqual = function (a, b) {
                    if (a == null || b == null) {
                        return false;
                    }
                    return (a.getQueueingPriority() !== b.getQueueingPriority());
                };
                /**
                 * Checks if the first of the two entities has a lower priority than the
                 * second. Note that this is a static method available through calling the
                 * entity's class i.e. <code>Entity.isSmaller(a,b)</code> where a and b are
                 * valid Entity objects.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if <code>a</code> has a lower
                 * priority than <code>b</code>,<code>/false</code> otherwise
                 * @param {desmoj.core.simulator.Entity} a
                 * Entity : First comparand entity
                 * @param {desmoj.core.simulator.Entity} b
                 * Entity : Second comparand entity
                 */
                Entity.isSmaller = function (a, b) {
                    if (a == null || b == null) {
                        return false;
                    }
                    return (a.getQueueingPriority() < b.getQueueingPriority());
                };
                /**
                 * Checks if the first of the two entities has lower or same priority than
                 * the second. Note that this is a static method available through calling
                 * the entity's class i.e. <code>Entity.isSmallerOrEqual(a,b)</code> where a
                 * and b are valid Entity objects.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if <code>a</code> has a smaller or
                 * equal priority than <code>b</code>, <code>/false</code> otherwise
                 * @param {desmoj.core.simulator.Entity} a
                 * Entity : First comparand entity
                 * @param {desmoj.core.simulator.Entity} b
                 * Entity : Second comparand entity
                 */
                Entity.isSmallerOrEqual = function (a, b) {
                    if (a == null || b == null) {
                        return false;
                    }
                    return (a.getQueueingPriority() <= b.getQueueingPriority());
                };
                Entity.prototype.schedule$desmoj_core_simulator_Event$desmoj_core_simulator_TimeInstant = function (what, when) {
                    if ((when == null)) {
                        this.sendWarning("Can\'t schedule Entity!", "Entity : " + this.getName() + " Method: schedule(Event what, TimeInstant when)", "The simulation time given as parameter is a null reference.", "Be sure to have a valid simulation time reference before calling this method.");
                        return;
                    }
                    if ((what == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: schedule(Event what, TimeInstant when)", "The Event given as parameter is a null reference.", "Be sure to have a valid Event reference for this event to be scheduled with.");
                        return;
                    }
                    if (!this.isModelCompatible(what)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored", "Entity : " + this.getName() + " Method: schedule(Event what, TimeInstant when)", "The Event to be scheduled with this Entity is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    this.generateTraceForScheduling(what, null, null, null, null, when, null);
                    this.getModel().getExperiment().getScheduler().scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_EventAbstract$desmoj_core_simulator_TimeInstant(this, what, when);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("schedules on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                Entity.prototype.schedule$desmoj_core_simulator_Event$desmoj_core_simulator_TimeSpan = function (what, dt) {
                    if ((dt == null)) {
                        this.sendWarning("Can\'t schedule Entity!", "Entity : " + this.getName() + " Method: schedule(Event what, TimeSpan dt)", "The simulation time given as parameter is a null reference.", "Be sure to have a valid simulation time reference before calling this method.");
                        return;
                    }
                    if ((what == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: schedule(Event what, TimeSpan dt)", "The Event given as parameter is a null reference.", "Be sure to have a valid Event reference for this event to be scheduled with.");
                        return;
                    }
                    if (!this.isModelCompatible(what)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored", "Entity : " + this.getName() + " Method: schedule(Event what, TimeSpan dt)", "The Event to be scheduled with this Entity is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    this.generateTraceForScheduling(what, null, null, null, null, desmoj.core.simulator.TimeOperations.add$desmoj_core_simulator_TimeInstant$desmoj_core_simulator_TimeSpan(this.presentTime(), dt), null);
                    this.getModel().getExperiment().getScheduler().scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_EventAbstract$desmoj_core_simulator_TimeSpan(this, what, dt);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("schedules on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                Entity.prototype.schedule$desmoj_core_simulator_Event = function (what) {
                    if ((what == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: schedule(Event what)", "The Event given as parameter is a null reference.", "Be sure to have a valid Event reference for this event to be scheduled with.");
                        return;
                    }
                    if (!this.isModelCompatible(what)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored", "Entity : " + this.getName() + " Method: schedule(Event what)", "The Event to be scheduled with this Entity is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    this.generateTraceForScheduling(what, null, null, null, null, this.presentTime(), null);
                    this.getModel().getExperiment().getScheduler().scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_EventAbstract$desmoj_core_simulator_TimeInstant(this, what, this.presentTime());
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("schedules on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                Entity.prototype.schedule$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf2Entities$desmoj_core_simulator_TimeInstant = function (who2, what, when) {
                    if ((who2 == null)) {
                        this.sendWarning("Can\'t schedule Entity!", "Entity : " + this.getName() + " Method: <E extends Entity> schedule(E who2, EventOf2Entities<?, E> what, TimeInstant when)", "The Entity \'who2\' given as parameter is a null reference.", "Be sure to have a valid Entity reference before calling this method.");
                        return;
                    }
                    if ((when == null)) {
                        this.sendWarning("Can\'t schedule Entity!", "Entity : " + this.getName() + " Method: <E extends Entity> schedule(E who2, EventOf2Entities<?, E> what, TimeInstant when)", "The simulation time given as parameter is a null reference.", "Be sure to have a valid simulation time reference before calling this method.");
                        return;
                    }
                    if ((what == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: <E extends Entity> schedule(E who2, EventOf2Entities<?, E> what, TimeInstant when)", "The EventOf2Entities given as parameter is a null reference.", "Be sure to have a valid EventOf2Entities reference for this event to be scheduled with.");
                        return;
                    }
                    if (!this.isModelCompatible(what)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored", "Entity : " + this.getName() + " Method: <E extends Entity> schedule(E who2, EventOf2Entities<?, E> what, TimeInstant when)", "The EventOf2Entities to be scheduled with this Entity is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    this.generateTraceForScheduling(what, who2, null, null, null, when, null);
                    this.getModel().getExperiment().getScheduler().scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf2Entities$desmoj_core_simulator_TimeInstant(this, who2, what, when);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("schedules on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                Entity.prototype.schedule$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf2Entities$desmoj_core_simulator_TimeSpan = function (who2, what, dt) {
                    if ((who2 == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: <E extends Entity> schedule(E who2, EventOf2Entities<?, E> what, TimeSpan dt) {", "The Entity \'who2\' given as parameter is a null reference.", "Be sure to have a valid Entity reference for this event to be scheduled with.");
                        return;
                    }
                    if ((dt == null)) {
                        this.sendWarning("Can\'t schedule Entity!", "Entity : " + this.getName() + this.getName() + " Method: <E extends Entity> schedule(E who2, EventOf2Entities<?, E> what, TimeSpan dt) {", "The simulation time given as parameter is a null reference.", "Be sure to have a valid simulation time reference before calling this method.");
                        return;
                    }
                    if ((what == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: <E extends Entity> schedule(E who2, EventOf2Entities<?, E> what, TimeSpan dt) {", "The EventOf2Entities given as parameter is a null reference.", "Be sure to have a valid EventOf2Entities reference for this event to be scheduled with.");
                        return;
                    }
                    if (!this.isModelCompatible(what)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored", "Entity : " + this.getName() + " Method: <E extends Entity> schedule(E who2, EventOf2Entities<?, E> what, TimeSpan dt) {", "The EventOf2Entities to be scheduled with this Entity is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    this.generateTraceForScheduling(what, who2, null, null, null, desmoj.core.simulator.TimeOperations.add$desmoj_core_simulator_TimeInstant$desmoj_core_simulator_TimeSpan(this.presentTime(), dt), null);
                    this.getModel().getExperiment().getScheduler().scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf2Entities$desmoj_core_simulator_TimeSpan(this, who2, what, dt);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("schedules on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                Entity.prototype.schedule$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf2Entities = function (who2, what) {
                    if ((who2 == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: <E extends Entity> schedule(E who2, EventOf2Entities<?, E> what) {", "The Entity \'who2\' given as parameter is a null reference.", "Be sure to have a valid Entity reference for this event to be scheduled with.");
                        return;
                    }
                    if ((what == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: <E extends Entity> schedule(E who2, EventOf2Entities<?, E> what) {", "The EventOf2Entities given as parameter is a null reference.", "Be sure to have a valid EventOf2Entities reference for this event to be scheduled with.");
                        return;
                    }
                    if (!this.isModelCompatible(what)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored", "Entity : " + this.getName() + " Method: <E extends Entity> schedule(E who2, EventOf2Entities<?, E> what) {", "The EventOf2Entities to be scheduled with this Entity is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    this.generateTraceForScheduling(what, who2, null, null, null, this.presentTime(), null);
                    this.getModel().getExperiment().getScheduler().scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf2Entities$desmoj_core_simulator_TimeInstant(this, who2, what, this.presentTime());
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("schedules on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                Entity.prototype.schedule$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf3Entities$desmoj_core_simulator_TimeInstant = function (who2, who3, what, when) {
                    if ((who2 == null)) {
                        this.sendWarning("Can\'t schedule Entity!", "Entity : " + this.getName() + " Method: <E extends Entity,F extends Entity> schedule(E who2, F who3, EventOf3Entities<?, E, F> what, TimeInstant when) {", "The Entity \'who2\' given as parameter is a null reference.", "Be sure to have a valid Entity reference before calling this method.");
                        return;
                    }
                    if ((who3 == null)) {
                        this.sendWarning("Can\'t schedule Entity!", "Entity : " + this.getName() + " Method: <E extends Entity,F extends Entity> schedule(E who2, F who3, EventOf3Entities<?, E, F> what, TimeInstant when) {", "The Entity \'who3\' given as parameter is a null reference.", "Be sure to have a valid Entity reference before calling this method.");
                        return;
                    }
                    if ((when == null)) {
                        this.sendWarning("Can\'t schedule Entity!", "Entity : " + this.getName() + " Method: <E extends Entity,F extends Entity> schedule(E who2, F who3, EventOf3Entities<?, E, F> what, TimeInstant when) {", "The simulation time given as parameter is a null reference.", "Be sure to have a valid simulation time reference before calling this method.");
                        return;
                    }
                    if ((what == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: <E extends Entity,F extends Entity> schedule(E who2, F who3, EventOf3Entities<?, E, F> what, TimeInstant when) {", "The EventOf3Entities given as parameter is a null reference.", "Be sure to have a valid EventOf3Entities reference for this event to be scheduled with.");
                        return;
                    }
                    if (!this.isModelCompatible(what)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored", "Entity : " + this.getName() + " Method: <E extends Entity,F extends Entity> schedule(E who2, F who3, EventOf3Entities<?, E, F> what, TimeInstant when) {", "The EventOf3Entities to be scheduled with this Entity is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    this.generateTraceForScheduling(what, who2, who3, null, null, when, null);
                    this.getModel().getExperiment().getScheduler().scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf3Entities$desmoj_core_simulator_TimeInstant(this, who2, who3, what, when);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("schedules on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                /**
                 * Schedules this Entity to be manipulated by the given EventOf3Entities at the given
                 * point of time. No preemption, i.e. a process calling this method
                 * will continue until passivated or hold.
                 *
                 * @param {desmoj.core.simulator.Entity} who2
                 * Entity : The second entity to be scheduled for the EventOf3Entities.
                 * @param {desmoj.core.simulator.Entity} who3
                 * Entity : The third entity to be scheduled for the EventOf3Entities.
                 * @param {desmoj.core.simulator.EventOf3Entities} what
                 * EventOf3Entities : The event to be scheduled
                 * @param {desmoj.core.simulator.TimeInstant} when
                 * TimeInstant : The point in simulation time the event is
                 * scheduled to happen.
                 * @see SimClock
                 */
                Entity.prototype.schedule = function (who2, who3, what, when) {
                    if (((who2 != null) || who2 === null) && ((who3 != null) || who3 === null) && ((what != null && what instanceof desmoj.core.simulator.EventOf3Entities) || what === null) && ((when != null && when instanceof desmoj.core.simulator.TimeInstant) || when === null)) {
                        return this.schedule$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf3Entities$desmoj_core_simulator_TimeInstant(who2, who3, what, when);
                    }
                    else if (((who2 != null) || who2 === null) && ((who3 != null) || who3 === null) && ((what != null && what instanceof desmoj.core.simulator.EventOf3Entities) || what === null) && ((when != null && when instanceof desmoj.core.simulator.TimeSpan) || when === null)) {
                        return this.schedule$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf3Entities$desmoj_core_simulator_TimeSpan(who2, who3, what, when);
                    }
                    else if (((who2 != null) || who2 === null) && ((who3 != null && who3 instanceof desmoj.core.simulator.EventOf2Entities) || who3 === null) && ((what != null && what instanceof desmoj.core.simulator.TimeInstant) || what === null) && when === undefined) {
                        return this.schedule$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf2Entities$desmoj_core_simulator_TimeInstant(who2, who3, what);
                    }
                    else if (((who2 != null) || who2 === null) && ((who3 != null && who3 instanceof desmoj.core.simulator.EventOf2Entities) || who3 === null) && ((what != null && what instanceof desmoj.core.simulator.TimeSpan) || what === null) && when === undefined) {
                        return this.schedule$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf2Entities$desmoj_core_simulator_TimeSpan(who2, who3, what);
                    }
                    else if (((who2 != null) || who2 === null) && ((who3 != null) || who3 === null) && ((what != null && what instanceof desmoj.core.simulator.EventOf3Entities) || what === null) && when === undefined) {
                        return this.schedule$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf3Entities(who2, who3, what);
                    }
                    else if (((who2 != null && who2 instanceof desmoj.core.simulator.Event) || who2 === null) && ((who3 != null && who3 instanceof desmoj.core.simulator.TimeInstant) || who3 === null) && what === undefined && when === undefined) {
                        return this.schedule$desmoj_core_simulator_Event$desmoj_core_simulator_TimeInstant(who2, who3);
                    }
                    else if (((who2 != null && who2 instanceof desmoj.core.simulator.Event) || who2 === null) && ((who3 != null && who3 instanceof desmoj.core.simulator.TimeSpan) || who3 === null) && what === undefined && when === undefined) {
                        return this.schedule$desmoj_core_simulator_Event$desmoj_core_simulator_TimeSpan(who2, who3);
                    }
                    else if (((who2 != null) || who2 === null) && ((who3 != null && who3 instanceof desmoj.core.simulator.EventOf2Entities) || who3 === null) && what === undefined && when === undefined) {
                        return this.schedule$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf2Entities(who2, who3);
                    }
                    else if (((who2 != null && who2 instanceof desmoj.core.simulator.Event) || who2 === null) && who3 === undefined && what === undefined && when === undefined) {
                        return this.schedule$desmoj_core_simulator_Event(who2);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Entity.prototype.schedule$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf3Entities$desmoj_core_simulator_TimeSpan = function (who2, who3, what, dt) {
                    if ((who2 == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: <E extends Entity, F extends Entity> schedule(E who2, F who3, EventOf3Entities<?, E, F> what, TimeSpan dt)", "The Entity \'who2\' given as parameter is a null reference.", "Be sure to have a valid Entity reference for this event to be scheduled with.");
                        return;
                    }
                    if ((who3 == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: <E extends Entity, F extends Entity> schedule(E who2, F who3, EventOf3Entities<?, E, F> what, TimeSpan dt)", "The Entity \'who3\' given as parameter is a null reference.", "Be sure to have a valid Entity reference for this event to be scheduled with.");
                        return;
                    }
                    if ((dt == null)) {
                        this.sendWarning("Can\'t schedule Entity!", "Entity : " + this.getName() + " Method: <E extends Entity, F extends Entity> schedule(E who2, F who3, EventOf3Entities<?, E, F> what, TimeSpan dt)", "The simulation time given as parameter is a null reference.", "Be sure to have a valid simulation time reference before calling this method.");
                        return;
                    }
                    if ((what == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: <E extends Entity, F extends Entity> schedule(E who2, F who3, EventOf3Entities<?, E, F> what, TimeSpan dt)", "The EventOf3Entities given as parameter is a null reference.", "Be sure to have a valid Event reference for this event to be scheduled with.");
                        return;
                    }
                    if (!this.isModelCompatible(what)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored", "Entity : " + this.getName() + " Method: <E extends Entity, F extends Entity> schedule(E who2, F who3, EventOf3Entities<?, E, F> what, TimeSpan dt)", "The EventOf3Entities to be scheduled with this Entity is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    this.generateTraceForScheduling(what, who2, who3, null, null, desmoj.core.simulator.TimeOperations.add$desmoj_core_simulator_TimeInstant$desmoj_core_simulator_TimeSpan(this.presentTime(), dt), null);
                    this.getModel().getExperiment().getScheduler().scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf3Entities$desmoj_core_simulator_TimeSpan(this, who2, who3, what, dt);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("schedules on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                Entity.prototype.schedule$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf3Entities = function (who2, who3, what) {
                    if ((who2 == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: <E extends Entity, F extends Entity> schedule(E who2, F who3, EventOf3Entities<?, E, F> what)", "The Entity \'who2\' given as parameter is a null reference.", "Be sure to have a valid Entity reference for this event to be scheduled with.");
                        return;
                    }
                    if ((who3 == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: <E extends Entity, F extends Entity> schedule(E who2, F who3, EventOf3Entities<?, E, F> what)", "The Entity \'who3\' given as parameter is a null reference.", "Be sure to have a valid Entity reference for this event to be scheduled with.");
                        return;
                    }
                    if ((what == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: <E extends Entity, F extends Entity> schedule(E who2, F who3, EventOf3Entities<?, E, F> what)", "The EventOf3Entities given as parameter is a null reference.", "Be sure to have a valid Event reference for this event to be scheduled with.");
                        return;
                    }
                    if (!this.isModelCompatible(what)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored", "Entity : " + this.getName() + " Method: <E extends Entity, F extends Entity> schedule(E who2, F who3, EventOf3Entities<?, E, F> what)", "The EventOf3Entities to be scheduled with this Entity is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    this.generateTraceForScheduling(what, who2, who3, null, null, this.presentTime(), null);
                    this.getModel().getExperiment().getScheduler().scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf3Entities$desmoj_core_simulator_TimeInstant(this, who2, who3, what, this.presentTime());
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("schedules on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                Entity.prototype.scheduleAfter$desmoj_core_simulator_Schedulable$desmoj_core_simulator_Event = function (after, what) {
                    if ((what == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: scheduleAfter(Schedulable after, Event what)", "The Event given as parameter is a null reference.", "Be sure to have a valid Event reference before calling this method.");
                        return;
                    }
                    if ((after == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: scheduleAfter(Schedulable after, Event what)", "The Schedulable given as parameter is a null reference.", "Be sure to have a valid Schedulable reference for this Entity to be scheduled with.");
                        return;
                    }
                    if (!after.isScheduled()) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: scheduleAfter(Schedulable after, Event what)", "The Schedulable given as parameter is not scheduled, thus no position can be determined for this Entity.", "Be sure that the Schedulable given as aprameter is actually scheduled. You can check that by calling its method isScheduled() which returns a boolean tellingyou whether it is scheduled or not.");
                        return;
                    }
                    if (!this.isModelCompatible(what)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored", "Entity : " + this.getName() + " Method: scheduleAfter(Schedulable after, Event what)", "The Event to be scheduled with this Entity is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    if (this.currentlySendTraceNotes()) {
                        if (this === this.currentEntity()) {
                            this.sendTraceNote("schedules \'" + what.getName() + "\' of itself after \'" + after.getName() + "\' at " + after.getEventNotes()[after.getEventNotes().length - 1].getTime().toString());
                        }
                        else {
                            this.sendTraceNote("schedules \'" + what.getName() + "\' of \'" + this.getName() + "\' after \'" + after.getName() + "\' at " + after.getEventNotes()[after.getEventNotes().length - 1].getTime().toString());
                        }
                    }
                    this.generateTraceForScheduling(what, null, null, after, null, /* get */ after.getEventNotes()[after.getEventNotes().length - 1].getTime(), null);
                    this.getModel().getExperiment().getScheduler().scheduleAfter$desmoj_core_simulator_Schedulable$desmoj_core_simulator_Entity$desmoj_core_simulator_EventAbstract(after, this, what);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("scheduleAfter " + after.getQuotedName() + " on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                Entity.prototype.scheduleAfter$desmoj_core_simulator_Schedulable$desmoj_core_simulator_EventOf2Entities$desmoj_core_simulator_Entity = function (after, what, who2) {
                    if ((what == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: <E extends Entity> scheduleAfter(Schedulable after, EventOf2Entities<?, E> what, E who2)", "The EventOf2Entities given as parameter is a null reference.", "Be sure to have a valid EventOf2Entities reference before calling this method.");
                        return;
                    }
                    if ((after == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: <E extends Entity> scheduleAfter(Schedulable after, EventOf2Entities<?, E> what, E who2)", "The Schedulable given as parameter is a null reference.", "Be sure to have a valid Schedulable reference for this Entity to be scheduled with.");
                        return;
                    }
                    if ((who2 == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: <E extends Entity> scheduleAfter(Schedulable after, EventOf2Entities<?, E> what, E who2)", "The Entity \'who2\' given as parameter is a null reference.", "Be sure to have a valid Entity reference for this Entity to be scheduled with.");
                        return;
                    }
                    if (!after.isScheduled()) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: <E extends Entity> scheduleAfter(Schedulable after, EventOf2Entities<?, E> what, E who2)", "The Schedulable given as parameter is not scheduled, thus no position can be determined for this Entity.", "Be sure that the Schedulable given as aprameter is actually scheduled. You can check that by calling its method isScheduled() which returns a boolean tellingyou whether it is scheduled or not.");
                        return;
                    }
                    if (!this.isModelCompatible(what)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored", "Entity : " + this.getName() + " Method: <E extends Entity> scheduleAfter(Schedulable after, EventOf2Entities<?, E> what, E who2)", "The Event to be scheduled with this Entity is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    this.generateTraceForScheduling(what, who2, null, after, null, /* get */ after.getEventNotes()[after.getEventNotes().length - 1].getTime(), null);
                    this.getModel().getExperiment().getScheduler().scheduleAfter$desmoj_core_simulator_Schedulable$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf2Entities(after, this, who2, what);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("scheduleAfter " + after.getQuotedName() + " on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                Entity.prototype.scheduleAfter$desmoj_core_simulator_Schedulable$desmoj_core_simulator_EventOf3Entities$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity = function (after, what, who2, who3) {
                    if ((what == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: <E extends Entity, F extends Entity> scheduleAfter(Schedulable after, EventOf3Entities<?, E, F> what, E who2, F who3)", "The EventOf3Entities given as parameter is a null reference.", "Be sure to have a valid EventOf3Entities reference before calling this method.");
                        return;
                    }
                    if ((after == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: <E extends Entity, F extends Entity> scheduleAfter(Schedulable after, EventOf3Entities<?, E, F> what, E who2, F who3)", "The Schedulable given as parameter is a null reference.", "Be sure to have a valid Schedulable reference for this Entity to be scheduled with.");
                        return;
                    }
                    if ((who2 == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: <E extends Entity, F extends Entity> scheduleAfter(Schedulable after, EventOf3Entities<?, E, F> what, E who2, F who3)", "The Entity \'who2\' given as parameter is a null reference.", "Be sure to have a valid Entity reference before calling this method.");
                        return;
                    }
                    if ((who3 == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: <E extends Entity, F extends Entity> scheduleAfter(Schedulable after, EventOf3Entities<?, E, F> what, E who2, F who3)", "The Entity \'who3\' given as parameter is a null reference.", "Be sure to have a valid Entity reference before calling this method.");
                        return;
                    }
                    if (!after.isScheduled()) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: <E extends Entity, F extends Entity> scheduleAfter(Schedulable after, EventOf3Entities<?, E, F> what, E who2, F who3)", "The Schedulable given as parameter is not scheduled, thus no position can be determined for this Entity.", "Be sure that the Schedulable given as aprameter is actually scheduled. You can check that by calling its method isScheduled() which returns a boolean tellingyou whether it is scheduled or not.");
                        return;
                    }
                    if (!this.isModelCompatible(what)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored", "Entity : " + this.getName() + " Method: <E extends Entity, F extends Entity> scheduleAfter(Schedulable after, EventOf3Entities<?, E, F> what, E who2, F who3)", "The EventOf3Entities to be scheduled with this Entity is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    this.generateTraceForScheduling(what, who2, who3, after, null, /* get */ after.getEventNotes()[after.getEventNotes().length - 1].getTime(), null);
                    this.getModel().getExperiment().getScheduler().scheduleAfter$desmoj_core_simulator_Schedulable$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf3Entities(after, this, who2, who3, what);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("scheduleAfter " + after.getQuotedName() + " on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                /**
                 * Schedules this Entity with the given EventOf3Entities to occur directly after the
                 * given Schedulable that is already scheduled. Note that the event's point
                 * of simulation time will be set to be the same as the Schedulable's time.
                 * Thus the event will occur directly after the given Schedulable but the
                 * simulation clock will not change. Will return with a warning message if
                 * the Schedulable given as parameter is not scheduled. If there are multiple
                 * schedules for the given Schedulable, the event will be scheduled after
                 * the last occurrence.
                 *
                 * @param {desmoj.core.simulator.Entity} who2
                 * Entity : The second entity to be scheduled for the EventOf3Entities.
                 * @param {desmoj.core.simulator.Entity} who3
                 * Entity : The third entity to be scheduled for the EventOf3Entities.
                 * @param {desmoj.core.simulator.EventOf3Entities} what
                 * EventOf3Entities : The event to be scheduled
                 * @param {desmoj.core.simulator.Schedulable} after
                 * Schedulable : The Schedulable this Entity should be scheduled
                 * after
                 * @param {desmoj.core.simulator.EventOf3Entities} what
                 * Event : The Event to manipulate this Entity
                 */
                Entity.prototype.scheduleAfter = function (after, what, who2, who3) {
                    if (((after != null && after instanceof desmoj.core.simulator.Schedulable) || after === null) && ((what != null && what instanceof desmoj.core.simulator.EventOf3Entities) || what === null) && ((who2 != null) || who2 === null) && ((who3 != null) || who3 === null)) {
                        return this.scheduleAfter$desmoj_core_simulator_Schedulable$desmoj_core_simulator_EventOf3Entities$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity(after, what, who2, who3);
                    }
                    else if (((after != null && after instanceof desmoj.core.simulator.Schedulable) || after === null) && ((what != null && what instanceof desmoj.core.simulator.EventOf2Entities) || what === null) && ((who2 != null) || who2 === null) && who3 === undefined) {
                        return this.scheduleAfter$desmoj_core_simulator_Schedulable$desmoj_core_simulator_EventOf2Entities$desmoj_core_simulator_Entity(after, what, who2);
                    }
                    else if (((after != null && after instanceof desmoj.core.simulator.Schedulable) || after === null) && ((what != null && what instanceof desmoj.core.simulator.Event) || what === null) && who2 === undefined && who3 === undefined) {
                        return this.scheduleAfter$desmoj_core_simulator_Schedulable$desmoj_core_simulator_Event(after, what);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Entity.prototype.scheduleBefore$desmoj_core_simulator_Schedulable$desmoj_core_simulator_Event = function (before, what) {
                    if ((what == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: scheduleBefore(Schedulable before, Event what)", "The Event given as parameter is a null reference.", "Be sure to have a valid Event reference before calling this method.");
                        return;
                    }
                    if ((before == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: scheduleBefore(Schedulable before, Event what)", "The Schedulable given as parameter is a null reference.", "Be sure to have a valid Schedulable reference for this Entity to be scheduled with.");
                        return;
                    }
                    if (!before.isScheduled()) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: scheduleBefore(Schedulable before, Event what)", "The Schedulable given as parameter is not scheduled, thus no position can be determined for this Entity.", "Be sure that the Schedulable given as aprameter is actually scheduled. You can check that by calling its method isScheduled() which returns a boolean tellingyou whether it is scheduled or not.");
                        return;
                    }
                    if (!this.isModelCompatible(what)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored", "Entity : " + this.getName() + " Method: scheduleBefore(Schedulable before, Event what)", "The Event to be scheduled with thisEntity is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    this.generateTraceForScheduling(what, null, null, null, before, /* get */ before.getEventNotes()[0].getTime(), null);
                    this.getModel().getExperiment().getScheduler().scheduleBefore$desmoj_core_simulator_Schedulable$desmoj_core_simulator_Entity$desmoj_core_simulator_EventAbstract(before, this, what);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("scheduleBefore " + before.getQuotedName() + " on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                Entity.prototype.scheduleBefore$desmoj_core_simulator_Schedulable$desmoj_core_simulator_EventOf2Entities$desmoj_core_simulator_Entity = function (before, what, who2) {
                    if ((what == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: <E extends Entity> void scheduleBefore(Schedulable before, EventOf2Entities<?, E> what, E who2)", "The EventOf2Entities given as parameter is a null reference.", "Be sure to have a valid EventOf2Entities reference before calling this method.");
                        return;
                    }
                    if ((before == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: <E extends Entity> void scheduleBefore(Schedulable before, EventOf2Entities<?, E> what, E who2)", "The Schedulable given as parameter is a null reference.", "Be sure to have a valid Schedulable reference for this Entity to be scheduled with.");
                        return;
                    }
                    if ((who2 == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: <E extends Entity> void scheduleBefore(Schedulable before, EventOf2Entities<?, E> what, E who2)", "The Entity \'who2\' given as parameter is a null reference.", "Be sure to have a valid Entity reference before calling this method.");
                        return;
                    }
                    if (!before.isScheduled()) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: <E extends Entity> void scheduleBefore(Schedulable before, EventOf2Entities<?, E> what, E who2)", "The Schedulable given as parameter is not scheduled, thus no position can be determined for this Entity.", "Be sure that the Schedulable given as aprameter is actually scheduled. You can check that by calling its method isScheduled() which returns a boolean tellingyou whether it is scheduled or not.");
                        return;
                    }
                    if (!this.isModelCompatible(what)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored", "Entity : " + this.getName() + " Method: <E extends Entity> void scheduleBefore(Schedulable before, EventOf2Entities<?, E> what, E who2)", "The EventOf2Entities to be scheduled with this Entity is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    this.generateTraceForScheduling(what, who2, null, null, before, /* get */ before.getEventNotes()[0].getTime(), null);
                    this.getModel().getExperiment().getScheduler().scheduleBefore$desmoj_core_simulator_Schedulable$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf2Entities(before, this, who2, what);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("scheduleBefore " + before.getQuotedName() + " on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                Entity.prototype.scheduleBefore$desmoj_core_simulator_Schedulable$desmoj_core_simulator_EventOf3Entities$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity = function (before, what, who2, who3) {
                    if ((what == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: <E extends Entity, F extends Entity> void scheduleBefore(Schedulable before, EventOf3Entities<?, E, F> what, E who2, F who3)", "The Event given as parameter is a null reference.", "Be sure to have a valid Event reference before calling this method.");
                        return;
                    }
                    if ((before == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: <E extends Entity, F extends Entity> void scheduleBefore(Schedulable before, EventOf3Entities<?, E, F> what, E who2, F who3)", "The Schedulable given as parameter is a null reference.", "Be sure to have a valid Schedulable reference for this Entity to be scheduled with.");
                        return;
                    }
                    if ((who2 == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: <E extends Entity, F extends Entity> void scheduleBefore(Schedulable before, EventOf3Entities<?, E, F> what, E who2, F who3)", "The Entity \'who2\' given as parameter is a null reference.", "Be sure to have a valid Entity reference for this Entity to be scheduled with.");
                        return;
                    }
                    if ((who3 == null)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: <E extends Entity, F extends Entity> void scheduleBefore(Schedulable before, EventOf3Entities<?, E, F> what, E who2, F who3)", "The Entity  \'who3\' given as parameter is a null reference.", "Be sure to have a valid Entity reference for this Entity to be scheduled with.");
                        return;
                    }
                    if (!before.isScheduled()) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored.", "Entity : " + this.getName() + " Method: <E extends Entity, F extends Entity> void scheduleBefore(Schedulable before, EventOf3Entities<?, E, F> what, E who2, F who3)", "The Schedulable given as parameter is not scheduled, thus no position can be determined for this Entity.", "Be sure that the Schedulable given as aprameter is actually scheduled. You can check that by calling its method isScheduled() which returns a boolean tellingyou whether it is scheduled or not.");
                        return;
                    }
                    if (!this.isModelCompatible(what)) {
                        this.sendWarning("Can\'t schedule Entity! Command ignored", "Entity : " + this.getName() + " Method: <E extends Entity, F extends Entity> void scheduleBefore(Schedulable before, EventOf3Entities<?, E, F> what, E who2, F who3)", "The EventOf3Entities to be scheduled with this Entity is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    this.generateTraceForScheduling(what, who2, who3, null, before, /* get */ before.getEventNotes()[0].getTime(), null);
                    this.getModel().getExperiment().getScheduler().scheduleBefore$desmoj_core_simulator_Schedulable$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf3Entities(before, this, who2, who3, what);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("scheduleBefore " + before.getQuotedName() + " on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                /**
                 * Schedules this Entity with the given EventOf3Entities to occur directly before the
                 * given Schedulable that is scheduled. Note that the event's point of
                 * simulation time will be set to be the same as the Schedulable's time.
                 * Thus the event will occur directly before the given Schedulable but the
                 * simulation clock will not change. Issues a warning message if the
                 * Schedulable given is not scheduled. If there are multiple
                 * schedules for the given Schedulable, the event will be scheduled before
                 * the first occurrence.
                 *
                 * @param {desmoj.core.simulator.Entity} who2
                 * Entity : The second entity to be scheduled for the EventOf3Entities.
                 * @param {desmoj.core.simulator.Entity} who3
                 * Entity : The third entity to be scheduled for the EventOf3Entities.
                 * @param {desmoj.core.simulator.EventOf3Entities} what
                 * EventOf3Entities : The event to be scheduled
                 * @param {desmoj.core.simulator.Schedulable} before
                 * Schedulable : The Schedulable this Entity should be scheduled
                 * before
                 */
                Entity.prototype.scheduleBefore = function (before, what, who2, who3) {
                    if (((before != null && before instanceof desmoj.core.simulator.Schedulable) || before === null) && ((what != null && what instanceof desmoj.core.simulator.EventOf3Entities) || what === null) && ((who2 != null) || who2 === null) && ((who3 != null) || who3 === null)) {
                        return this.scheduleBefore$desmoj_core_simulator_Schedulable$desmoj_core_simulator_EventOf3Entities$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity(before, what, who2, who3);
                    }
                    else if (((before != null && before instanceof desmoj.core.simulator.Schedulable) || before === null) && ((what != null && what instanceof desmoj.core.simulator.EventOf2Entities) || what === null) && ((who2 != null) || who2 === null) && who3 === undefined) {
                        return this.scheduleBefore$desmoj_core_simulator_Schedulable$desmoj_core_simulator_EventOf2Entities$desmoj_core_simulator_Entity(before, what, who2);
                    }
                    else if (((before != null && before instanceof desmoj.core.simulator.Schedulable) || before === null) && ((what != null && what instanceof desmoj.core.simulator.Event) || what === null) && who2 === undefined && who3 === undefined) {
                        return this.scheduleBefore$desmoj_core_simulator_Schedulable$desmoj_core_simulator_Event(before, what);
                    }
                    else
                        throw new Error('invalid overload');
                };
                /**
                 * Sets the entity's queuing priority to a given integer value. The default
                 * priority of each entity (unless assigned otherwise) is zero.
                 * Negative priorities are lower, positive priorities are higher.
                 * All values should be inside the range defined by Java's integral
                 * <code>integer</code> data type [-2147483648, +2147483647].
                 *
                 * An entity's queuing priority can be used by the modeller to determine how
                 * the entity is treated by queues, though how precisely a queue will use
                 * the priority to determine sort order is up to it's queuing strategy:
                 * <ul>
                 * <li><code>QueueBased.FIFO</code> sorts entities by their queuing priority,
                 * highest priority first. Entities with the same priority are
                 * enqueued based on &quot;first in, first out&quot;.</li>
                 * <li><code>QueueBased.LIFO</code> also sorts entities by their priority,
                 * highest priority first. However, entities with the same priority are
                 * enqueued based on &quot;last in, first out&quot;.</li>
                 * <li><code>QueueBased.Random</code> assigns a random position to each
                 * entity entering the queue, disregarding priority.</li>
                 * </ul>
                 * Of course, the modeller is free to use the queuing priority to determine
                 * how entities are processed by the components he implements himself,
                 * whether they are queues or not.
                 *
                 * @param {number} newPriority
                 * int : The new queuing priority value
                 */
                Entity.prototype.setQueueingPriority = function (newPriority) {
                    this._myQueuingPriority = newPriority;
                };
                /**
                 * Informs this <code>Entity</code> to be queued in a given <code>QueueBased</code>.
                 *
                 * @param {desmoj.core.simulator.QueueBased} q
                 * QueueBased : The <code>QueueBased</code> where this entity is now queued.
                 */
                Entity.prototype.addQueueBased = function (q) {
                    /* add */ (this._myQueues.push(q) > 0);
                };
                /**
                 * Informs this <code>Entity</code> to be no longer queued in a given <code>QueueBased</code>.
                 *
                 * @param {desmoj.core.simulator.QueueBased} q
                 * Queue<?> : The <code>QueueBased</code> where this entity is no longer queued.
                 */
                Entity.prototype.removeQueueBased = function (q) {
                    /* remove */ (function (a) { return a.splice(a.indexOf(q), 1); })(this._myQueues);
                };
                /**
                 * Removes an event-note from the internal list
                 *
                 * * @param note
                 * EventNote : The <code>EventNote to be removed</code>
                 * @param {desmoj.core.simulator.EventNote} note
                 */
                Entity.prototype.removeEventNote = function (note) {
                    /* remove */ (function (a) { return a.splice(a.indexOf(note), 1); })(this._schedule);
                };
                /**
                 * Utility method to generate trace output for scheduling this event (internal use only).
                 *
                 * @param {desmoj.core.simulator.EventAbstract} Event the event to be scheduled
                 * @param {desmoj.core.simulator.Entity} who1 the second entity scheduled with the event (or <code>null</code> if not applicable)
                 * @param {desmoj.core.simulator.Entity} who2 the third entity scheduled with the event (or <code>null</code> if not applicable)
                 * @param {desmoj.core.simulator.Schedulable} after the Schedulable after which the event is scheduled (or <code>null</code> if not applicable)
                 * @param {desmoj.core.simulator.Schedulable} before the Schedulable before which the event is scheduled (or <code>null</code> if not applicable)
                 * @param {desmoj.core.simulator.TimeInstant} at the TimeInstant at which the event is scheduled
                 * @param {string} remark optional further comments (or <code>null</code> if not applicable)
                 */
                Entity.prototype.generateTraceForScheduling = function (Event, who1, who2, after, before, at, remark) {
                    if (this.currentlySendTraceNotes()) {
                        var trace = { str: "schedules \'" + Event.getName() + "\'", toString: function () { return this.str; } };
                        if (who1 != null) {
                            var who1alias_1 = (who1 === this.currentEntity() ? "itself" : "\'" + who1.getName() + "\'");
                            /* append */ (function (sb) { return sb.str = sb.str.concat(" with " + who1alias_1); })(trace);
                            if (who2 != null) {
                                var who2alias_1 = (who2 === this.currentEntity() ? "itself" : "\'" + who2.getName() + "\'");
                                /* append */ (function (sb) { return sb.str = sb.str.concat(" and " + who2alias_1); })(trace);
                            }
                        }
                        if (after != null) {
                            var afterAlias_1 = (after === this.currentEntity() ? "itself" : "\'" + after.getName() + "\'");
                            /* append */ (function (sb) { return sb.str = sb.str.concat(" after " + afterAlias_1); })(trace);
                        }
                        else if (before != null) {
                            var beforeAlias_1 = (before === this.currentEntity() ? "itself" : "\'" + before.getName() + "\'");
                            /* append */ (function (sb) { return sb.str = sb.str.concat(" before " + beforeAlias_1); })(trace);
                        }
                        if (at === this.presentTime()) {
                            /* append */ (function (sb) { return sb.str = sb.str.concat(" now."); })(trace);
                        }
                        else {
                            /* append */ (function (sb) { return sb.str = sb.str.concat(" at " + at.toString() + "."); })(trace);
                        }
                        if (remark != null && remark.length > 0) {
                            /* append */ (function (sb) { return sb.str = sb.str.concat(". " + remark); })(trace);
                        }
                        this.sendTraceNote(/* toString */ trace.str);
                    }
                };
                /**
                 * Creates and returns a copy of this entity.
                 * Note that subclasses have to implement the interface
                 * <code>java.lang.Cloneable</code> to actually use this method as
                 * otherwise, a <code>CloneNotSupportedException</code> will be thrown.
                 *
                 * @return {desmoj.core.simulator.Entity} Entity : A copy of this entity.
                 */
                Entity.prototype.clone = function () {
                    var _this = this;
                    var c = (function (o) { if (_super.prototype.clone != undefined) {
                        return _super.prototype.clone.call(_this);
                    }
                    else {
                        var clone = Object.create(o);
                        for (var p in o) {
                            if (o.hasOwnProperty(p))
                                clone[p] = o[p];
                        }
                        return clone;
                    } })(this);
                    c._myQueues = ([]);
                    c._identNumber = this.getModel().linkWithIdentNumber(c);
                    return c;
                };
                /**
                 *
                 * @param {*} obj
                 * @return {boolean}
                 */
                Entity.prototype.equals = function (obj) {
                    return (function (o1, o2) { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(this, obj);
                };
                return Entity;
            }(desmoj.core.simulator.Schedulable));
            simulator.Entity = Entity;
            Entity["__class"] = "desmoj.core.simulator.Entity";
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Creates a new event of the given model, with the given name and trace
             * option.
             *
             * @param {string} name
             * java.lang.String : The name of this event
             * @param {desmoj.core.simulator.Model} owner
             * Model : The model this event is associated to
             * @param {boolean} showInTrace
             * boolean : Flag for showing event in trace-files. Set it to
             * <code>true</code> if event should show up in trace. Set it to
             * <code>false</code> if event should not be shown in trace.
             * @class
             * @extends desmoj.core.simulator.Schedulable
             * @author Tim Lechler
             */
            var EventAbstract = (function (_super) {
                __extends(EventAbstract, _super);
                function EventAbstract(owner, name, showInTrace) {
                    var _this = _super.call(this, owner, name, showInTrace) || this;
                    _this._realTimeConstraint = 0;
                    _this.numberOfEntities = 0;
                    _this._mySchedulingPriority = 0;
                    _this.numberOfEntities = 0;
                    _this._mySchedulingPriority = 0;
                    return _this;
                }
                /**
                 * Tests if this event actually is an external event which is not used for
                 * modelling but to control the experiment to act at certain points of
                 * simulation time. External events must not be connected to an entity.
                 *
                 * @return {boolean} boolean : Is <code>true</code> if this is an instance of class
                 * <code>ExternalEvent</code>,<code>false</code> otherwise
                 */
                EventAbstract.prototype.isExternal = function () {
                    return (this != null && this instanceof desmoj.core.simulator.ExternalEvent);
                };
                /**
                 * Returns the realTime deadline for this event (in nanoseconds). In case of a
                 * real-time execution (i. e. the execution speed rate is set to a positive
                 * value) the Scheduler will produce a warning message if a deadline is
                 * missed.
                 *
                 * @return {number} the realTimeConstraint in nanoseconds
                 */
                EventAbstract.prototype.getRealTimeConstraint = function () {
                    return this._realTimeConstraint;
                };
                /**
                 * Returns the realTime deadline for this event (in nanoseconds). In case of a
                 * real-time execution (i. e. the execution speed rate is set to a positive
                 * value) the Scheduler will produce a warning message if a deadline is
                 * missed.
                 *
                 * @return {number} the realTimeConstraint in nanoseconds
                 */
                EventAbstract.prototype.getNumberOfEntities = function () {
                    return this.numberOfEntities;
                };
                /**
                 * Sets the realTime deadline for this event (in nanoseconds). In case of a
                 * real-time execution (i. e. the execution speed rate is set to a positive
                 * value) the Scheduler will produce a warning message if a deadline is
                 * missed.
                 *
                 * @param {number} realTimeConstraint the realTimeConstraint in nanoseconds to set
                 */
                EventAbstract.prototype.setRealTimeConstraint = function (realTimeConstraint) {
                    this._realTimeConstraint = realTimeConstraint;
                };
                /**
                 * Utility method to generate trace output for scheduling this event (internal use only).
                 *
                 * @param {desmoj.core.simulator.Entity} who1 the first entity scheduled with this event (or <code>null</code> if not applicable)
                 * @param {desmoj.core.simulator.Entity} who2 the second entity scheduled with this event (or <code>null</code> if not applicable)
                 * @param {desmoj.core.simulator.Entity} who3 the third entity scheduled with this event (or <code>null</code> if not applicable)
                 * @param {desmoj.core.simulator.Schedulable} after the Schedulable after which this event is scheduled (or <code>null</code> if not applicable)
                 * @param {desmoj.core.simulator.Schedulable} before the Schedulable before which this event is scheduled (or <code>null</code> if not applicable)
                 * @param {desmoj.core.simulator.TimeInstant} at the TimeInstant at which this event is scheduled
                 * @param {string} remark optional further comments (or <code>null</code> if not applicable)
                 */
                EventAbstract.prototype.generateTraceForScheduling = function (who1, who2, who3, after, before, at, remark) {
                    if (this.currentlySendTraceNotes()) {
                        var trace = { str: "schedules \'" + this.getName() + "\'", toString: function () { return this.str; } };
                        if (who1 != null) {
                            var who1alias_2 = (who1 === this.currentEntity() && who2 == null && who3 == null ? "itself" : "\'" + who1.getName() + "\'");
                            /* append */ (function (sb) { return sb.str = sb.str.concat(" of " + who1alias_2); })(trace);
                            if (who2 != null) {
                                /* append */ (function (sb) { return sb.str = sb.str.concat(who3 == null ? " and \'" + who2.getName() + "\'" : ", \'" + who2.getName() + "\'"); })(trace);
                                if (who3 != null) {
                                    /* append */ (function (sb) { return sb.str = sb.str.concat(" and \'" + who3.getName() + "\'"); })(trace);
                                }
                            }
                        }
                        if (after != null) {
                            var afterAlias_2 = (after === this.currentEntity() ? "itself" : "\'" + after.getName() + "\'");
                            /* append */ (function (sb) { return sb.str = sb.str.concat(" after " + afterAlias_2); })(trace);
                        }
                        else if (before != null) {
                            var beforeAlias_2 = (before === this.currentEntity() ? "itself" : "\'" + before.getName() + "\'");
                            /* append */ (function (sb) { return sb.str = sb.str.concat(" before " + beforeAlias_2); })(trace);
                        }
                        if (at === this.presentTime()) {
                            /* append */ (function (sb) { return sb.str = sb.str.concat(" now"); })(trace);
                        }
                        else {
                            /* append */ (function (sb) { return sb.str = sb.str.concat(" at " + at.toString()); })(trace);
                        }
                        if (remark != null && remark.length > 0) {
                            /* append */ (function (sb) { return sb.str = sb.str.concat(". " + remark); })(trace);
                        }
                        this.sendTraceNote(/* toString */ trace.str);
                    }
                };
                /**
                 * Returns the event's scheduling priority. The scheduling priority is used
                 * to determine which event to execute first if two or more events are scheduled
                 * at the same instant. The default priority is zero.
                 * Higher priorities are positive, lower priorities negative.
                 *
                 * @return {number} int : The events's priority
                 */
                EventAbstract.prototype.getSchedulingPriority = function () {
                    return this._mySchedulingPriority;
                };
                /**
                 * Sets the entity's scheduling priority to a given integer value. The default
                 * priority (unless assigned otherwise) is zero.
                 * Negative priorities are lower, positive priorities are higher.
                 * All values should be inside the range defined by Java's integral
                 * <code>integer</code> data type [-2147483648, +2147483647].
                 *
                 * An event's scheduling priority it used to determine which event is
                 * executed first if scheduled for the same time instant.
                 * Should the priority be the same, event execution depends on the
                 * <code>EventList</code> in use, e.g. scheduled first is executed
                 * first (<code>EventTreeList</code>) or random (<code>RandomizingEventTreeList</code>).
                 *
                 * @param {number} newPriority
                 * int : The new scheduling priority value
                 */
                EventAbstract.prototype.setSchedulingPriority = function (newPriority) {
                    this._mySchedulingPriority = newPriority;
                };
                /**
                 * Creates and returns a copy of this event.
                 * Note that subclasses have to implement the interface
                 * <code>java.lang.Cloneable</code> to actually use this method as
                 * otherwise, a <code>CloneNotSupportedException</code> will be thrown.
                 *
                 * @return {desmoj.core.simulator.EventAbstract} EventAbstract : A copy of this event.
                 */
                EventAbstract.prototype.clone = function () {
                    var _this = this;
                    return (function (o) { if (_super.prototype.clone != undefined) {
                        return _super.prototype.clone.call(_this);
                    }
                    else {
                        var clone = Object.create(o);
                        for (var p in o) {
                            if (o.hasOwnProperty(p))
                                clone[p] = o[p];
                        }
                        return clone;
                    } })(this);
                };
                return EventAbstract;
            }(desmoj.core.simulator.Schedulable));
            simulator.EventAbstract = EventAbstract;
            EventAbstract["__class"] = "desmoj.core.simulator.EventAbstract";
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var report;
        (function (report) {
            /**
             * Create a new HTMLReportOutput class
             *
             * @param {number} simTimeFloatingDigits
             * int: The number of floating point digits of the simulation
             * time values to be displayed
             * @class
             * @extends desmoj.core.report.ReportMultRowsFileOut
             * @author Gunnar Kiesel
             */
            var HTMLReportOutput = (function (_super) {
                __extends(HTMLReportOutput, _super);
                function HTMLReportOutput(simTimeFloatingDigits) {
                    var _this = this;
                    if (((typeof simTimeFloatingDigits === 'number') || simTimeFloatingDigits === null)) {
                        var __args = Array.prototype.slice.call(arguments);
                        _this = _super.call(this, simTimeFloatingDigits, "desmoj.core.report.HTMLTableChartFormatter") || this;
                    }
                    else if (simTimeFloatingDigits === undefined) {
                        var __args = Array.prototype.slice.call(arguments);
                        _this = _super.call(this, 1, "desmoj.core.report.HTMLTableChartFormatter") || this;
                    }
                    else
                        throw new Error('invalid overload');
                    return _this;
                }
                /**
                 * set the time of the current output
                 *
                 * @param {number} timeFloats
                 * int: time of the curent output
                 */
                HTMLReportOutput.prototype.setTimeFloats = function (timeFloats) {
                    this.formatter.setTimePrecision(timeFloats);
                };
                /**
                 * returns the file appendix for this output type *
                 * @return {string}
                 */
                HTMLReportOutput.prototype.getAppendix = function () {
                    return ".html";
                };
                return HTMLReportOutput;
            }(desmoj.core.report.ReportMultRowsFileOut));
            report.HTMLReportOutput = HTMLReportOutput;
            HTMLReportOutput["__class"] = "desmoj.core.report.HTMLReportOutput";
            HTMLReportOutput["__interfaces"] = ["desmoj.core.report.OutputType", "desmoj.core.report.MessageReceiver"];
        })(report = core.report || (core.report = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var dist;
        (function (dist) {
            /**
             * Constructs a distribution returning continuously distributed double
             * samples. Note that the method <code>Double sample()</code> returning the samples
             * (inherited from <code>NumericalDist<N></code>) has to be
             * implemented in subclasses.
             *
             * @param {desmoj.core.simulator.Model} owner
             * Model : The distribution's owner
             * @param {string} name
             * java.lang.String : The distribution's name
             * @param {boolean} showInReport
             * boolean : Flag to show distribution in report
             * @param {boolean} showInTrace
             * boolean : Flag to show distribution in trace
             * @class
             * @extends desmoj.core.dist.NumericalDist
             * @author Tim Lechler, Johannes Goebel
             */
            var ContDist = (function (_super) {
                __extends(ContDist, _super);
                function ContDist(owner, name, showInReport, showInTrace) {
                    return _super.call(this, owner, name, showInReport, showInTrace) || this;
                }
                ContDist.prototype.sampleTimeSpan$ = function () {
                    if (!this.getModel().isConnected()) {
                        this.sendWarning("Failed to sample a TimeSpan. Returning TimeSpan(0) instead.", "ContDist: " + this.getName() + " Method: TimeSpan sampleTimeSpan()", "Model not yet connected to an experiment, thus reference time unit and random number seeds not yet set.", "Make sure your model is connected to an experiment before this method is called.");
                        return new desmoj.core.simulator.TimeSpan(0);
                    }
                    var sample = this.sample();
                    if (sample < 0) {
                        this.sendWarning("Failed to sample a TimeSpan. Returning TimeSpan(0) instead.", "ContDist: " + this.getName() + " Method: TimeSpan sampleTimeSpan()", "The distribution returned a negative sample (" + sample + ").", "Make sure to sample TimeSpans from non-negative distributions only.");
                        return new desmoj.core.simulator.TimeSpan(0);
                    }
                    return new desmoj.core.simulator.TimeSpan(sample);
                };
                ContDist.prototype.sampleTimeSpan$def_TimeUnit = function (unit) {
                    if (unit == null) {
                        throw (new desmoj.core.exception.SimAbortedException(new desmoj.core.report.ErrorMessage(null, "Can\'t create TimeSpan object! Simulation aborted.", "ContDist: " + this.getName() + " Method: TimeSpan sampleTimeSpan(TimeUnit unit)", "Time unit passed is null", "Make sure to pass a non-null time unit.", null)));
                    }
                    if (!this.getModel().isConnected()) {
                        this.sendWarning("Failed to sample a TimeSpan. Returning TimeSpan(0) instead.", "ContDist: " + this.getName() + " Method: TimeSpan sampleTimeSpan(TimeUnit unit)", "Model not yet connected to an experiment, thus random number seeds not yet set.", "Make sure your model is connected to an experiment before this method is called.");
                        return new desmoj.core.simulator.TimeSpan(0);
                    }
                    var sample = this.sample();
                    if (sample < 0) {
                        this.sendWarning("Failed to sample a TimeSpan. Returning TimeSpan(0) instead.", "ContDist: " + this.getName() + " Method: TimeSpan sampleTimeSpan(TimeUnit unit)", "The distribution returned a negative sample (" + sample + ").", "Make sure to sample TimeSpans from non-negative distributions only.");
                        return new desmoj.core.simulator.TimeSpan(0);
                    }
                    return new desmoj.core.simulator.TimeSpan(sample, unit);
                };
                /**
                 * Convenience method to sample a period of random length by creating a
                 * <code>TimeSpan</code> whose length is determined by sampling this
                 * distribution (time unit given explicitly as parameter), thus replacing
                 * the pattern <code>new TimeSpan(distribution.sample(), unit)</code>.
                 *
                 * @param {def.TimeUnit} unit
                 * TimeUnit: the TimeUnit to assign to the sampled value
                 *
                 * @return {desmoj.core.simulator.TimeSpan} TimeSpan : The TimeSpan sampled from this distribution
                 */
                ContDist.prototype.sampleTimeSpan = function (unit) {
                    if (((typeof unit === 'number') || unit === null)) {
                        return this.sampleTimeSpan$def_TimeUnit(unit);
                    }
                    else if (unit === undefined) {
                        return this.sampleTimeSpan$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                return ContDist;
            }(desmoj.core.dist.NumericalDist));
            dist.ContDist = ContDist;
            ContDist["__class"] = "desmoj.core.dist.ContDist";
        })(dist = core.dist || (core.dist = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (demos) {
    var eventsexample;
    (function (eventsexample) {
        /**
         * Constructor of the truck entity.
         *
         * @param {desmoj.core.simulator.Model} owner the model this entity belongs to
         * @param {string} name this truck's name
         * @param {boolean} showInTrace flag to indicate if this entity shall produce output for the trace
         * @class
         * @extends desmoj.core.simulator.Entity
         * @author Olaf Neidhardt, Ruth Meyer
         */
        var Truck = (function (_super) {
            __extends(Truck, _super);
            function Truck(owner, name, showInTrace) {
                return _super.call(this, owner, name, showInTrace) || this;
            }
            return Truck;
        }(desmoj.core.simulator.Entity));
        eventsexample.Truck = Truck;
        Truck["__class"] = "demos.eventsexample.Truck";
    })(eventsexample = demos.eventsexample || (demos.eventsexample = {}));
})(demos || (demos = {}));
(function (demos) {
    var eventsexample;
    (function (eventsexample) {
        /**
         * Constructor of the van carrier entity.
         *
         * @param {desmoj.core.simulator.Model} owner the model this entity belongs to
         * @param {string} name this VC's name
         * @param {boolean} showInTrace flag to indicate if this entity shall produce output for the trace
         * @class
         * @extends desmoj.core.simulator.Entity
         * @author Olaf Neidhardt, Ruth Meyer
         */
        var VanCarrier = (function (_super) {
            __extends(VanCarrier, _super);
            function VanCarrier(owner, name, showInTrace) {
                return _super.call(this, owner, name, showInTrace) || this;
            }
            return VanCarrier;
        }(desmoj.core.simulator.Entity));
        eventsexample.VanCarrier = VanCarrier;
        VanCarrier["__class"] = "demos.eventsexample.VanCarrier";
    })(eventsexample = demos.eventsexample || (demos.eventsexample = {}));
})(demos || (demos = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Creates a new event of the given model, with the given name and trace
             * option.
             *
             * @param {string} name
             * java.lang.String : The name of this event
             * @param {desmoj.core.simulator.Model} owner
             * Model : The model this event is associated to
             * @param {boolean} showInTrace
             * boolean : Flag for showing event in trace-files. Set it to
             * <code>true</code> if event should show up in trace. Set it to
             * <code>false</code> if event should not be shown in trace.
             * @class
             * @extends desmoj.core.simulator.EventAbstract
             * @author Tim Lechler
             */
            var Event = (function (_super) {
                __extends(Event, _super);
                function Event(owner, name, showInTrace) {
                    var _this = _super.call(this, owner, name, showInTrace) || this;
                    _this.numberOfEntities = 1;
                    return _this;
                }
                Event.prototype.eventRoutine = function (truck) {
                    if (((truck != null) || truck === null)) {
                        return this.eventRoutine$desmoj_core_simulator_Entity(truck);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Event.prototype.eventRoutine$desmoj_core_simulator_Entity = function (who) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                Event.prototype.schedule$desmoj_core_simulator_Entity$desmoj_core_simulator_TimeInstant = function (who, instant) {
                    if ((instant == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: schedule(Entity who, TimeInstant instant)", "The TimeInstant given as parameter is a null reference.", "Be sure to have a valid TimeInstant reference before calling this method.");
                        return;
                    }
                    if ((who == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: schedule(Entity who, TimeInstant instant)", "The Entity given as parameter is a null reference.", "Be sure to have a valid Entity reference for this event to be scheduled with.");
                        return;
                    }
                    if (!this.isModelCompatible(who)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Entity : " + this.getName() + " Method: schedule(Entity who, TimeInstant instant)", "The Entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    this.generateTraceForScheduling(who, null, null, null, null, instant, null);
                    this.getModel().getExperiment().getScheduler().scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_EventAbstract$desmoj_core_simulator_TimeInstant(who, this, instant);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("schedules on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                /**
                 * Schedules this event to act on the given entity at a certain point in
                 * simulation time. No preemption, i.e. a process calling this method
                 * will continue until passivated or hold.
                 *
                 * @param {desmoj.core.simulator.Entity} who
                 * E : The first entity to be manipulated by this event
                 * @param {desmoj.core.simulator.TimeInstant} instant
                 * TimeInstant : The point in simulation time this event is
                 * scheduled to happen.
                 */
                Event.prototype.schedule = function (who, instant) {
                    if (((who != null) || who === null) && ((instant != null && instant instanceof desmoj.core.simulator.TimeInstant) || instant === null)) {
                        return this.schedule$desmoj_core_simulator_Entity$desmoj_core_simulator_TimeInstant(who, instant);
                    }
                    else if (((who != null) || who === null) && ((instant != null && instant instanceof desmoj.core.simulator.TimeSpan) || instant === null)) {
                        return this.schedule$desmoj_core_simulator_Entity$desmoj_core_simulator_TimeSpan(who, instant);
                    }
                    else if (((who != null) || who === null) && ((instant != null && instant instanceof desmoj.core.dist.NumericalDist) || instant === null)) {
                        return this.schedule$desmoj_core_simulator_Entity$desmoj_core_dist_NumericalDist(who, instant);
                    }
                    else if (((who != null) || who === null) && instant === undefined) {
                        return this.schedule$desmoj_core_simulator_Entity(who);
                    }
                    else
                        throw new Error('invalid overload');
                };
                Event.prototype.schedule$desmoj_core_simulator_Entity$desmoj_core_simulator_TimeSpan = function (who, dt) {
                    if ((dt == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: schedule(Entity who, TimeSpan dt)", "The TimeSpan given as parameter is a null reference.", "Be sure to have a valid TimeSpan reference before calling this method.");
                        return;
                    }
                    if ((who == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: schedule(Entity who, TimeSpan dt)", "The Entity given as parameter is a null reference.", "Be sure to have a valid Entity reference for this event to be scheduled with.");
                        return;
                    }
                    if (!this.isModelCompatible(who)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Entity : " + this.getName() + " Method: schedule(Entity who, TimeSpan dt)", "The Entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    this.generateTraceForScheduling(who, null, null, null, null, desmoj.core.simulator.TimeOperations.add$desmoj_core_simulator_TimeInstant$desmoj_core_simulator_TimeSpan(this.presentTime(), dt), null);
                    this.getModel().getExperiment().getScheduler().scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_EventAbstract$desmoj_core_simulator_TimeSpan(who, this, dt);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("schedules on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                Event.prototype.schedule$desmoj_core_simulator_Entity = function (who) {
                    if ((who == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: schedule(Entity who)", "The Entity given as parameter is a null reference.", "Be sure to have a valid Entity reference for this event to be scheduled with.");
                        return;
                    }
                    if (!this.isModelCompatible(who)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Entity : " + this.getName() + " Method: schedule(Entity who)", "The Entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    this.generateTraceForScheduling(who, null, null, null, null, this.presentTime(), null);
                    this.getModel().getExperiment().getScheduler().scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_EventAbstract$desmoj_core_simulator_TimeInstant(who, this, this.presentTime());
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("schedules on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                Event.prototype.schedule$desmoj_core_simulator_Entity$desmoj_core_dist_NumericalDist = function (who, dist) {
                    if ((dist == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: schedule(Entity who, NumericalDist<?> dist)", "The NumericalDist given as parameter is a null reference.", "Be sure to have a valid NumericalDist reference before calling this method.");
                        return;
                    }
                    if ((who == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: schedule(Entity who, NumericalDist<?> dist)", "The Entity given as parameter is a null reference.", "Be sure to have a valid Entity reference for this event to be scheduled with.");
                        return;
                    }
                    if (!this.isModelCompatible(who)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Entity : " + this.getName() + " Method: schedule(Entity who, NumericalDist<?> dist)", "The Entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    var dt = dist.sampleTimeSpan();
                    this.generateTraceForScheduling(who, null, null, null, null, desmoj.core.simulator.TimeOperations.add$desmoj_core_simulator_TimeInstant$desmoj_core_simulator_TimeSpan(this.presentTime(), dt), "sampled from " + dist.getQuotedName());
                    this.getModel().getExperiment().getScheduler().scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_EventAbstract$desmoj_core_simulator_TimeSpan(who, this, dt);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("schedules on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                /**
                 * Schedules this event to act on the given Entity directly after the given
                 * Schedulable is already set to be activated. Note that this event's point
                 * of simulation time will be set to be the same as the Schedulable's time.
                 * Thus this event will occur directly after the given Schedulable but the
                 * simulation clock will not change. Make sure that the Schedulable given as
                 * parameter is actually scheduled.
                 *
                 * @param {desmoj.core.simulator.Schedulable} after
                 * Schedulable : The Schedulable this entity should be scheduled
                 * after
                 * @param {desmoj.core.simulator.Entity} who
                 * E : The Entity to be manipulated by this event
                 */
                Event.prototype.scheduleAfter = function (after, who) {
                    if (who == null) {
                        this.sendWarning("Can\'t schedule Event! Command ignored.", "Event : " + this.getName() + " Method: scheduleAfter(Schedulable after, " + "Entity who)", "The Entity \'who\' given as parameter is a null reference.", "Be sure to have a valid Entity reference before calling this method.");
                        return;
                    }
                    if (after == null) {
                        this.sendWarning("Can\'t schedule Event! Command ignored.", "Event : " + this.getName() + " Method: scheduleAfter(Schedulable after, " + "Entity who)", "The Schedulable given as parameter is a null reference.", "Be sure to have a valid Schedulable reference for this Event to be scheduled with.");
                        return;
                    }
                    if (who.isScheduled()) {
                        this.sendWarning("Can\'t schedule Event! Command ignored.", "Entity : " + this.getName() + " Method: scheduleAfter(Schedulable after, " + "Entity who)", "The Entity \'" + who.getName() + "\'to be scheduled with this " + "Event is already scheduled.", "Use method reSchedule(TimeSpan dt) to shift the entity to be scheduled at some other point of time.");
                        return;
                    }
                    if (!after.isScheduled()) {
                        this.sendWarning("Can\'t schedule Event! Command ignored.", "Event : " + this.getName() + " Method: scheduleAfter(Schedulable after, " + "Entity who)", "The Schedulable \'" + after.getName() + "\' given as a positioning " + "reference has to be already scheduled but is not.", "Use method isScheduled() of any Schedulable to find out if it is already scheduled.");
                        return;
                    }
                    if (!this.isModelCompatible(who)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Entity : " + this.getName() + " Method: scheduleAfter(Schedulable after, " + "Entity who)", "The Entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    this.generateTraceForScheduling(who, null, null, after, null, /* get */ after.getEventNotes()[after.getEventNotes().length - 1].getTime(), null);
                    this.getModel().getExperiment().getScheduler().scheduleAfter$desmoj_core_simulator_Schedulable$desmoj_core_simulator_Entity$desmoj_core_simulator_EventAbstract(after, who, this);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("scheduleAfter " + after.getQuotedName() + " on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                /**
                 * Schedules this event to act on the given Entity directly before the given
                 * Schedulable is already set to be activated. Note that this event's point
                 * of simulation time will be set to be the same as the Schedulable's time.
                 * Thus this event will occur directly before the given Schedulable but the
                 * simulation clock will not change. Make sure that the Schedulable given as
                 * parameter is actually scheduled.
                 *
                 * @param {desmoj.core.simulator.Schedulable} before
                 * Schedulable : The Schedulable this entity should be scheduled
                 * before
                 * @param {desmoj.core.simulator.Entity} who
                 * E : The Entity to be manipulated by this event
                 */
                Event.prototype.scheduleBefore = function (before, who) {
                    if ((who == null)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored.", "Event : " + this.getName() + " Method: scheduleBefore(Schedulable before, " + "Entity who)", "The Entity given as parameter is a null reference.", "Be sure to have a valid Entity reference before calling this method.");
                        return;
                    }
                    if ((before == null)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored.", "Event : " + this.getName() + " Method: scheduleBefore(Schedulable before, " + "Entity who)", "The Schedulable given as parameter is a null reference.", "Be sure to have a valid Schedulable reference for this Event to be scheduled with.");
                        return;
                    }
                    if (who.isScheduled()) {
                        this.sendWarning("Can\'t schedule Event! Command ignored.", "Event : " + this.getName() + " Method: scheduleBefore(Schedulable before, " + "Entity who)", "The Entity \'" + who.getName() + "\'to be scheduled with this " + "Event is already scheduled.", "Use method reSchedule(TimeSpan dt) to shift the entity to be scheduled at some other point of time.");
                        return;
                    }
                    if (!before.isScheduled()) {
                        this.sendWarning("Can\'t schedule Event! Command ignored.", "Event : " + this.getName() + " Method: scheduleBefore(Schedulable after, " + "Entity who)", "The Schedulable \'" + before.getName() + "\' given as a " + "positioning reference has to be already scheduled but " + "is not.", "Use method isScheduled() of any Schedulable to find out if it is already scheduled.");
                        return;
                    }
                    if (!this.isModelCompatible(who)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Event : " + this.getName() + " Method: scheduleBeforer(Schedulable before, " + "Entity who)", "The Entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    this.generateTraceForScheduling(who, null, null, null, before, /* get */ before.getEventNotes()[0].getTime(), null);
                    this.getModel().getExperiment().getScheduler().scheduleBefore$desmoj_core_simulator_Schedulable$desmoj_core_simulator_Entity$desmoj_core_simulator_EventAbstract(before, who, this);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("scheduleBefore " + before.getQuotedName() + " on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                /**
                 * Creates and returns a copy of this event.
                 * Note that subclasses have to implement the interface
                 * <code>java.lang.Cloneable</code> to actually use this method as
                 * otherwise, a <code>CloneNotSupportedException</code> will be thrown.
                 *
                 * @return {desmoj.core.simulator.Event} Event<E> : A copy of this event.
                 */
                Event.prototype.clone = function () {
                    var _this = this;
                    return (function (o) { if (_super.prototype.clone != undefined) {
                        return _super.prototype.clone.call(_this);
                    }
                    else {
                        var clone = Object.create(o);
                        for (var p in o) {
                            if (o.hasOwnProperty(p))
                                clone[p] = o[p];
                        }
                        return clone;
                    } })(this);
                };
                return Event;
            }(desmoj.core.simulator.EventAbstract));
            simulator.Event = Event;
            Event["__class"] = "desmoj.core.simulator.Event";
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Creates a new Event of the given model, with the given name and trace
             * option.
             *
             * @param {string} name
             * java.lang.String : The name of this event
             * @param {desmoj.core.simulator.Model} owner
             * Model : The model this event is associated to
             * @param {boolean} showInTrace
             * boolean : Flag for showing Event in trace-files. Set it to
             * <code>true</code> if Event should show up in trace. Set it to
             * <code>false</code> if Event should not be shown in trace.
             * @class
             * @extends desmoj.core.simulator.EventAbstract
             * @author Tim Lechler
             */
            var EventOf2Entities = (function (_super) {
                __extends(EventOf2Entities, _super);
                function EventOf2Entities(owner, name, showInTrace) {
                    var _this = _super.call(this, owner, name, showInTrace) || this;
                    _this.numberOfEntities = 2;
                    return _this;
                }
                EventOf2Entities.prototype.eventRoutine = function (vanCarrier, truck) {
                    if (((vanCarrier != null) || vanCarrier === null) && ((truck != null) || truck === null)) {
                        return this.eventRoutine$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity(vanCarrier, truck);
                    }
                    else
                        throw new Error('invalid overload');
                };
                EventOf2Entities.prototype.eventRoutine$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity = function (who1, who2) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                EventOf2Entities.prototype.schedule$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_TimeInstant = function (who1, who2, instant) {
                    if ((instant == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: eventRoutine(E who1, F who2)", "The TimeInstant given as parameter is a null reference.", "Be sure to have a valid TimeInstant reference before calling this method.");
                        return;
                    }
                    if ((who1 == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: eventRoutine(E who1, F who2)", "The first entity given as parameter is a null reference.", "Be sure to have a valid Entity reference for this event to be scheduled with.");
                        return;
                    }
                    if ((who2 == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: eventRoutine(E who1, F who2)", "The second entity given as parameter is a null reference.", "Be sure to have a valid Entity reference for this event to be scheduled with.");
                        return;
                    }
                    if (!this.isModelCompatible(who1)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Entity : " + this.getName() + " Method: eventRoutine(E who1, F who2)", "The first entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    if (!this.isModelCompatible(who2)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Entity : " + this.getName() + " Method: eventRoutine(E who1, F who2)", "The second entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    this.generateTraceForScheduling(who1, who2, null, null, null, instant, null);
                    this.getModel().getExperiment().getScheduler().scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf2Entities$desmoj_core_simulator_TimeInstant(who1, who2, this, instant);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("schedules on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                /**
                 * Schedules this event to act on the given entities at a certain point in
                 * simulation time. No preemption, i.e. a process calling this method
                 * will continue until passivated or hold.
                 *
                 * @param {desmoj.core.simulator.Entity} who1
                 * E : The first entity to be manipulated by this event
                 * @param {desmoj.core.simulator.Entity} who2
                 * F : The second entity to be manipulated by this event
                 * @param {desmoj.core.simulator.TimeInstant} instant
                 * TimeInstant : The point in simulation time this event is
                 * scheduled to happen.
                 */
                EventOf2Entities.prototype.schedule = function (who1, who2, instant) {
                    if (((who1 != null) || who1 === null) && ((who2 != null) || who2 === null) && ((instant != null && instant instanceof desmoj.core.simulator.TimeInstant) || instant === null)) {
                        return this.schedule$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_TimeInstant(who1, who2, instant);
                    }
                    else if (((who1 != null) || who1 === null) && ((who2 != null) || who2 === null) && ((instant != null && instant instanceof desmoj.core.simulator.TimeSpan) || instant === null)) {
                        return this.schedule$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_TimeSpan(who1, who2, instant);
                    }
                    else if (((who1 != null) || who1 === null) && ((who2 != null) || who2 === null) && ((instant != null && instant instanceof desmoj.core.dist.NumericalDist) || instant === null)) {
                        return this.schedule$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_dist_NumericalDist(who1, who2, instant);
                    }
                    else if (((who1 != null) || who1 === null) && ((who2 != null) || who2 === null) && instant === undefined) {
                        return this.schedule$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity(who1, who2);
                    }
                    else
                        throw new Error('invalid overload');
                };
                EventOf2Entities.prototype.schedule$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_TimeSpan = function (who1, who2, dt) {
                    if ((dt == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: schedule(E who1, F who2, TimeSpan dt)", "The TimeSpan given as parameter is a null reference.", "Be sure to have a valid TimeSpan reference before calling this method.");
                        return;
                    }
                    if ((who1 == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: schedule(E who1, F who2, TimeSpan dt)", "The first entity given as parameter is a null reference.", "Be sure to have a valid Entity reference for this event to be scheduled with.");
                        return;
                    }
                    if ((who2 == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: schedule(E who1, F who2, TimeSpan dt)", "The second entity given as parameter is a null reference.", "Be sure to have a valid Entity reference for this event to be scheduled with.");
                        return;
                    }
                    if (!this.isModelCompatible(who1)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Entity : " + this.getName() + " Method: schedule(E who1, F who2, TimeSpan dt)", "The first entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    if (!this.isModelCompatible(who2)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Entity : " + this.getName() + " Method: schedule(E who1, F who2, TimeSpan dt)", "The second entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    this.generateTraceForScheduling(who1, who2, null, null, null, desmoj.core.simulator.TimeOperations.add$desmoj_core_simulator_TimeInstant$desmoj_core_simulator_TimeSpan(this.presentTime(), dt), null);
                    this.getModel().getExperiment().getScheduler().scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf2Entities$desmoj_core_simulator_TimeSpan(who1, who2, this, dt);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("schedules on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                EventOf2Entities.prototype.schedule$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity = function (who1, who2) {
                    if ((who1 == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: schedule(E who1, F who2)", "The first entity given as parameter is a null reference.", "Be sure to have a valid Entity reference for this event to be scheduled with.");
                        return;
                    }
                    if ((who2 == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: schedule(E who1, F who2)", "The second entity given as parameter is a null reference.", "Be sure to have a valid Entity reference for this event to be scheduled with.");
                        return;
                    }
                    if (!this.isModelCompatible(who1)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Entity : " + this.getName() + " Method: schedule(E who1, F who2)", "The first entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    if (!this.isModelCompatible(who2)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Entity : " + this.getName() + " Method: schedule(E who1, F who2)", "The second entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    this.generateTraceForScheduling(who1, who2, null, null, null, this.presentTime(), null);
                    this.getModel().getExperiment().getScheduler().scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf2Entities$desmoj_core_simulator_TimeInstant(who1, who2, this, this.presentTime());
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("schedules on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                EventOf2Entities.prototype.schedule$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_dist_NumericalDist = function (who1, who2, dist) {
                    if ((dist == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: schedule(E who1, F who2, NumericalDist<?> dist)", "The NumericalDist given as parameter is a null reference.", "Be sure to have a valid NumericalDist reference before calling this method.");
                        return;
                    }
                    if ((who1 == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: schedule(E who1, F who2, NumericalDist<?> dist)", "The first entity given as parameter is a null reference.", "Be sure to have a valid Entity reference for this event to be scheduled with.");
                        return;
                    }
                    if ((who2 == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: schedule(E who1, F who2, NumericalDist<?> dist)", "The second entity given as parameter is a null reference.", "Be sure to have a valid Entity reference for this event to be scheduled with.");
                        return;
                    }
                    if (!this.isModelCompatible(who1)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Entity : " + this.getName() + " Method: schedule(E who1, F who2, NumericalDist<?> dist)", "The first entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    if (!this.isModelCompatible(who2)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Entity : " + this.getName() + " Method: schedule(E who1, F who2, NumericalDist<?> dist)", "The second entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    var dt = dist.sampleTimeSpan();
                    this.generateTraceForScheduling(who1, who2, null, null, null, desmoj.core.simulator.TimeOperations.add$desmoj_core_simulator_TimeInstant$desmoj_core_simulator_TimeSpan(this.presentTime(), dt), " Sampled from " + dist.getQuotedName() + ".");
                    this.getModel().getExperiment().getScheduler().scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf2Entities$desmoj_core_simulator_TimeSpan(who1, who2, this, dt);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("schedules on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                /**
                 * Schedules this event to act on the given Entity directly after the given
                 * Schedulable is already set to be activated. Note that this event's point
                 * of simulation time will be set to be the same as the Schedulable's time.
                 * Thus this event will occur directly after the given Schedulable but the
                 * simulation clock will not change. Make sure that the Schedulable given as
                 * parameter is actually scheduled.
                 *
                 * @param {desmoj.core.simulator.Schedulable} after
                 * Schedulable : The Schedulable this entity should be scheduled
                 * after
                 * @param {desmoj.core.simulator.Entity} who1
                 * E : The first entity to be manipulated by this event
                 * @param {desmoj.core.simulator.Entity} who2
                 * F : The second entity to be manipulated by this event
                 */
                EventOf2Entities.prototype.scheduleAfter = function (after, who1, who2) {
                    if (who1 == null) {
                        this.sendWarning("Can\'t schedule Event! Command ignored.", "Event : " + this.getName() + " Method: scheduleAfter(Schedulable after, E who1, F who2)", "The Entity \'who1\' given as parameter is a null reference.", "Be sure to have a valid Entity reference before calling this method.");
                        return;
                    }
                    if (who2 == null) {
                        this.sendWarning("Can\'t schedule Event! Command ignored.", "Event : " + this.getName() + " Method: scheduleAfter(Schedulable after, E who1, F who2)", "The second entity \'who\' given as parameter is a null reference.", "Be sure to have a valid Entity reference before calling this method.");
                        return;
                    }
                    if (after == null) {
                        this.sendWarning("Can\'t schedule Event! Command ignored.", "Event : " + this.getName() + " Method: scheduleAfter(Schedulable after, E who1, F who2)", "The Schedulable given as parameter is a null reference.", "Be sure to have a valid Schedulable reference for this Event to be scheduled with.");
                        return;
                    }
                    if (!after.isScheduled()) {
                        this.sendWarning("Can\'t schedule Event! Command ignored.", "Event : " + this.getName() + " Method: scheduleAfter(Schedulable after, E who1, F who2)", "The Schedulable \'" + after.getName() + "\' given as a positioning " + "reference has to be already scheduled but is not.", "Use method isScheduled() of any Schedulable to find out if it is already scheduled.");
                        return;
                    }
                    if (!this.isModelCompatible(who1)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Entity : " + this.getName() + " Method: scheduleAfter(Schedulable after, E who1, F who2)", "The first entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    if (!this.isModelCompatible(who2)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Entity : " + this.getName() + " Method: scheduleAfter(Schedulable after, E who1, F who2)", "The second entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    this.generateTraceForScheduling(who1, who2, null, after, null, /* get */ after.getEventNotes()[after.getEventNotes().length - 1].getTime(), null);
                    this.getModel().getExperiment().getScheduler().scheduleAfter$desmoj_core_simulator_Schedulable$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf2Entities(after, who1, who2, this);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("scheduleAfter " + after.getQuotedName() + " on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                /**
                 * Schedules this event to act on the given Entity directly before the given
                 * Schedulable is already set to be activated. Note that this event's point
                 * of simulation time will be set to be the same as the Schedulable's time.
                 * Thus this event will occur directly before the given Schedulable but the
                 * simulation clock will not change. Make sure that the Schedulable given as
                 * parameter is actually scheduled.
                 *
                 * @param {desmoj.core.simulator.Schedulable} before
                 * Schedulable : The Schedulable this entity should be scheduled
                 * before
                 * @param {desmoj.core.simulator.Entity} who1
                 * E : The first entity to be manipulated by this event
                 * @param {desmoj.core.simulator.Entity} who2
                 * F : The second entity to be manipulated by this event
                 */
                EventOf2Entities.prototype.scheduleBefore = function (before, who1, who2) {
                    if ((who1 == null)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored.", "Event : " + this.getName() + " Method: scheduleBefore(Schedulable before, E who1, F who2)", "The Entity \'who1\' given as parameter is a null reference.", "Be sure to have a valid Entity reference before calling this method.");
                        return;
                    }
                    if ((who2 == null)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored.", "Event : " + this.getName() + " Method: scheduleBefore(Schedulable before, E who1, F who2)", "The Entity \'who2\' given as parameter is a null reference.", "Be sure to have a valid Entity reference before calling this method.");
                        return;
                    }
                    if ((before == null)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored.", "Event : " + this.getName() + " Method: scheduleBefore(Schedulable before, E who1, F who2)", "The Schedulable given as parameter is a null reference.", "Be sure to have a valid Schedulable reference for this Event to be scheduled with.");
                        return;
                    }
                    if (!before.isScheduled()) {
                        this.sendWarning("Can\'t schedule Event! Command ignored.", "Event : " + this.getName() + " Method: scheduleBefore(Schedulable before, E who1, F who2)", "The Schedulable \'" + before.getName() + "\' given as a " + "positioning reference has to be already scheduled but " + "is not.", "Use method isScheduled() of any Schedulable to find out if it is already scheduled.");
                        return;
                    }
                    if (!this.isModelCompatible(who1)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Event : " + this.getName() + " Method: scheduleBefore(Schedulable before, E who1, F who2)", "The first entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    if (!this.isModelCompatible(who2)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Event : " + this.getName() + " Method: scheduleBefore(Schedulable before, E who1, F who2)", "The second entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    this.generateTraceForScheduling(who1, who2, null, null, before, /* get */ before.getEventNotes()[0].getTime(), null);
                    this.getModel().getExperiment().getScheduler().scheduleBefore$desmoj_core_simulator_Schedulable$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf2Entities(before, who1, who2, this);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("scheduleBefore " + before.getQuotedName() + " on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                /**
                 * Creates and returns a copy of this event.
                 * Note that subclasses have to implement the interface
                 * <code>java.lang.Cloneable</code> to actually use this method as
                 * otherwise, a <code>CloneNotSupportedException</code> will be thrown.
                 *
                 * @return {desmoj.core.simulator.EventOf2Entities} EventOf2Entities<E,F> : A copy of this event.
                 */
                EventOf2Entities.prototype.clone = function () {
                    var _this = this;
                    return (function (o) { if (_super.prototype.clone != undefined) {
                        return _super.prototype.clone.call(_this);
                    }
                    else {
                        var clone = Object.create(o);
                        for (var p in o) {
                            if (o.hasOwnProperty(p))
                                clone[p] = o[p];
                        }
                        return clone;
                    } })(this);
                };
                return EventOf2Entities;
            }(desmoj.core.simulator.EventAbstract));
            simulator.EventOf2Entities = EventOf2Entities;
            EventOf2Entities["__class"] = "desmoj.core.simulator.EventOf2Entities";
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Creates a new Event of the given model, with the given name and trace
             * option.
             *
             * @param {string} name
             * java.lang.String : The name of this event
             * @param {desmoj.core.simulator.Model} owner
             * Model : The model this event is associated to
             * @param {boolean} showInTrace
             * boolean : Flag for showing Event in trace-files. Set it to
             * <code>true</code> if Event should show up in trace. Set it to
             * <code>false</code> if Event should not be shown in trace.
             * @class
             * @extends desmoj.core.simulator.EventAbstract
             * @author Tim Lechler
             */
            var EventOf3Entities = (function (_super) {
                __extends(EventOf3Entities, _super);
                function EventOf3Entities(owner, name, showInTrace) {
                    var _this = _super.call(this, owner, name, showInTrace) || this;
                    _this.numberOfEntities = 3;
                    return _this;
                }
                EventOf3Entities.prototype.schedule$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_TimeInstant = function (who1, who2, who3, instant) {
                    if ((instant == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: eventRoutine(E who1, F who2, G who3)", "The TimeInstant given as parameter is a null reference.", "Be sure to have a valid TimeInstant reference before calling this method.");
                        return;
                    }
                    if ((who1 == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: eventRoutine(E who1, F who2, G who3)", "The first entity given as parameter is a null reference.", "Be sure to have a valid Entity reference for this event to be scheduled with.");
                        return;
                    }
                    if ((who2 == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: eventRoutine(E who1, F who2, G who3)", "The second entity given as parameter is a null reference.", "Be sure to have a valid Entity reference for this event to be scheduled with.");
                        return;
                    }
                    if ((who3 == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: eventRoutine(E who1, F who2, G who3)", "The third entity given as parameter is a null reference.", "Be sure to have a valid Entity reference for this event to be scheduled with.");
                        return;
                    }
                    if (!this.isModelCompatible(who1)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Entity : " + this.getName() + " Method: eventRoutine(E who1, F who2, G who3)", "The first entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    if (!this.isModelCompatible(who2)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Entity : " + this.getName() + " Method: eventRoutine(E who1, F who2, G who3)", "The second entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    if (!this.isModelCompatible(who3)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Entity : " + this.getName() + " Method: eventRoutine(E who1, F who2, G who3)", "The third entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    this.generateTraceForScheduling(who1, who2, who3, null, null, instant, null);
                    this.getModel().getExperiment().getScheduler().scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf3Entities$desmoj_core_simulator_TimeInstant(who1, who2, who3, this, instant);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("schedules on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                /**
                 * Schedules this event to act on the given entities at a certain point in
                 * simulation time. No preemption, i.e. a process calling this method
                 * will continue until passivated or hold.
                 *
                 * @param {desmoj.core.simulator.Entity} who1
                 * E : The first entity to be manipulated by this event
                 * @param {desmoj.core.simulator.Entity} who2
                 * F : The second entity to be manipulated by this event
                 * @param {desmoj.core.simulator.Entity} who3
                 * G : The third entity to be manipulated by this event
                 * @param {desmoj.core.simulator.TimeInstant} instant
                 * TimeInstant : The point in simulation time this event is
                 * scheduled to happen.
                 */
                EventOf3Entities.prototype.schedule = function (who1, who2, who3, instant) {
                    if (((who1 != null) || who1 === null) && ((who2 != null) || who2 === null) && ((who3 != null) || who3 === null) && ((instant != null && instant instanceof desmoj.core.simulator.TimeInstant) || instant === null)) {
                        return this.schedule$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_TimeInstant(who1, who2, who3, instant);
                    }
                    else if (((who1 != null) || who1 === null) && ((who2 != null) || who2 === null) && ((who3 != null) || who3 === null) && ((instant != null && instant instanceof desmoj.core.simulator.TimeSpan) || instant === null)) {
                        return this.schedule$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_TimeSpan(who1, who2, who3, instant);
                    }
                    else if (((who1 != null) || who1 === null) && ((who2 != null) || who2 === null) && ((who3 != null) || who3 === null) && ((instant != null && instant instanceof desmoj.core.dist.NumericalDist) || instant === null)) {
                        return this.schedule$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_dist_NumericalDist(who1, who2, who3, instant);
                    }
                    else if (((who1 != null) || who1 === null) && ((who2 != null) || who2 === null) && ((who3 != null) || who3 === null) && instant === undefined) {
                        return this.schedule$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity(who1, who2, who3);
                    }
                    else
                        throw new Error('invalid overload');
                };
                EventOf3Entities.prototype.schedule$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_TimeSpan = function (who1, who2, who3, dt) {
                    if ((dt == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: schedule(E who1, F who2, G who3, TimeSpan dt)", "The TimeSpan given as parameter is a null reference.", "Be sure to have a valid TimeSpan reference before calling this method.");
                        return;
                    }
                    if ((who1 == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: schedule(E who1, F who2, G who3, TimeSpan dt)", "The first entity given as parameter is a null reference.", "Be sure to have a valid Entity reference for this event to be scheduled with.");
                        return;
                    }
                    if ((who2 == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: schedule(E who1, F who2, G who3, TimeSpan dt)", "The second entity given as parameter is a null reference.", "Be sure to have a valid Entity reference for this event to be scheduled with.");
                        return;
                    }
                    if ((who3 == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: schedule(E who1, F who2, G who3, TimeSpan dt)", "The third entity given as parameter is a null reference.", "Be sure to have a valid Entity reference for this event to be scheduled with.");
                        return;
                    }
                    if (!this.isModelCompatible(who1)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Entity : " + this.getName() + " Method: schedule(E who1, F who2, G who3, TimeSpan dt)", "The first entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    if (!this.isModelCompatible(who2)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Entity : " + this.getName() + " Method: schedule(E who1, F who2, G who3, TimeSpan dt)", "The second entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    if (!this.isModelCompatible(who3)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Entity : " + this.getName() + " Method: schedule(E who1, F who2, G who3, TimeSpan dt)", "The third entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    this.generateTraceForScheduling(who1, who2, who3, null, null, desmoj.core.simulator.TimeOperations.add$desmoj_core_simulator_TimeInstant$desmoj_core_simulator_TimeSpan(this.presentTime(), dt), null);
                    this.getModel().getExperiment().getScheduler().scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf3Entities$desmoj_core_simulator_TimeSpan(who1, who2, who3, this, dt);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("schedules on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                EventOf3Entities.prototype.schedule$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity = function (who1, who2, who3) {
                    if ((who1 == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: schedule(E who1, F who2, G who3)", "The first entity given as parameter is a null reference.", "Be sure to have a valid Entity reference for this event to be scheduled with.");
                        return;
                    }
                    if ((who2 == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: schedule(E who1, F who2, G who3)", "The second entity given as parameter is a null reference.", "Be sure to have a valid Entity reference for this event to be scheduled with.");
                        return;
                    }
                    if ((who3 == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: schedule(E who1, F who2, G who3)", "The third entity given as parameter is a null reference.", "Be sure to have a valid Entity reference for this event to be scheduled with.");
                        return;
                    }
                    if (!this.isModelCompatible(who1)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Entity : " + this.getName() + " Method: schedule(E who1, F who2, G who3)", "The first entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    if (!this.isModelCompatible(who2)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Entity : " + this.getName() + " Method: schedule(E who1, F who2, G who3)", "The second entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    if (!this.isModelCompatible(who3)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Entity : " + this.getName() + " Method: schedule(E who1, F who2, G who3)", "The third entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    this.generateTraceForScheduling(who1, who2, who3, null, null, this.presentTime(), null);
                    this.getModel().getExperiment().getScheduler().scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf3Entities$desmoj_core_simulator_TimeInstant(who1, who2, who3, this, this.presentTime());
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("schedules on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                EventOf3Entities.prototype.schedule$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_dist_NumericalDist = function (who1, who2, who3, dist) {
                    if ((dist == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: schedule(E who1, F who2, G who3, NumericalDist<?> dist)", "The NumericalDist given as parameter is a null reference.", "Be sure to have a valid NumericalDist reference before calling this method.");
                        return;
                    }
                    if ((who1 == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: schedule(E who1, F who2, G who3, NumericalDist<?> dist)", "The first entity given as parameter is a null reference.", "Be sure to have a valid Entity reference for this event to be scheduled with.");
                        return;
                    }
                    if ((who2 == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: schedule(E who1, F who2, G who3, NumericalDist<?> dist)", "The second entity given as parameter is a null reference.", "Be sure to have a valid Entity reference for this event to be scheduled with.");
                        return;
                    }
                    if ((who3 == null)) {
                        this.sendWarning("Can\'t schedule Event!", "Event : " + this.getName() + " Method: schedule(E who1, F who2, G who3, NumericalDist<?> dist)", "The third entity given as parameter is a null reference.", "Be sure to have a valid Entity reference for this event to be scheduled with.");
                        return;
                    }
                    if (!this.isModelCompatible(who1)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Entity : " + this.getName() + " Method: schedule(E who1, F who2, G who3, NumericalDist<?> dist)", "The first entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    if (!this.isModelCompatible(who2)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Entity : " + this.getName() + " Method: schedule(E who1, F who2, G who3, NumericalDist<?> dist)", "The second entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    if (!this.isModelCompatible(who3)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Entity : " + this.getName() + " Method: schedule(E who1, F who2, G who3, NumericalDist<?> dist)", "The third entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    var dt = dist.sampleTimeSpan();
                    this.generateTraceForScheduling(who1, who2, who3, null, null, desmoj.core.simulator.TimeOperations.add$desmoj_core_simulator_TimeInstant$desmoj_core_simulator_TimeSpan(this.presentTime(), dt), " Sampled from " + dist.getQuotedName() + ".");
                    this.getModel().getExperiment().getScheduler().scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf3Entities$desmoj_core_simulator_TimeSpan(who1, who2, who3, this, dt);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("schedules on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                /**
                 * Schedules this event to act on the given Entities directly after the given
                 * Schedulable is already set to be activated. Note that this event's point
                 * of simulation time will be set to be the same as the Schedulable's time.
                 * Thus this event will occur directly after the given Schedulable but the
                 * simulation clock will not change. Make sure that the Schedulable given as
                 * parameter is actually scheduled.
                 *
                 * @param {desmoj.core.simulator.Schedulable} after
                 * Schedulable : The Schedulable this entity should be scheduled
                 * after
                 * @param {desmoj.core.simulator.Entity} who1
                 * E : The first entity to be manipulated by this event
                 * @param {desmoj.core.simulator.Entity} who2
                 * F : The second entity to be manipulated by this event
                 * @param {desmoj.core.simulator.Entity} who3
                 * G : The third entity to be manipulated by this event
                 */
                EventOf3Entities.prototype.scheduleAfter = function (after, who1, who2, who3) {
                    if (who1 == null) {
                        this.sendWarning("Can\'t schedule Event! Command ignored.", "Event : " + this.getName() + " Method: scheduleAfter(Schedulable after, E who1, F who2, G who3)", "The Entity \'who1\' given as parameter is a null reference.", "Be sure to have a valid Entity reference before calling this method.");
                        return;
                    }
                    if (who2 == null) {
                        this.sendWarning("Can\'t schedule Event! Command ignored.", "Event : " + this.getName() + " Method: scheduleAfter(Schedulable after, E who1, F who2, G who3)", "The Entity \'who2\' given as parameter is a null reference.", "Be sure to have a valid Entity reference before calling this method.");
                        return;
                    }
                    if (who3 == null) {
                        this.sendWarning("Can\'t schedule Event! Command ignored.", "Event : " + this.getName() + " Method: scheduleAfter(Schedulable after, E who1, F who2, G who3)", "The Entity \'who3\' given as parameter is a null reference.", "Be sure to have a valid Entity reference before calling this method.");
                        return;
                    }
                    if (after == null) {
                        this.sendWarning("Can\'t schedule Event! Command ignored.", "Event : " + this.getName() + " Method: scheduleAfter(Schedulable after, E who1, F who2, G who3)", "The Schedulable given as parameter is a null reference.", "Be sure to have a valid Schedulable reference for this Event to be scheduled with.");
                        return;
                    }
                    if (!after.isScheduled()) {
                        this.sendWarning("Can\'t schedule Event! Command ignored.", "Event : " + this.getName() + " Method: scheduleAfter(Schedulable after, E who1, F who2, G who3)", "The Schedulable \'" + after.getName() + "\' given as a positioning " + "reference has to be already scheduled but is not.", "Use method isScheduled() of any Schedulable to find out if it is already scheduled.");
                        return;
                    }
                    if (!this.isModelCompatible(who1)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Entity : " + this.getName() + " Method: scheduleAfter(Schedulable after, E who1, F who2, G who3)", "The first Entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    if (!this.isModelCompatible(who2)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Entity : " + this.getName() + " Method: scheduleAfter(Schedulable after, E who1, F who2, G who3)", "The second entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    if (!this.isModelCompatible(who3)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Entity : " + this.getName() + " Method: scheduleAfter(Schedulable after, E who1, F who2, G who3)", "The third entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    this.generateTraceForScheduling(who1, who2, who3, after, null, /* get */ after.getEventNotes()[after.getEventNotes().length - 1].getTime(), null);
                    this.getModel().getExperiment().getScheduler().scheduleAfter$desmoj_core_simulator_Schedulable$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf3Entities(after, who1, who2, who3, this);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("scheduleAfter " + after.getQuotedName() + " on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                /**
                 * Schedules this event to act on the given Entities directly before the given
                 * Schedulable is already set to be activated. Note that this event's point
                 * of simulation time will be set to be the same as the Schedulable's time.
                 * Thus this event will occur directly before the given Schedulable but the
                 * simulation clock will not change. Make sure that the Schedulable given as
                 * parameter is actually scheduled.
                 *
                 * @param {desmoj.core.simulator.Schedulable} before
                 * Schedulable : The Schedulable this entity should be scheduled
                 * before
                 * @param {desmoj.core.simulator.Entity} who1
                 * E : The first entity to be manipulated by this event
                 * @param {desmoj.core.simulator.Entity} who2
                 * F : The second entity to be manipulated by this event
                 * @param {desmoj.core.simulator.Entity} who3
                 * G : The third entity to be manipulated by this event
                 */
                EventOf3Entities.prototype.scheduleBefore = function (before, who1, who2, who3) {
                    if (who1 == null) {
                        this.sendWarning("Can\'t schedule Event! Command ignored.", "Event : " + this.getName() + " Method: scheduleBefore(Schedulable after, E who1, F who2, G who3)", "The Entity \'who1\' given as parameter is a null reference.", "Be sure to have a valid Entity reference before calling this method.");
                        return;
                    }
                    if (who2 == null) {
                        this.sendWarning("Can\'t schedule Event! Command ignored.", "Event : " + this.getName() + " Method: scheduleBefore(Schedulable after, E who1, F who2, G who3)", "The Entity \'who2\' given as parameter is a null reference.", "Be sure to have a valid Entity reference before calling this method.");
                        return;
                    }
                    if (who3 == null) {
                        this.sendWarning("Can\'t schedule Event! Command ignored.", "Event : " + this.getName() + " Method: scheduleBefore(Schedulable after, E who1, F who2, G who3)", "The Entity \'who3\' given as parameter is a null reference.", "Be sure to have a valid Entity reference before calling this method.");
                        return;
                    }
                    if ((before == null)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored.", "Event : " + this.getName() + " Method: scheduleBefore(Schedulable before, E who1, F who2, G who3)", "The Schedulable given as parameter is a null reference.", "Be sure to have a valid Schedulable reference for this Event to be scheduled with.");
                        return;
                    }
                    if (!before.isScheduled()) {
                        this.sendWarning("Can\'t schedule Event! Command ignored.", "Event : " + this.getName() + " Method: scheduleBefore(Schedulable after, " + " Method: scheduleBefore(Schedulable before, E who1, F who2, G who3)", "The Schedulable \'" + before.getName() + "\' given as a " + "positioning reference has to be already scheduled but " + "is not.", "Use method isScheduled() of any Schedulable to find out if it is already scheduled.");
                        return;
                    }
                    if (!this.isModelCompatible(who1)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Event : " + this.getName() + " Method: scheduleBefore(Schedulable before, E who1, F who2, G who3)", "The first entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    if (!this.isModelCompatible(who2)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Event : " + this.getName() + " Method: scheduleBefore(Schedulable before, E who1, F who2, G who3)", "The second entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    if (!this.isModelCompatible(who3)) {
                        this.sendWarning("Can\'t schedule Event! Command ignored", "Event : " + this.getName() + " Method: scheduleBefore(Schedulable before, E who1, F who2, G who3)", "The third entity to be scheduled with this event is not modelcompatible.", "Make sure to use compatible model components only.");
                        return;
                    }
                    this.generateTraceForScheduling(who1, who2, who3, null, before, /* get */ before.getEventNotes()[0].getTime(), null);
                    this.getModel().getExperiment().getScheduler().scheduleBefore$desmoj_core_simulator_Schedulable$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity$desmoj_core_simulator_EventOf3Entities(before, who1, who2, who3, this);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("scheduleBefore " + before.getQuotedName() + " on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                /**
                 * Creates and returns a copy of this event.
                 * Note that subclasses have to implement the interface
                 * <code>java.lang.Cloneable</code> to actually use this method as
                 * otherwise, a <code>CloneNotSupportedException</code> will be thrown.
                 *
                 * @return {desmoj.core.simulator.EventOf3Entities} EventOf3Entities<E,F,G> : A copy of this event.
                 */
                EventOf3Entities.prototype.clone = function () {
                    var _this = this;
                    return (function (o) { if (_super.prototype.clone != undefined) {
                        return _super.prototype.clone.call(_this);
                    }
                    else {
                        var clone = Object.create(o);
                        for (var p in o) {
                            if (o.hasOwnProperty(p))
                                clone[p] = o[p];
                        }
                        return clone;
                    } })(this);
                };
                return EventOf3Entities;
            }(desmoj.core.simulator.EventAbstract));
            simulator.EventOf3Entities = EventOf3Entities;
            EventOf3Entities["__class"] = "desmoj.core.simulator.EventOf3Entities";
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Creates an external event for the given model with the given name and the
             * specified tracemode.
             *
             * @param {desmoj.core.simulator.Model} owner
             * Model : The external event's model
             * @param {string} name
             * java.lang.String : The external event's name
             * @param {boolean} showInTrace
             * boolean : Flag for showing this external event in
             * tracemessages
             * @class
             * @extends desmoj.core.simulator.EventAbstract
             * @author Tim Lechler
             */
            var ExternalEvent = (function (_super) {
                __extends(ExternalEvent, _super);
                function ExternalEvent(owner, name, showInTrace) {
                    var _this = _super.call(this, owner, name, showInTrace) || this;
                    _this.numberOfEntities = 0;
                    return _this;
                }
                ExternalEvent.prototype.eventRoutine = function (who) {
                    if (who === undefined) {
                        return this.eventRoutine$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                ExternalEvent.prototype.eventRoutine$ = function () { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); };
                ExternalEvent.prototype.schedule$desmoj_core_simulator_TimeSpan = function (dt) {
                    if ((dt == null)) {
                        this.sendWarning("Can\'t schedule external event!", "ExternalEvent : " + this.getName() + " Method: schedule(Entity who, TimeSpan dt)", "The simulation time given as parameter is a null reference.", "Be sure to have a valid TimeSpan reference before calling this method.");
                        return;
                    }
                    this.generateTraceForScheduling(null, null, null, null, null, desmoj.core.simulator.TimeOperations.add$desmoj_core_simulator_TimeInstant$desmoj_core_simulator_TimeSpan(this.presentTime(), dt), null);
                    this.getModel().getExperiment().getScheduler().scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_EventAbstract$desmoj_core_simulator_TimeSpan(null, this, dt);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("schedules on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                /**
                 * Schedules this external event to make the desired changes to the
                 * experiment or model at the current point of time plus the given span of
                 * time. No preemption, i.e. a process calling this method
                 * will continue until passivated or hold.
                 *
                 * @param {desmoj.core.simulator.TimeSpan} dt
                 * TimeSpan : The offset to the current simulation time at which
                 * this external event is to be scheduled
                 * @see SimClock
                 */
                ExternalEvent.prototype.schedule = function (dt) {
                    if (((dt != null && dt instanceof desmoj.core.simulator.TimeSpan) || dt === null)) {
                        return this.schedule$desmoj_core_simulator_TimeSpan(dt);
                    }
                    else if (((dt != null && dt instanceof desmoj.core.dist.NumericalDist) || dt === null)) {
                        return this.schedule$desmoj_core_dist_NumericalDist(dt);
                    }
                    else if (((dt != null && dt instanceof desmoj.core.simulator.TimeInstant) || dt === null)) {
                        return this.schedule$desmoj_core_simulator_TimeInstant(dt);
                    }
                    else if (dt === undefined) {
                        return this.schedule$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                ExternalEvent.prototype.schedule$ = function () {
                    this.generateTraceForScheduling(null, null, null, null, null, this.presentTime(), null);
                    this.getModel().getExperiment().getScheduler().scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_EventAbstract$desmoj_core_simulator_TimeInstant(null, this, this.presentTime());
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("schedules on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                ExternalEvent.prototype.schedule$desmoj_core_dist_NumericalDist = function (dist) {
                    if ((dist == null)) {
                        this.sendWarning("Can\'t schedule external event!", "ExternalEvent : " + this.getName() + " Method: schedule(Entity who, NumericalDist<?> dist)", "The NumericalDist given as parameter is a null reference.", "Be sure to have a valid NumericalDist reference before calling this method.");
                        return;
                    }
                    var dt = dist.sampleTimeSpan();
                    this.generateTraceForScheduling(null, null, null, null, null, desmoj.core.simulator.TimeOperations.add$desmoj_core_simulator_TimeInstant$desmoj_core_simulator_TimeSpan(this.presentTime(), dt), " Sampled from " + dist.getQuotedName() + ".");
                    this.getModel().getExperiment().getScheduler().scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_EventAbstract$desmoj_core_simulator_TimeSpan(null, this, dt);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("schedules on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                ExternalEvent.prototype.schedule$desmoj_core_simulator_TimeInstant = function (when) {
                    if ((when == null)) {
                        this.sendWarning("Can\'t schedule external event!", "ExternalEvent : " + this.getName() + " Method: schedule(Entity who, TimeInstant when)", "The point of simulation time given as parameter is a null reference.", "Be sure to have a valid TimeInstant reference before calling this method.");
                        return;
                    }
                    this.generateTraceForScheduling(null, null, null, null, null, when, null);
                    this.getModel().getExperiment().getScheduler().scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_EventAbstract$desmoj_core_simulator_TimeInstant(null, this, when);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("schedules on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                /**
                 * Schedules this external event to act on the experiment or model state
                 * directly after the given Schedulable is already set to be activated. Note
                 * that this external event's point of simulation time will be set to be the
                 * same as the Schedulable's time. Thus this external event will occur
                 * directly after the given Schedulable but the simulation clock will not
                 * change. Make sure that the Schedulable given as parameter is actually
                 * scheduled.
                 *
                 * @param {desmoj.core.simulator.Schedulable} after
                 * Schedulable : The Schedulable this external event should be
                 * scheduled after
                 */
                ExternalEvent.prototype.scheduleAfter = function (after) {
                    if ((after == null)) {
                        this.sendWarning("Can\'t schedule external event! Command ignored.", "ExternalEvent : " + this.getName() + " Method: scheduleAfter(Schedulable after, " + "Entity who)", "The Schedulable given as parameter is a null reference.", "Be sure to have a valid Schedulable reference for this external event to be scheduled with.");
                        return;
                    }
                    if (!after.isScheduled()) {
                        this.sendWarning("Can\'t schedule external event! Command ignored.", "ExternalEvent : " + this.getName() + " Method: scheduleAfter(Schedulable after)", "The Schedulable \'" + after.getName() + "\' given as a positioning " + "reference has to be already scheduled but is not.", "Use method isScheduled() of any Schedulable to find out if it is already scheduled.");
                        return;
                    }
                    this.generateTraceForScheduling(null, null, null, after, null, /* get */ after.getEventNotes()[after.getEventNotes().length - 1].getTime(), null);
                    this.getModel().getExperiment().getScheduler().scheduleAfter$desmoj_core_simulator_Schedulable$desmoj_core_simulator_Entity$desmoj_core_simulator_EventAbstract(after, null, this);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("scheduleAfter " + after.getQuotedName() + " on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                /**
                 * Schedules this external event to act on the experiment or model state
                 * directly before the given Schedulable is already set to be activated.
                 * Note that this external event's point of simulation time will be set to
                 * be the same as the Schedulable's time. Thus this external event will
                 * occur directly before the given Schedulable but the simulation clock will
                 * not change. Make sure that the Schedulable given as parameter is actually
                 * scheduled.
                 *
                 * @param {desmoj.core.simulator.Schedulable} before
                 * Schedulable : The Schedulable this external event should be
                 * scheduled before
                 */
                ExternalEvent.prototype.scheduleBefore = function (before) {
                    if ((before == null)) {
                        this.sendWarning("Can\'t schedule external event! Command ignored.", "ExternalEvent : " + this.getName() + " Method: scheduleBefore(Schedulable before, " + "Entity who)", "The Schedulable given as parameter is a null reference.", "Be sure to have a valid Schedulable reference for this external event to be scheduled with.");
                        return;
                    }
                    if (!before.isScheduled()) {
                        this.sendWarning("Can\'t schedule external event! Command ignored.", "ExternalEvent : " + this.getName() + " Method: scheduleBefore(Schedulable before)", "The Schedulable \'" + before.getName() + "\' given as a " + "positioning reference has to be already " + "scheduled but is not.", "Use method isScheduled() of any Schedulable to find out if it is already scheduled.");
                        return;
                    }
                    this.generateTraceForScheduling(null, null, null, null, before, /* get */ before.getEventNotes()[0].getTime(), null);
                    this.getModel().getExperiment().getScheduler().scheduleBefore$desmoj_core_simulator_Schedulable$desmoj_core_simulator_Entity$desmoj_core_simulator_EventAbstract(before, null, this);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("scheduleBefore " + before.getQuotedName() + " on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                /**
                 * Creates and returns a copy of this event.
                 * Note that subclasses have to implement the interface
                 * <code>java.lang.Cloneable</code> to actually use this method as
                 * otherwise, a <code>CloneNotSupportedException</code> will be thrown.
                 *
                 * @return {desmoj.core.simulator.ExternalEvent} ExternalEvent : A copy of this event.
                 */
                ExternalEvent.prototype.clone = function () {
                    var _this = this;
                    return (function (o) { if (_super.prototype.clone != undefined) {
                        return _super.prototype.clone.call(_this);
                    }
                    else {
                        var clone = Object.create(o);
                        for (var p in o) {
                            if (o.hasOwnProperty(p))
                                clone[p] = o[p];
                        }
                        return clone;
                    } })(this);
                };
                return ExternalEvent;
            }(desmoj.core.simulator.EventAbstract));
            simulator.ExternalEvent = ExternalEvent;
            ExternalEvent["__class"] = "desmoj.core.simulator.ExternalEvent";
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var dist;
        (function (dist) {
            /**
             * Constructs a simple negative-exponentially distributed pseudo random
             * generator with the given value as mean of the distribution. Only positive
             * values are allowed.
             *
             * @param {desmoj.core.simulator.Model} owner
             * Model : The distribution's owner
             * @param {string} name
             * java.lang.String : The distribution's name
             * @param {number} mean
             * double : The mean value for this distribution
             * @param {boolean} showInReport
             * boolean : Flag for producing reports
             * @param {boolean} showInTrace
             * boolean : Flag for producing trace output
             * @class
             * @extends desmoj.core.dist.ContDist
             * @author Tim Lechler
             */
            var ContDistExponential = (function (_super) {
                __extends(ContDistExponential, _super);
                function ContDistExponential(owner, name, mean, showInReport, showInTrace) {
                    var _this = _super.call(this, owner, name, showInReport, showInTrace) || this;
                    _this.mean = 0;
                    _this.mean = mean;
                    return _this;
                }
                /**
                 * Creates the default reporter for the RealDistExponential distribution.
                 *
                 * @return {desmoj.core.report.Reporter} Reporter : The reporter for the RealDistExponential distribution
                 * @see desmoj.core.report.ContDistExponReporter
                 */
                ContDistExponential.prototype.createDefaultReporter = function () {
                    return new desmoj.core.report.ContDistExponReporter(this);
                };
                /**
                 * Returns the mean value of the negative-exponential distribution.
                 *
                 * @return {number} double : the mean value of the negative-exponential distribution
                 */
                ContDistExponential.prototype.getMean = function () {
                    return this.mean;
                };
                /**
                 * Returns the next negative exponential pseudo random number.
                 *
                 * @return {number} Double : The next negative exponential pseudo random number
                 */
                ContDistExponential.prototype.sample = function () {
                    return _super.prototype.sample.call(this);
                };
                /**
                 * Abstract method to map a double <code>p</code> from 0...1 to the
                 * distribution's domain by determining the value x that satisfies
                 * <code>P(X &lt; x) = p</code>.
                 *
                 * @param {number} p double: A value between 0 and 1
                 *
                 * @return {number} N : The value x that satisfies <code>P(X &lt; x) = p</code>
                 */
                ContDistExponential.prototype.getInverseOfCumulativeProbabilityFunction = function (p) {
                    return -Math.log(p) * this.mean;
                };
                return ContDistExponential;
            }(desmoj.core.dist.ContDist));
            dist.ContDistExponential = ContDistExponential;
            ContDistExponential["__class"] = "desmoj.core.dist.ContDistExponential";
        })(dist = core.dist || (core.dist = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var dist;
        (function (dist) {
            /**
             * Creates a stream of pseudo random numbers following a uniform
             * distribution between the lower and the upper value parameter. The
             * specific lower and upper borders of the range of this distribution have
             * to be given here at creation time. Note that the lower border in fact has
             * to be lower than the upper border. If not, the parameters will be swapped
             * to assign the higher value to the upper border of the distribution. Two
             * equal values for upper and lower will be accepted, but result in a
             * constant distribution that will invariably return that given value.
             *
             * @param {desmoj.core.simulator.Model} owner
             * Model : The distribution's owner
             * @param {string} name
             * java.lang.String : The distribution's name
             * @param {number} lowerBorder
             * double : The minimum value for this distribution
             * @param {number} upperBorder
             * double : The maximum value for this distribution
             * @param {boolean} showInReport
             * boolean : Flag for producing reports
             * @param {boolean} showInTrace
             * boolean : Flag for producing trace output
             * @class
             * @extends desmoj.core.dist.ContDist
             * @author Tim Lechler
             */
            var ContDistUniform = (function (_super) {
                __extends(ContDistUniform, _super);
                function ContDistUniform(owner, name, lowerBorder, upperBorder, showInReport, showInTrace) {
                    var _this = _super.call(this, owner, name, showInReport, showInTrace) || this;
                    _this._min = 0;
                    _this._max = 0;
                    if (lowerBorder <= upperBorder) {
                        _this._min = lowerBorder;
                        _this._max = upperBorder;
                    }
                    else {
                        _this._min = upperBorder;
                        _this._max = lowerBorder;
                    }
                    return _this;
                }
                /**
                 * Creates the default reporter for the RealDistUniform distribution.
                 *
                 * @return {desmoj.core.report.Reporter} Reporter : The reporter for the RealDistUniform distribution
                 * @see desmoj.core.report.ContDistUniformReporter
                 */
                ContDistUniform.prototype.createDefaultReporter = function () {
                    return new desmoj.core.report.ContDistUniformReporter(this);
                };
                /**
                 * Returns the lower border of the range of this uniform distribution.
                 *
                 * @return {number} double : The lower border of the range of this uniform
                 * distribution
                 */
                ContDistUniform.prototype.getLower = function () {
                    return this._min;
                };
                /**
                 * Returns the upper border of the range of this distribution.
                 *
                 * @return {number} double : The upper border of the range of this uniform
                 * distribution
                 */
                ContDistUniform.prototype.getUpper = function () {
                    return this._max;
                };
                /**
                 * Returns the next floating point sample from this uniform distribution.
                 * The value returned is basically the uniformly distributed pseudo random
                 * number produced by the underlying random generator stretched to match the
                 * range specified by the client via construtor parameters.
                 *
                 * @return {number} Double : The next floating point sample from this uniform
                 * distribution
                 */
                ContDistUniform.prototype.sample = function () {
                    return _super.prototype.sample.call(this);
                };
                /**
                 * Abstract method to map a double <code>p</code> from 0...1 to the
                 * distribution's domain by determining the value x that satisfies
                 * <code>P(X &lt; x) = p</code>.
                 *
                 * @param {number} p double: A value between 0 and 1
                 *
                 * @return {number} N : The value x that satisfies P(X &lt; x) = p
                 */
                ContDistUniform.prototype.getInverseOfCumulativeProbabilityFunction = function (p) {
                    return this._min + ((this._max - this._min) * p);
                };
                /**
                 * Overrides the same method of <code>desmoj.dist.Distribution</code>. It
                 * makes no sense to set a <code>RealDistUniform</code> object with a
                 * negative lower border to nonNegative. In this case a warning will be
                 * sent. <br>
                 * Sets the nonNegative switch to the given value. If nonNegative is set to
                 * <code>true</code> the distribution returns positive samples only,
                 * otherwise it also produces negative samples, if possible.
                 *
                 * @param {boolean} newValue
                 * boolean : If <code>true</code> the distribution is set to
                 * return positive samples only, otherwise it also produces
                 * negative samples, if possible.
                 */
                ContDistUniform.prototype.setNonNegative = function (newValue) {
                    if (newValue === true && this._min < 0) {
                        this.sendWarning("Attempt to set a RealDistUniform distribution with a negative lowerBorder to nonNegative. This will be done, but doesn\'t make sense!", "RealDistUniform: " + this.getName() + " Method: public void " + "setNonNegative(boolean newValue)", "The given distribution has a negative border but all negative values will be ignored.", "Make sure not to set a RealDistUniform distribution with a negative lowerBorder to nonNegative.");
                    }
                    if (newValue === true && this._max < 0) {
                        this.sendWarning("Attempt to set a RealDistUniform distribution with a negative upperBorder to nonNegative. The command will be ignored!", "RealDistUniform: " + this.getName() + " Method: public void " + "setNonNegative(boolean newValue)", "The given distribution has a negative upper border. When all negative values will be ignored, one won\'t get any values.", "Make sure not to set a RealDistUniform distribution with a negative upperBorder to nonNegative.");
                        return;
                    }
                    this.nonNegative = newValue;
                };
                return ContDistUniform;
            }(desmoj.core.dist.ContDist));
            dist.ContDistUniform = ContDistUniform;
            ContDistUniform["__class"] = "desmoj.core.dist.ContDistUniform";
        })(dist = core.dist || (core.dist = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (demos) {
    var eventsexample;
    (function (eventsexample) {
        /**
         * Constructor of the truck arrival event
         *
         * Used to create a new truck arrival event
         *
         * @param {desmoj.core.simulator.Model} owner the model this event belongs to
         * @param {string} name this event's name
         * @param {boolean} showInTrace flag to indicate if this event shall produce output for the trace
         * @class
         * @extends desmoj.core.simulator.Event
         * @author Olaf Neidhardt, Ruth Meyer
         */
        var TruckArrivalEvent = (function (_super) {
            __extends(TruckArrivalEvent, _super);
            function TruckArrivalEvent(owner, name, showInTrace) {
                var _this = _super.call(this, owner, name, showInTrace) || this;
                _this.myModel = null;
                _this.myModel = owner;
                return _this;
            }
            TruckArrivalEvent.prototype.eventRoutine$demos_eventsexample_Truck = function (truck) {
                this.myModel.truckQueue.insert(truck);
                this.sendTraceNote("TruckQueueLength: " + this.myModel.truckQueue.length());
                if (!this.myModel.idleVCQueue.isEmpty()) {
                    var vanCarrier = this.myModel.idleVCQueue.first();
                    this.myModel.idleVCQueue.remove$desmoj_core_simulator_Entity(vanCarrier);
                    this.myModel.truckQueue.remove$desmoj_core_simulator_Entity(truck);
                    var serviceEnd = new demos.eventsexample.ServiceEndEvent(this.myModel, "ServiceEndEvent", true);
                    serviceEnd.schedule(vanCarrier, truck, new desmoj.core.simulator.TimeSpan(this.myModel.getServiceTime(), def.TimeUnit.MINUTES));
                }
            };
            /**
             * This eventRoutine() describes what happens when a truck
             * enters the terminal.
             *
             * On arrival, the truck will enter the queue (parking lot). It will then
             * check if the van carrier is available.
             * If this is the case, it will occupy the van carrier and schedule a
             * service end event.
             * Otherwise the truck just waits (does nothing).
             * @param {demos.eventsexample.Truck} truck
             */
            TruckArrivalEvent.prototype.eventRoutine = function (truck) {
                if (((truck != null && truck instanceof demos.eventsexample.Truck) || truck === null)) {
                    return this.eventRoutine$demos_eventsexample_Truck(truck);
                }
                else if (((truck != null) || truck === null)) {
                    return this.eventRoutine$desmoj_core_simulator_Entity(truck);
                }
                else
                    throw new Error('invalid overload');
            };
            return TruckArrivalEvent;
        }(desmoj.core.simulator.Event));
        eventsexample.TruckArrivalEvent = TruckArrivalEvent;
        TruckArrivalEvent["__class"] = "demos.eventsexample.TruckArrivalEvent";
    })(eventsexample = demos.eventsexample || (demos.eventsexample = {}));
})(demos || (demos = {}));
(function (demos) {
    var eventsexample;
    (function (eventsexample) {
        /**
         * Constructor of the service end event
         *
         * Used to create a new service end event
         *
         * @param {desmoj.core.simulator.Model} owner the model this event belongs to
         * @param {string} name this event's name
         * @param {boolean} showInTrace flag to indicate if this event shall produce output for the trace
         * @class
         * @extends desmoj.core.simulator.EventOf2Entities
         * @author Olaf Neidhardt, Ruth Meyer
         */
        var ServiceEndEvent = (function (_super) {
            __extends(ServiceEndEvent, _super);
            function ServiceEndEvent(owner, name, showInTrace) {
                var _this = _super.call(this, owner, name, showInTrace) || this;
                _this.myModel = null;
                _this.myModel = owner;
                return _this;
            }
            ServiceEndEvent.prototype.eventRoutine$demos_eventsexample_VanCarrier$demos_eventsexample_Truck = function (vanCarrier, truck) {
                this.sendTraceNote(truck + " leaves the terminal");
                if (!this.myModel.truckQueue.isEmpty()) {
                    var nextTruck = this.myModel.truckQueue.first();
                    this.myModel.truckQueue.remove$desmoj_core_simulator_Entity(nextTruck);
                    var event_1 = new ServiceEndEvent(this.myModel, "ServiceEndEvent", true);
                    event_1.schedule(vanCarrier, nextTruck, new desmoj.core.simulator.TimeSpan(this.myModel.getServiceTime(), def.TimeUnit.MINUTES));
                }
                else {
                    this.myModel.idleVCQueue.insert(vanCarrier);
                }
            };
            /**
             * This eventRoutine() describes what happens when a van carrier finishes
             * loading a truck.
             *
             * The truck leaves the system.
             * The van carrier will then check if there is another truck
             * waiting for service.
             * If there is another truck waiting it will service it.
             * If not it will wait on its parking spot for the next
             * customer to arrive.
             * @param {demos.eventsexample.VanCarrier} vanCarrier
             * @param {demos.eventsexample.Truck} truck
             */
            ServiceEndEvent.prototype.eventRoutine = function (vanCarrier, truck) {
                if (((vanCarrier != null && vanCarrier instanceof demos.eventsexample.VanCarrier) || vanCarrier === null) && ((truck != null && truck instanceof demos.eventsexample.Truck) || truck === null)) {
                    return this.eventRoutine$demos_eventsexample_VanCarrier$demos_eventsexample_Truck(vanCarrier, truck);
                }
                else if (((vanCarrier != null) || vanCarrier === null) && ((truck != null) || truck === null)) {
                    return this.eventRoutine$desmoj_core_simulator_Entity$desmoj_core_simulator_Entity(vanCarrier, truck);
                }
                else
                    throw new Error('invalid overload');
            };
            return ServiceEndEvent;
        }(desmoj.core.simulator.EventOf2Entities));
        eventsexample.ServiceEndEvent = ServiceEndEvent;
        ServiceEndEvent["__class"] = "demos.eventsexample.ServiceEndEvent";
    })(eventsexample = demos.eventsexample || (demos.eventsexample = {}));
})(demos || (demos = {}));
(function (demos) {
    var eventsexample;
    (function (eventsexample) {
        /**
         * Constructs a new TruckGeneratorEvent.
         *
         * @param {desmoj.core.simulator.Model} owner the model this event belongs to
         * @param {string} name this event's name
         * @param {boolean} showInTrace flag to indicate if this event shall produce output for the trace
         * @class
         * @extends desmoj.core.simulator.ExternalEvent
         * @author Olaf Neidhardt, Ruth Meyer
         */
        var TruckGeneratorEvent = (function (_super) {
            __extends(TruckGeneratorEvent, _super);
            function TruckGeneratorEvent(owner, name, showInTrace) {
                return _super.call(this, owner, name, showInTrace) || this;
            }
            /**
             * The eventRoutine() describes the generating of a new truck.
             *
             * It creates a new truck, a new TruckArrivalEvent
             * and schedules itself again for the next new truck generation.
             */
            TruckGeneratorEvent.prototype.eventRoutine = function () {
                var model = this.getModel();
                var truck = new demos.eventsexample.Truck(model, "Truck", true);
                var truckArrival = new demos.eventsexample.TruckArrivalEvent(model, "TruckArrivalEvent", true);
                truckArrival.schedule(truck, new desmoj.core.simulator.TimeSpan(0.0));
                this.schedule$desmoj_core_simulator_TimeSpan(new desmoj.core.simulator.TimeSpan(model.getTruckArrivalTime(), def.TimeUnit.MINUTES));
            };
            return TruckGeneratorEvent;
        }(desmoj.core.simulator.ExternalEvent));
        eventsexample.TruckGeneratorEvent = TruckGeneratorEvent;
        TruckGeneratorEvent["__class"] = "demos.eventsexample.TruckGeneratorEvent";
    })(eventsexample = demos.eventsexample || (demos.eventsexample = {}));
})(demos || (demos = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Creates the external event to stop the debug output for an experiment.
             *
             * @param {desmoj.core.simulator.Model} owner
             * desmoj.Model : The model this external event is associated to
             * @param {boolean} showInTrace
             * boolean : The flag indicating if this external event is shown
             * in the trace output
             * @class
             * @extends desmoj.core.simulator.ExternalEvent
             * @author Tim Lechler
             */
            var ExternalEventDebugOff = (function (_super) {
                __extends(ExternalEventDebugOff, _super);
                function ExternalEventDebugOff(owner, showInTrace) {
                    return _super.call(this, owner, "DebugOff", showInTrace) || this;
                }
                /**
                 * Switches the messagemanager's debug note channel off to stop forwarding
                 * debugnotes to the configured output.
                 */
                ExternalEventDebugOff.prototype.eventRoutine = function () {
                    var ex = this.getModel().getExperiment();
                    if (this.currentlySendTraceNotes())
                        this.sendTraceNote("Debug switched off");
                    ex.getMessageManager().switchOff(desmoj.core.simulator.Experiment.debugnote);
                };
                return ExternalEventDebugOff;
            }(desmoj.core.simulator.ExternalEvent));
            simulator.ExternalEventDebugOff = ExternalEventDebugOff;
            ExternalEventDebugOff["__class"] = "desmoj.core.simulator.ExternalEventDebugOff";
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Creates the external event to start the debug output for an experiment.
             *
             * @param {desmoj.core.simulator.Model} owner
             * desmoj.Model : The model this external event is associated to
             * @param {boolean} showInTrace
             * boolean : The flag indicating if this external event is shown
             * in the trace output
             * @class
             * @extends desmoj.core.simulator.ExternalEvent
             * @author Tim Lechler
             */
            var ExternalEventDebugOn = (function (_super) {
                __extends(ExternalEventDebugOn, _super);
                function ExternalEventDebugOn(owner, showInTrace) {
                    return _super.call(this, owner, "DebugOn", showInTrace) || this;
                }
                /**
                 * Switches the messagemanager's debug note channel on to forward debugnotes
                 * to the configured output.
                 */
                ExternalEventDebugOn.prototype.eventRoutine = function () {
                    var ex = this.getModel().getExperiment();
                    ex.getMessageManager().switchOn(desmoj.core.simulator.Experiment.debugnote);
                    if (this.currentlySendTraceNotes())
                        this.sendTraceNote("Debug switched on");
                };
                return ExternalEventDebugOn;
            }(desmoj.core.simulator.ExternalEvent));
            simulator.ExternalEventDebugOn = ExternalEventDebugOn;
            ExternalEventDebugOn["__class"] = "desmoj.core.simulator.ExternalEventDebugOn";
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Constructs an external event to abort the experiment.
             *
             * @param {desmoj.core.simulator.Model} owner
             * desmoj.Model : The model this external event is associated to
             * @param {string} name
             * java.lang.String : The external event's name
             * @param {boolean} showInTrace
             * boolean : Flag indicating if the external event is shown in
             * the report
             * @class
             * @extends desmoj.core.simulator.ExternalEvent
             * @author Tim Lechler
             */
            var ExternalEventStop = (function (_super) {
                __extends(ExternalEventStop, _super);
                function ExternalEventStop(owner, name, showInTrace) {
                    return _super.call(this, owner, name, showInTrace) || this;
                }
                ExternalEventStop.prototype.eventRoutine$ = function () {
                    this.getModel().getExperiment().setStatus(desmoj.core.simulator.Experiment.STOPPED);
                };
                ExternalEventStop.prototype.eventRoutine$desmoj_core_simulator_Entity = function (who) {
                    if (who != null) {
                        this.sendWarning("Can\'t accept Entity as parameter", "ExternalEvent : " + this.getName() + " Method: void eventRoutine(Entity who)", "External events do not act on entities.", "If you want an event to act on the given Entity use the class Event and override theeventRoutine(Entity who) method in that class.");
                    }
                    this.eventRoutine();
                };
                /**
                 * Do not use this method to implement the external event's eventRoutine!
                 * This method can not be hidden due to the inheritance relationship to the
                 * class <code>Event</code>. Since external events are designed to act on
                 * the model or experiment in general and are not associated to an
                 * individual Entity, you should use the parameterless method
                 * <code>void eventRoutine()</code> instead. Calling this method will result
                 * in a warning message and the parameterless method will be called. The
                 * given Entity will not be changed. Do not override this method in your
                 * special external events!
                 *
                 * @see ExternalEvent#eventRoutine()
                 * @param {desmoj.core.simulator.Entity} who
                 */
                ExternalEventStop.prototype.eventRoutine = function (who) {
                    if (((who != null && who instanceof desmoj.core.simulator.Entity) || who === null)) {
                        return this.eventRoutine$desmoj_core_simulator_Entity(who);
                    }
                    else if (who === undefined) {
                        return this.eventRoutine$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                ExternalEventStop.prototype.schedule$desmoj_core_simulator_TimeSpan = function (dt) {
                    if ((dt == null)) {
                        this.sendWarning("Can\'t schedule external event!", "ExternalEvent : " + this.getName() + " Method: schedule(Entity who, TimeSpan dt)", "The simulation time given as parameter is a null reference.", "Be sure to have a valid TimeSpan reference before calling this method.");
                        return;
                    }
                    if (this.isScheduled()) {
                        this.sendWarning("Can\'t schedule external event! Command ignored.", "ExternalEvent : " + this.getName() + " Method: schedule(Entity wo, TimeSpan dt)", "The external event to be scheduled is already scheduled.", "Use external events only once, do not reuse them multiple times.");
                        return;
                    }
                    if (this.currentlySendTraceNotes()) {
                        this.sendTraceNote("ExternalEvent \'" + this.getName() + "\' scheduled at " + desmoj.core.simulator.TimeOperations.add$desmoj_core_simulator_TimeInstant$desmoj_core_simulator_TimeSpan(this.presentTime(), dt).toString());
                    }
                    this.getModel().getExperiment().getScheduler().scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_EventAbstract$desmoj_core_simulator_TimeSpan(null, this, dt);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("schedules on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                /**
                 * Schedules this external event to make the desired changes to the
                 * experiment or model at the current point of time plus the given span of
                 * time
                 *
                 * @param {desmoj.core.simulator.TimeSpan} dt
                 * TimeSpan : The offset to the current simulation time at which
                 * this external event is to be scheduled
                 * @see SimClock
                 */
                ExternalEventStop.prototype.schedule = function (dt) {
                    if (((dt != null && dt instanceof desmoj.core.simulator.TimeSpan) || dt === null)) {
                        return this.schedule$desmoj_core_simulator_TimeSpan(dt);
                    }
                    else if (((dt != null && dt instanceof desmoj.core.simulator.TimeInstant) || dt === null)) {
                        return this.schedule$desmoj_core_simulator_TimeInstant(dt);
                    }
                    else if (((dt != null && dt instanceof desmoj.core.dist.NumericalDist) || dt === null)) {
                        return this.schedule$desmoj_core_dist_NumericalDist(dt);
                    }
                    else if (dt === undefined) {
                        return this.schedule$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                ExternalEventStop.prototype.schedule$desmoj_core_simulator_TimeInstant = function (when) {
                    if ((when == null)) {
                        this.sendWarning("Can\'t schedule external event!", "ExternalEvent : " + this.getName() + " Method: schedule(Entity who, TimeInstant when)", "The point of simulation time given as parameter is a null reference.", "Be sure to have a valid TimeInstant reference before calling this method.");
                        return;
                    }
                    if (this.isScheduled()) {
                        this.sendWarning("Can\'t schedule external event! Command ignored.", "ExternalEvent : " + this.getName() + " Method: schedule(Entity wo, TimeInstant when)", "The external event to be scheduled is already scheduled.", "Use external events only once, do not reuse them multiple times.");
                        return;
                    }
                    if (this.currentlySendTraceNotes()) {
                        this.sendTraceNote("ExternalEvent \'" + this.getName() + "\' scheduled at " + when.toString());
                    }
                    this.getModel().getExperiment().getScheduler().scheduleNoPreempt$desmoj_core_simulator_Entity$desmoj_core_simulator_EventAbstract$desmoj_core_simulator_TimeInstant(null, this, when);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("schedules on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                /**
                 * Schedules this external event to act on the experiment or model state
                 * directly after the given Schedulable is already set to be activated. Note
                 * that this external event's point of simulation time will be set to be the
                 * same as the Schedulable's time. Thus this external event will occur
                 * directly after the given Schedulable but the simulation clock will not
                 * change. Make sure that the Schedulable given as parameter is actually
                 * scheduled.
                 *
                 * @param {desmoj.core.simulator.Schedulable} after
                 * Schedulable : The Schedulable this external event should be
                 * scheduled after
                 */
                ExternalEventStop.prototype.scheduleAfter = function (after) {
                    if ((after == null)) {
                        this.sendWarning("Can\'t schedule external event! Command ignored.", "ExternalEvent : " + this.getName() + " Method: scheduleAfter(Schedulable after, " + "Entity who)", "The Schedulable given as parameter is a null reference.", "Be sure to have a valid Schedulable reference for this external event to be scheduled with.");
                        return;
                    }
                    if (this.isScheduled()) {
                        this.sendWarning("Can\'t schedule external event! Command ignored.", "ExternalEvent : " + this.getName() + " Method: scheduleAfter(Schedulable after)", "The external event to be scheduled is already scheduled.", "Use method external events only once, do not use them multiple times.");
                        return;
                    }
                    if (!after.isScheduled()) {
                        this.sendWarning("Can\'t schedule external event! Command ignored.", "ExternalEvent : " + this.getName() + " Method: scheduleAfter(Schedulable after)", "The Schedulable \'" + after.getName() + "\' given as a positioning " + "reference has to be already scheduled but is not.", "Use method isScheduled() of any Schedulable to find out if it is already scheduled.");
                        return;
                    }
                    if (this.currentlySendTraceNotes()) {
                        this.sendTraceNote("external event \'" + this.getName() + "\' scheduled after \'" + after.getName() + "\' at " + after.getEventNotes()[after.getEventNotes().length - 1].getTime().toString());
                    }
                    this.getModel().getExperiment().getScheduler().scheduleAfter$desmoj_core_simulator_Schedulable$desmoj_core_simulator_Entity$desmoj_core_simulator_EventAbstract(after, null, this);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("scheduleAfter " + after.getQuotedName() + " on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                /**
                 * Schedules this external event to act on the experiment or model state
                 * directly before the given Schedulable is already set to be activated.
                 * Note that this external event's point of simulation time will be set to
                 * be the same as the Schedulable's time. Thus this external event will
                 * occur directly before the given Schedulable but the simulation clock will
                 * not change. Make sure that the Schedulable given as parameter is actually
                 * scheduled.
                 *
                 * @param {desmoj.core.simulator.Schedulable} before
                 * Schedulable : The Schedulable this external event should be
                 * scheduled before
                 */
                ExternalEventStop.prototype.scheduleBefore = function (before) {
                    if ((before == null)) {
                        this.sendWarning("Can\'t schedule external event! Command ignored.", "ExternalEvent : " + this.getName() + " Method: scheduleBefore(Schedulable before, " + "Entity who)", "The Schedulable given as parameter is a null reference.", "Be sure to have a valid Schedulable reference for this external event to be scheduled with.");
                        return;
                    }
                    if (this.isScheduled()) {
                        this.sendWarning("Can\'t schedule external event! Command ignored.", "ExternalEvent : " + this.getName() + " Method: scheduleBefore(Schedulable before)", "The external event to be scheduled is already scheduled.", "Use method external events only once, do not use them multiple times.");
                        return;
                    }
                    if (!before.isScheduled()) {
                        this.sendWarning("Can\'t schedule external event! Command ignored.", "ExternalEvent : " + this.getName() + " Method: scheduleBefore(Schedulable before)", "The Schedulable \'" + before.getName() + "\' given as a " + "positioning reference has to be already " + "scheduled but is not.", "Use method isScheduled() of any Schedulable to find out if it is already scheduled.");
                        return;
                    }
                    if (this.currentlySendTraceNotes()) {
                        this.sendTraceNote("external event \'" + this.getName() + "\' scheduled before \'" + before.getName() + "\' at " + before.getEventNotes()[0].getTime().toString());
                    }
                    this.getModel().getExperiment().getScheduler().scheduleBefore$desmoj_core_simulator_Schedulable$desmoj_core_simulator_Entity$desmoj_core_simulator_EventAbstract(before, null, this);
                    if (this.currentlySendDebugNotes()) {
                        this.sendDebugNote("scheduleBefore " + before.getQuotedName() + " on EventList<br>" + this.getModel().getExperiment().getScheduler().toString());
                    }
                };
                return ExternalEventStop;
            }(desmoj.core.simulator.ExternalEvent));
            simulator.ExternalEventStop = ExternalEventStop;
            ExternalEventStop["__class"] = "desmoj.core.simulator.ExternalEventStop";
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Creates the external event to stop the trace output for an experiment.
             *
             * @param {desmoj.core.simulator.Model} owner
             * desmoj.Model : The model this external event is associated to
             * @param {boolean} showInTrace
             * boolean : The flag indicating if this external event is shown
             * in the trace output
             * @class
             * @extends desmoj.core.simulator.ExternalEvent
             * @author Tim Lechler
             */
            var ExternalEventTraceOff = (function (_super) {
                __extends(ExternalEventTraceOff, _super);
                function ExternalEventTraceOff(owner, showInTrace) {
                    return _super.call(this, owner, "TraceOff", showInTrace) || this;
                }
                ExternalEventTraceOff.prototype.eventRoutine = function (who) {
                    if (who === undefined) {
                        return this.eventRoutine$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                ExternalEventTraceOff.prototype.eventRoutine$ = function () {
                    var ex = this.getModel().getExperiment();
                    if (this.currentlySendTraceNotes())
                        this.sendTraceNote("Trace switched off");
                    ex.getMessageManager().switchOff(desmoj.core.simulator.Experiment.tracenote);
                };
                return ExternalEventTraceOff;
            }(desmoj.core.simulator.ExternalEvent));
            simulator.ExternalEventTraceOff = ExternalEventTraceOff;
            ExternalEventTraceOff["__class"] = "desmoj.core.simulator.ExternalEventTraceOff";
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var simulator;
        (function (simulator) {
            /**
             * Creates the external event to start the trace output for an experiment.
             *
             * @param {desmoj.core.simulator.Model} owner
             * desmoj.Model : The model this external event is associated to
             * @param {boolean} showInTrace
             * boolean : The flag indicating if this external event is shown
             * in the trace output
             * @class
             * @extends desmoj.core.simulator.ExternalEvent
             * @author Tim Lechler
             */
            var ExternalEventTraceOn = (function (_super) {
                __extends(ExternalEventTraceOn, _super);
                function ExternalEventTraceOn(owner, showInTrace) {
                    return _super.call(this, owner, "TraceOn", showInTrace) || this;
                }
                ExternalEventTraceOn.prototype.eventRoutine = function (who) {
                    if (who === undefined) {
                        return this.eventRoutine$();
                    }
                    else
                        throw new Error('invalid overload');
                };
                ExternalEventTraceOn.prototype.eventRoutine$ = function () {
                    var ex = this.getModel().getExperiment();
                    ex.getMessageManager().switchOn(desmoj.core.simulator.Experiment.tracenote);
                    if (this.currentlySendTraceNotes())
                        this.sendTraceNote("Trace switched on");
                };
                return ExternalEventTraceOn;
            }(desmoj.core.simulator.ExternalEvent));
            simulator.ExternalEventTraceOn = ExternalEventTraceOn;
            ExternalEventTraceOn["__class"] = "desmoj.core.simulator.ExternalEventTraceOn";
        })(simulator = core.simulator || (core.simulator = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
(function (desmoj) {
    var core;
    (function (core) {
        var dist;
        (function (dist) {
            /**
             * Constructs a simple Weibull-distributed pseudo random
             * generator with the given values as mean and beta of the distribution.
             * Only positive values are allowed.
             *
             * @param {desmoj.core.simulator.Model} owner
             * Model : The distribution's owner
             * @param {string} name
             * java.lang.String : The distribution's name
             * @param {number} mean
             * double : The mean value for this distribution
             * @param {number} beta
             * double : The beat value for this distribution
             * @param {boolean} showInReport
             * boolean : Flag for producing reports
             * @param {boolean} showInTrace
             * boolean : Flag for producing trace output
             * @class
             * @extends desmoj.core.dist.ContDistExponential
             * @author Tim Lechler, Johannes G&ouml;bel
             */
            var ContDistWeibull = (function (_super) {
                __extends(ContDistWeibull, _super);
                function ContDistWeibull(owner, name, mean, beta, showInReport, showInTrace) {
                    var _this = _super.call(this, owner, name, mean, showInReport, showInTrace) || this;
                    _this.beta = 0;
                    _this.beta = beta;
                    return _this;
                }
                /**
                 * Returns the beta value of the Weibull distribution.
                 *
                 * @return {number} double : the mean value of the Weibull distribution
                 */
                ContDistWeibull.prototype.getBeta = function () {
                    return this.beta;
                };
                /**
                 * Returns the next pseudo random number of the Weibull distribution.
                 *
                 * @return {number} Double : The next negative exponential pseudo random number
                 */
                ContDistWeibull.prototype.sample = function () {
                    return _super.prototype.sample.call(this);
                };
                /**
                 * Abstract method to map a double <code>p</code> from 0...1 to the
                 * distribution's domain by determining the value x that satisfies
                 * <code>P(X &lt; x) = p</code>.
                 *
                 * @param {number} p double: A value between 0 and 1
                 *
                 * @return {number} N : The value x that satisfies <code>P(X &lt; x) = p</code>
                 */
                ContDistWeibull.prototype.getInverseOfCumulativeProbabilityFunction = function (p) {
                    return Math.pow(_super.prototype.getInverseOfCumulativeProbabilityFunction.call(this, p), 1 / this.beta);
                };
                return ContDistWeibull;
            }(desmoj.core.dist.ContDistExponential));
            dist.ContDistWeibull = ContDistWeibull;
            ContDistWeibull["__class"] = "desmoj.core.dist.ContDistWeibull";
        })(dist = core.dist || (core.dist = {}));
    })(core = desmoj.core || (desmoj.core = {}));
})(desmoj || (desmoj = {}));
desmoj.core.statistic.StatisticObject.PRECISION_$LI$();
desmoj.core.statistic.StatisticObject.UNDEFINED_$LI$();
desmoj.core.report.FileOutput.eol_$LI$();
desmoj.core.report.FileOutput.fileSystem_$LI$();
desmoj.core.report.FileOutput.NORMAL_FILE_ACCESS_$LI$();
desmoj.core.simulator.TimeOperations.myTimeFormatter_$LI$();
desmoj.core.simulator.TimeOperations.referenceUnit_$LI$();
desmoj.core.simulator.TimeOperations.epsilon_$LI$();
desmoj.core.simulator.TimeInstant.DEFAULT_PREFERRED_TIMEZONE_$LI$();
def.TimeUnit_$WRAPPER.MAX_$LI$();
def.TimeUnit_$WRAPPER.C6_$LI$();
def.TimeUnit_$WRAPPER.C5_$LI$();
def.TimeUnit_$WRAPPER.C4_$LI$();
def.TimeUnit_$WRAPPER.C3_$LI$();
def.TimeUnit_$WRAPPER.C2_$LI$();
def.TimeUnit_$WRAPPER.C1_$LI$();
def.TimeUnit_$WRAPPER.C0_$LI$();
def.Color.BLUE_$LI$();
def.Color.blue_$LI$();
def.Color.CYAN_$LI$();
def.Color.cyan_$LI$();
def.Color.MAGENTA_$LI$();
def.Color.magenta_$LI$();
def.Color.GREEN_$LI$();
def.Color.green_$LI$();
def.Color.YELLOW_$LI$();
def.Color.yellow_$LI$();
def.Color.ORANGE_$LI$();
def.Color.orange_$LI$();
def.Color.PINK_$LI$();
def.Color.pink_$LI$();
def.Color.RED_$LI$();
def.Color.red_$LI$();
def.Color.BLACK_$LI$();
def.Color.black_$LI$();
def.Color.DARK_GRAY_$LI$();
def.Color.darkGray_$LI$();
def.Color.GRAY_$LI$();
def.Color.gray_$LI$();
def.Color.LIGHT_GRAY_$LI$();
def.Color.lightGray_$LI$();
def.Color.WHITE_$LI$();
def.Color.white_$LI$();
demos.eventsexample.EventsExample.main(null);
